<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker中的-it和-d代表的含义</title>
      <link href="/hexo-blog/2024/06/25/docker%E4%B8%AD%E7%9A%84-it%E5%92%8C-d%E4%BB%A3%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89/"/>
      <url>/hexo-blog/2024/06/25/docker%E4%B8%AD%E7%9A%84-it%E5%92%8C-d%E4%BB%A3%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="docker中的-it和-d代表的含义"><a href="#docker中的-it和-d代表的含义" class="headerlink" title="docker中的-it和-d代表的含义"></a>docker中的-it和-d代表的含义</h1><p>在Docker中，<code>-it</code> 和 <code>-d</code> 是两个非常常用的命令行选项，它们分别控制容器的运行模式，具体含义如下：</p><h3 id="it"><a href="#it" class="headerlink" title="-it"></a>-it</h3><ul><li><strong>i</strong>: 代表 <code>interactive</code>（交互式）。这个选项让容器的标准输入（stdin）保持打开，允许你与容器进行交互，比如通过命令行输入指令。</li><li><strong>t</strong>: 代表 <code>tty</code>（终端类型）。它为容器分配一个伪终端，使得容器的输出格式更加友好，看起来就像在本地终端操作一样。这对于需要终端交互的场景非常有用，比如运行bash shell。</li></ul><p>综上，使用 <code>-it</code> 参数启动的容器通常用于需要用户交互的场景，比如进入容器的命令行界面进行操作。</p><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><ul><li><strong>d</strong>: 代表 <code>detach</code>（分离）。使用这个选项启动容器时，容器会在后台以守护进程的方式运行。这意味着容器会在非交互模式下启动，不会把控制台输出直接绑定到当前的终端，也不会接收来自终端的输入。这对于不需要用户交互的服务，如Web服务器、数据库等长期运行的服务非常有用。</li></ul><h3 id="使用场景对比"><a href="#使用场景对比" class="headerlink" title="使用场景对比"></a>使用场景对比</h3><ul><li><p><strong>对于开发或测试环境</strong>，当你需要进入容器内部进行一些手动配置或测试时，通常会使用 <code>-it</code> 选项。例如，<code>docker run -dit --name my-python python:3.9</code> 命令会启动一个新的Python环境的容器在后台，为容器分配一个伪终端。虽然在后台模式下，这个终端对用户直接交互不是必需的，但它可以影响某些需要终端环境的应用程序的行为，尽管实际效果用户可能感知不到，尤其是在没有附加到容器的情况下。</p></li><li><p><strong>而对于生产部署或者需要作为服务运行的容器</strong>，则倾向于使用 <code>-d</code> 选项使其以后台方式运行。例如，部署一个Web应用可能会用到 <code>docker run -d -p 80:80 nginx</code>，这将启动一个Nginx服务并将主机的80端口映射到容器的80端口，而容器在后台安静运行，不影响当前终端的使用。</p></li></ul><h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p>在某些情况下，你可能需要先使用 <code>-it</code> 进入容器进行一些初始化配置，然后通过 <code>CTRL+P CTRL+Q</code>（而非 <code>CTRL+C</code>）优雅地脱离容器而不终止它，使其继续在后台运行。但要注意，一旦使用 <code>-d</code>，容器就不会直接提供交互式终端。</p><p>总之，选择 <code>-it</code> 或 <code>-d</code> 主要取决于你希望如何管理容器以及容器内应用程序的需求。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的冷知识</title>
      <link href="/hexo-blog/2024/06/21/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/"/>
      <url>/hexo-blog/2024/06/21/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="git的冷知识"><a href="#git的冷知识" class="headerlink" title="git的冷知识"></a>git的冷知识</h1><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化的时候默认没有名字的分支</span></span><br><span class="line"><span class="comment"># gitte提交(默认分支为master)只有你执行了git push origin master之后才会与本地产生联系，本地分支被命名为master分支</span></span><br><span class="line"><span class="comment"># github提交(默认分支为main)</span></span><br><span class="line">git branch -M main <span class="comment"># 将未命名的分支重命名为main分支，与远程默认的origin/main匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单纯的想改分支名</span></span><br><span class="line">git branch -M main-back <span class="comment"># 当前分支为main-front，执行此git指令，分支改名为main-back</span></span><br></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main默认的远程分支是main</span></span><br><span class="line"><span class="comment"># git push 远程仓库别名 本地分支名:远程分支名</span></span><br><span class="line">git push origin main <span class="comment"># 效果相当与git push origin main:main</span></span><br></pre></td></tr></table></figure><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git log 打印的默认是打印当前本地分支对应的远程分支的提交历史</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 假设当前是main分支,等价于查看origin/main分支的提交信息,即git log origin/main</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git log 查看指定分支的提交历史</span></span><br><span class="line">git <span class="built_in">log</span> upstream/main</span><br><span class="line"><span class="comment"># 如果想要查看所有分支的提交历史</span></span><br><span class="line">git config --global alias.tree <span class="string">&#x27;log --all --graph --decorate --oneline&#x27;</span></span><br><span class="line">git tree <span class="comment"># 可以展示所有本地分支和远程跟踪分支的提交历史</span></span><br></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git fetch 会把默认的origin仓库的最新代码拉到本地，但是不会与本地代码合并</span></span><br><span class="line"><span class="comment"># 同时git fetch也可以指定仓库,指定拉取的分支</span></span><br><span class="line">git fetch upstream main <span class="comment"># 将upstream远程仓库中的main分支拉取到本地，并且不会产生合并</span></span><br></pre></td></tr></table></figure><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git的diff算法，将本地的记录和远程分支的代码作比较</span></span><br><span class="line"><span class="comment"># 按 Space 键向下翻页，按 b 键回退一页，按 q 键退出分页器</span></span><br><span class="line">git diff main origin/main <span class="comment"># 输出为空则没有差异</span></span><br></pre></td></tr></table></figure><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快合并,不会产生新的合并历史</span></span><br><span class="line">git merge origin/main <span class="comment"># 假设当前为main分支，把远程的main分支合并到当前分支(--ff) </span></span><br><span class="line"><span class="comment"># 慢合并,会产生新的提交历史</span></span><br><span class="line">git merge origin/main --no-ff <span class="comment"># 执行后会进入vim模式,书写commmit信息,需要重新提交到origin/main</span></span><br></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin main </span><br><span class="line">==&gt; git fetch origin main &amp;&amp; git merge origin/main --ff <span class="comment"># 快合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般合并的较好解决方式</span></span><br><span class="line">git fetch origin main</span><br><span class="line"><span class="comment"># 查看本地main和远程main的差异</span></span><br><span class="line">git diff main origin/main</span><br><span class="line"><span class="comment"># 选择合并的方式 --ff,--no-ff</span></span><br><span class="line">git merge origin/main [options...]</span><br><span class="line"><span class="comment"># 再手动解决冲突</span></span><br><span class="line">vim filename</span><br><span class="line"><span class="comment"># 重新提交</span></span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">&quot;合并冲突&quot;</span> &amp;&amp; git push</span><br></pre></td></tr></table></figure><h3 id="–no-ff和–ff的区别"><a href="#–no-ff和–ff的区别" class="headerlink" title="–no-ff和–ff的区别"></a>–no-ff和–ff的区别</h3><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240623012537701.png" alt="image-20240623012537701"></p><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/164a116afdfd225ed66c7a6bb9057c8a.png" alt="img"></p><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240622211200880.png" alt="image-20240622211200880"></p><blockquote><p>明显–no-ff更加适合commit的回退，使用–ff需要手动回退多次，因为–no-ff生成一个合并的commit提交，</p><p>git revert -m [position] <commit-id>可以选择保留哪边</p></blockquote><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类似git merge只是使提交历史更加线性</span></span><br><span class="line">git fetch origin main</span><br><span class="line">git diff main origin/main</span><br><span class="line">git rebase origin/main</span><br></pre></td></tr></table></figure><h4 id="git-rebase-前"><a href="#git-rebase-前" class="headerlink" title="git rebase 前"></a>git rebase 前</h4><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240622154204336.png" alt="image-20240622154204336"></p><h4 id="git-rebase-后"><a href="#git-rebase-后" class="headerlink" title="git rebase 后"></a>git rebase 后</h4><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240622154355094.png" alt="image-20240622154355094"></p><blockquote><p>可以发现通过rebase本质改变的使origin&#x2F;main的位置，origin&#x2F;main在本地分支下游，就算修改了origin&#x2F;main的位置也能保证提交历史的线性</p></blockquote><h3 id="git-merge和git-rebase的取舍"><a href="#git-merge和git-rebase的取舍" class="headerlink" title="git merge和git rebase的取舍"></a>git merge和git rebase的取舍</h3><blockquote><p><code>git merge</code> 适合于希望保持历史完整性和追踪合并事件的场景。</p><p><code>git rebase</code> 更倾向于维护简洁、线性的提交历史，尤其是在个人工作流或准备提交前的整理阶段。</p></blockquote><h3 id="git-merge中–ff和–no-ff的取舍"><a href="#git-merge中–ff和–no-ff的取舍" class="headerlink" title="git merge中–ff和–no-ff的取舍"></a>git merge中–ff和–no-ff的取舍</h3><blockquote><p><code>--ff</code>（fast-forward）追求简洁，直接移动指针，适用于内部开发或无合并冲突的简单情况。</p><p><code>--no-ff</code>强制创建合并提交，明晰历史分界，更适合团队协作和需要明确追踪合并历史的场景。</p></blockquote><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 撤销到某一次commit之前，并生成一次新的commit提交(记录回退操作)</span></span><br><span class="line">git revert &lt;commit-id&gt; <span class="comment"># 不是合并提交</span></span><br><span class="line"><span class="comment"># 合并提交</span></span><br><span class="line">git show &lt;commit-id&gt; <span class="comment"># 查看合并的两个分支的位置,第一个对应position为1,第二个对应position为2</span></span><br><span class="line">git revert -m &lt;position&gt; &lt;commit-id&gt; <span class="comment"># position是commit保留的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后需要重新提交回退信息</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h4 id="普通提交的撤销"><a href="#普通提交的撤销" class="headerlink" title="普通提交的撤销"></a>普通提交的撤销</h4><p>回退到”windows新增4.txt之前”,此时当前分支文件只有1.txt,2.txt,3.txt</p><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240622170518165.png" alt="image-20240622170518165"></p><h4 id="合并分支的撤销"><a href="#合并分支的撤销" class="headerlink" title="合并分支的撤销"></a>合并分支的撤销</h4><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240623012604881.png" alt="image-20240623012604881"></p><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240623012621449.png" alt="image-20240623012621449"></p><blockquote><p>此时1.txt内容回退到commit(操作系统windows.上的1.txt提交)后的内容</p></blockquote><blockquote><p><code>git revert &lt;commit&gt;</code> 允许你创建一个新的提交来撤销那个引入问题的提交中的所有更改，而不会影响其他提交。这样既修复了问题，又保持了提交历史的清晰和完整，展现了问题是如何被解决的，这对于团队协作和后期的代码审查、问题追踪非常有帮助。</p></blockquote><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回退到指定版本</span></span><br><span class="line">git reset [--soft | --mixed | --hard] [HEAD]</span><br><span class="line"></span><br><span class="line"><span class="comment"># --mixed(默认)</span></span><br><span class="line">git reset --mixed [HEAD] <span class="comment"># 不会暂存到本地,需要手动add和commit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --soft</span></span><br><span class="line">git reset --soft [HEAD] <span class="comment"># 会暂存到本地,不需要手动add和commit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --hard(危险操作)</span></span><br><span class="line">git reset --soft [HEAD] <span class="comment"># 会暂存到本地,清空HEAD之后的所有commit记录</span></span><br></pre></td></tr></table></figure><h4 id="–mixed"><a href="#–mixed" class="headerlink" title="–mixed"></a>–mixed</h4><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240622181709378.png" alt="image-20240622181709378"></p><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240622181752213.png" alt="image-20240622181752213"></p><h4 id="–soft"><a href="#–soft" class="headerlink" title="–soft"></a>–soft</h4><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240622182035541.png" alt="image-20240622182035541"></p><h4 id="–hard"><a href="#–hard" class="headerlink" title="–hard"></a>–hard</h4><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240622190945940.png" alt="image-20240622190945940"></p><blockquote><p>与–soft区别就是暂存区的文件也会回退,4.txt已经访问不到了</p></blockquote><h3 id="git-reflog-备份神器"><a href="#git-reflog-备份神器" class="headerlink" title="git reflog(备份神器)"></a>git reflog(备份神器)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假如你执行了以下命令</span></span><br><span class="line">git reset &lt;commit-id&gt; --hard &amp;&amp; git push -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># git reflog可以查看本地的head变化的历史</span></span><br><span class="line"><span class="comment"># 只要 HEAD 发生变化，就可以通过 reflog 查看到</span></span><br><span class="line">git reset &lt;commit-id&gt; --soft &amp;&amp; git push -f <span class="comment"># 就能回退到之前强制推送前远程仓库的状态</span></span><br><span class="line"><span class="comment"># 一般这个commit-id使第二个(HEAD&#123;1&#125;),因为在上面指令reset时HEAD指向改变了，所以是第二个</span></span><br><span class="line"><span class="comment"># HEAD&#123;n&#125;,n代表偏移量</span></span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/img/note/git%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-20240622191703199.png" alt="image-20240622191703199"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记</title>
      <link href="/hexo-blog/2024/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
      <url>/hexo-blog/2024/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（OS）"><a href="#操作系统（OS）" class="headerlink" title="操作系统（OS）"></a>操作系统（OS）</h1><h2 id="1-计算机系统概述"><a href="#1-计算机系统概述" class="headerlink" title="1.计算机系统概述"></a>1.计算机系统概述</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><blockquote><p>什么是操作系统？</p></blockquote><p>操作系统（Operating Ststem， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p><blockquote><p>操作系统在系统中的位置</p></blockquote><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/fe9e38177511e4b0e4027a6a0e98ffb2-17188584822421.png" alt="在这里插入图片描述"></p><blockquote><p>操作系统的功能和目标</p></blockquote><ol><li>系统资源的管理者</li></ol><ul><li>文件管理</li><li>内存管理</li><li>处理机（CPU）管理</li><li>设备（计算机硬件，例如摄像头）管理</li></ul><ol start="2"><li>用户和计算机硬件之间的接口</li></ol><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/682bed8e1943ba0004c2055966760a32-17188584822423.png" alt="image-20210803155903894"></p><ol start="3"><li>对硬件机器的拓展</li></ol><blockquote><p>操作系统的四个特征</p></blockquote><ol><li>并发</li></ol><p>并发是指两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，在微观上是交替发生的。</p><p>易混淆的概念——并行：两个或多个事件在同一时刻同时发生</p><ol start="2"><li>共享</li></ol><p>共享即资源共享，是指系统中的资源内存中多个并发执行的进程共同使用。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/8cb1f49e8ac62fd06470326751283d9f-17188584822435.png" alt="image-20210803160930275"></p><p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)</p><p>生活实例:</p><ul><li>互斥共享方式:使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</li><li>同时共享方式:使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</li></ul><ol start="3"><li>虚拟</li></ol><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/33ac7e25259c9f6616d74c77789cff96-17188584822437.png" alt="image-20210803161622408"></p><ol start="4"><li>异步</li></ol><p>异步是指，在多道程序环境下，允许多个程序并发执行，但<strong>由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</strong></p><ul><li>只有系统拥有并发性，才有可能导致异步性。</li></ul><h3 id="2-操作系统的运行机制和体系结构"><a href="#2-操作系统的运行机制和体系结构" class="headerlink" title="2.操作系统的运行机制和体系结构"></a>2.操作系统的运行机制和体系结构</h3><ul><li>指令</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/c3d1276e4e694448d8c726df56840444-17188584822439.png" alt="image-20210803163918128"></p><ul><li>CPU</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1376755e1fea3a6a9de7e62ca02461b4-171885848224311.png" alt="image-20210803163953265"></p><ul><li>程序</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/0d8b6714442b0f3cf443a7caa9500c66-171885848224315.png" alt="image-20210803164014423"></p><ul><li>操作系统的内核</li></ul><p>由于内核划分功能的不同，内核分为大内核和微内核。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/414046c0f1b465596777ecf359e87b32-171885848224313.png" alt="image-20210803164737354"></p><ul><li>大内核和微内核的优缺点</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/a7546e379bb46da49bc3a59e6741f076-171885848224417.png" alt="image-20210803164935729"></p><p>类比:</p><ul><li><p>操作系统的体系结构问题与企业的管理问题很相似。</p></li><li><p>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接</p></li><li><p>大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织结构混乱，难以维护。</p></li><li><p>微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护;缺点是效率低。</p></li></ul><h3 id="3-中断和异常"><a href="#3-中断和异常" class="headerlink" title="3.中断和异常"></a>3.中断和异常</h3><h4 id="1-概念和作用"><a href="#1-概念和作用" class="headerlink" title="1.概念和作用"></a>1.概念和作用</h4><p><strong>中断</strong>是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p><ol><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li><li>对于不同的中断信号，会进行不同的处理。</li><li>有了中断，才能实现多道程序并发执行。</li><li>“用户态→核心态”是通过中断实现的，<strong>并且中断是唯一途径</strong>。“核心态→用户态”的切换是通过执行一个特权指令，将程序状态字（ PSW）的标志位设置为 “用户态”。</li></ol><h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h4><ul><li>中断信号的来源来自CPU内部称为内中断，外部称为外中断。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/f91b708e8dc66811d113b9fb0e69890a-171885848224419.png" alt="image-20210803172625970"></p><h3 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4.系统调用"></a>4.系统调用</h3><h4 id="1-含义"><a href="#1-含义" class="headerlink" title="1.含义"></a>1.含义</h4><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/d119d41b87d6698af254bb54c388f63e-171885848224421.png" alt="image-20210803173308247"></p><h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h4><p><strong>应用程序通过系统调用请求操作系统的服务</strong>。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;o操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。<strong>这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</strong></p><h4 id="3-系统调用和库函数的区别"><a href="#3-系统调用和库函数的区别" class="headerlink" title="3.系统调用和库函数的区别"></a>3.系统调用和库函数的区别</h4><p>编程语言（c,java）中里边有很多库函数，其实它们（不是所有的库函数）就是将系统调用封装起来，隐藏一些细节，使上层进行系统调用更加方便。</p><h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h4><ul><li>系统调用发生在用户态，对系统调用的处理发生在核心态。</li><li>执行陷入指令（自陷指令或访管指令）会处理内中断，使处理器（CPU）从用户态进入核心态。</li></ul><h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h2><h3 id="1-进程的定义，组成，组织方式，特征"><a href="#1-进程的定义，组成，组织方式，特征" class="headerlink" title="1.进程的定义，组成，组织方式，特征"></a>1.进程的定义，组成，组织方式，特征</h3><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h4><p>程序： 就是指令序列</p><p>引入多道程序（CPU可以并发执行多个程序）之后，为了方便操作系统进行管理，引入了进程，进程实体的概念。</p><p><strong>PCB，程序段，数据段三部分构成了进程实体（也叫作进程映像）</strong>。一般情况下，我们把进程实体简称为进程。</p><p>例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB.</p><p><strong>PCB是进程存在的唯一标识。</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/37d1c420af34f332857bb3718a22689b-171885848224423.png" alt="image-20210804132427626"></p><h4 id="2-进程的组织方式"><a href="#2-进程的组织方式" class="headerlink" title="2.进程的组织方式"></a>2.进程的组织方式</h4><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。<br>注: 进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p><p>相当于java中的链表和数组。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/202202b3dbf97314063939d4df5c5236-171885848224425.png" alt="image-20210804133435317"></p><h4 id="3-进程的特征"><a href="#3-进程的特征" class="headerlink" title="3.进程的特征"></a>3.进程的特征</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/127792e5036ff16b86bf3e6ebeb1bfd0-171885848224427.png" alt="image-20210804133900620"></p><h3 id="2-进程的状态和转换"><a href="#2-进程的状态和转换" class="headerlink" title="2.进程的状态和转换"></a>2.进程的状态和转换</h3><h4 id="1-状态"><a href="#1-状态" class="headerlink" title="1.状态"></a>1.状态</h4><p>进程是程序的一次执行。在这个过程中，进程的状态会有各种变化。为了方便各个进程的管理，操作系统将进程划分为几个状态。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/d2cb6a8ab8fa8d9478c3f33cc97d95df-171885848224529.png" alt="image-20210804134612092"></p><p>除此之外，进程还有两种状态。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/6eff7a6300e0a9f8fbacdc6811dcde91-171885848224531.png" alt="image-20210804134807573"></p><h4 id="2-转换"><a href="#2-转换" class="headerlink" title="2.转换"></a>2.转换</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/e3bb02ed85fbde30d8e7f6a53d6f1432-171885848224533.png" alt="image-20210804135200848"></p><h3 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3.进程控制"></a>3.进程控制</h3><blockquote><p>含义</p></blockquote><p><strong>进程控制就是要实现进程状态转换。</strong></p><blockquote><p>实现</p></blockquote><p><strong>进程控制由原语实现。</strong>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，<strong>在执行过程中不可被中断</strong>。</p><p>原语采用 “关中断指令” 和 “开中断指令” 来实现。 注意： 原语运行在核心态。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/898802e6075ffa6a41d16e06342f1101-171885848224535.png" alt="image-20210804140224825"></p><p>那么原语是如何实现进程状态的转换呢？</p><ol><li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<br>a.所有的进程控制原语一定都会修改进程状态标志<br>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>c.某进程开始运行前必然要恢复期运行环境</li><li>将PCB插入合适的队列</li><li>分配&#x2F;回收资源</li></ol><p>具体实现如图所示：</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/7ae4afc1ea4d3c3628ec52b99b228917-171885848224537.png" alt="image-20210804140655847"></p><h3 id="4-进程通信"><a href="#4-进程通信" class="headerlink" title="4.进程通信"></a>4.进程通信</h3><blockquote><p>含义</p></blockquote><p>进程通信就是进程之间的信息交换。</p><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p><p>操作系统提供了三种方法：共享存储，消息传递，管道通信。</p><h4 id="1-共享存储"><a href="#1-共享存储" class="headerlink" title="1.共享存储"></a>1.共享存储</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/3e425e65a1e27ad00a15c004b5503900-171885848224539.png" alt="image-20210804141304538"></p><h4 id="2-管道通信"><a href="#2-管道通信" class="headerlink" title="2.管道通信"></a>2.管道通信</h4><p>1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。<br>2.各进程要互斥地访问管道。<br>3.数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取后，管道变空，此时读进程的read()系统调用将被阻塞。<br>4.<strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong><br>5．数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程最多只能有一个，否则可能会有读错数据的情况。</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/14748e1b28c2344372baa69437fb885f-171885848224641.png" alt="image-20210804141624412"></p><h4 id="3-消息传递"><a href="#3-消息传递" class="headerlink" title="3.消息传递"></a>3.消息传递</h4><p>进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息” 两个原语进行数据交换。</p><p>类似于Http协议。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/da5a742699dbec1bd5288c11f3f3d496-171885848224643.png" alt="image-20210804142126570"></p><h3 id="5-线程概念和多线程模型"><a href="#5-线程概念和多线程模型" class="headerlink" title="5.线程概念和多线程模型"></a>5.线程概念和多线程模型</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>有的进程需要同时做很多事，例如用QQ来进行聊天，发送文件等，而传统的进程只能<strong>串行</strong>执行一系列程序。因此，引入“线程”，来增加并发度。</p><ul><li><p>可以把线程理解为轻量级的进程。</p></li><li><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p></li><li><p>引入线程后，进程作为除CPU之外的系统资源的分配单元。</p></li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/3551b2efc325d9eeb84ba20b42039ce7-171885848224645.png" alt="image-20210804142809083"></p><h4 id="2-线程分类"><a href="#2-线程分类" class="headerlink" title="2.线程分类"></a>2.线程分类</h4><ol><li>用户级线程</li></ol><ul><li>用户级线程由应用程序通过线程库实现。<strong>所有的线程管理工作都由应用程序负责（包括线程切换)</strong></li><li>用户级线程中，线程切换可以在用户态下即可完成，<strong>无需操作系统干预。</strong></li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)</li><li>可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。</li></ul><ol start="2"><li>内核级线程</li></ol><ul><li>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li><li>可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</li></ul><p>&#x3D;&#x3D;操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。&#x3D;&#x3D;</p><h3 id="6-多线程模型"><a href="#6-多线程模型" class="headerlink" title="6.多线程模型"></a>6.多线程模型</h3><blockquote><p>多对一模型</p></blockquote><ul><li>多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</li><li>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，<strong>线程管理的系统开销小，效率高</strong></li><li>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。<strong>多个线程不可在多核处理机上并行运行</strong></li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b7e1c04ce8954a471ee08f95df17be03-171885848224647.png" alt="image-20210804144200566"></p><blockquote><p>一对一模型</p></blockquote><ul><li>一对一模型:一个用户级线程映射到一个内核级线程。</li><li>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。<strong>多线程可在多核处理机上并行执行。</strong></li><li>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，<strong>因此线程管理的成本高，开销大。</strong></li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/30546ad553f8744f00864f7a3b4399aa-171885848224649.png" alt="image-20210804144508904"></p><blockquote><p>多对多模型</p></blockquote><ul><li>多对多模型:n用户级线程映射到m个内核级线程(n &gt;&#x3D;m)。每个用户进程对应m个内核级线程。</li><li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/a42d433bc67c626ca4be89520a9b6572-171885848224651.png" alt="image-20210804144634167"></p><h3 id="7-处理机调度的概念和层次"><a href="#7-处理机调度的概念和层次" class="headerlink" title="7.处理机调度的概念和层次"></a>7.处理机调度的概念和层次</h3><blockquote><p>含义</p></blockquote><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。</p><p>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><p>调度分为三个层次，分别为高级调度，中级调度，初级调度。</p><h4 id="1-高级调度"><a href="#1-高级调度" class="headerlink" title="1.高级调度"></a>1.高级调度</h4><ul><li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</li><li>高级调度（作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。</li><li><strong>高级调度是辅存（外存）与内存之间的调度</strong>。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。<strong>高级调度主要是指调入的问题</strong>，因为只有调入的时机需要操作系统来确定，调出的时机必然是作业运行结束才调出。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/6a9a38fbdf651ec632a50274cea46f70-171885848224653.png" alt="image-20210804152012091"></p><h4 id="2-中级调度"><a href="#2-中级调度" class="headerlink" title="2.中级调度"></a>2.中级调度</h4><ul><li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量</strong>。</li><li>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</li><li><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</strong></li><li>一个进程可能会被多次调出、调入内存，因此<strong>中级调度发生的频率要比高级调度更高。</strong></li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/37c75d014d6c0816607b1eb690d31a11-171885848224655.png" alt="image-20210804152341270"></p><h4 id="补充知识：进程的七状态模型"><a href="#补充知识：进程的七状态模型" class="headerlink" title="补充知识：进程的七状态模型"></a>补充知识：进程的七状态模型</h4><ul><li><p>暂时被调到外存等待的进程状态称为挂起状态。</p></li><li><p>挂起状态又可以进一步细分为就绪挂起，堵塞挂起两种状态。</p></li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/2d7353e5c69a5b2f8e9e7041d3593103-171885848224757.png" alt="image-20210804152935709"></p><h4 id="3-低级调度"><a href="#3-低级调度" class="headerlink" title="3.低级调度"></a>3.低级调度</h4><ul><li>低级调度（进程调度），其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它。</strong></li><li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li><li>进程调度的频率很高，一般几十毫秒一次。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5447df82195ed45119ff23ddad012205-171885848224759.png" alt="image-20210804153047419"></p><h4 id="4-三种调度的联系和对比"><a href="#4-三种调度的联系和对比" class="headerlink" title="4.三种调度的联系和对比"></a>4.三种调度的联系和对比</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/002c477097ce9a50c6d7bd7690471560-171885848224761.png" alt="image-20210804153249686"></p><h3 id="8-进程调度的时机，切换过程和方式"><a href="#8-进程调度的时机，切换过程和方式" class="headerlink" title="8.进程调度的时机，切换过程和方式"></a>8.进程调度的时机，切换过程和方式</h3><h4 id="1-进程调度的时机"><a href="#1-进程调度的时机" class="headerlink" title="1.进程调度的时机"></a>1.进程调度的时机</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/3189df2592fc681dea9a6a830e205371-171885848224763.png" alt="image-20210805140446449"></p><p>临界资源： 一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。</p><h4 id="2-进程调度的方式"><a href="#2-进程调度的方式" class="headerlink" title="2.进程调度的方式"></a>2.进程调度的方式</h4><ul><li>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li></ul><blockquote><p>优点</p></blockquote><ul><li>实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><ul><li>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li></ul><blockquote><p>优点</p></blockquote><ul><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</li></ul><h4 id="3-进程的切换与过程"><a href="#3-进程的切换与过程" class="headerlink" title="3.进程的切换与过程"></a>3.进程的切换与过程</h4><p>“狭义的进程调度”与“进程切换”的区别:</p><ul><li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p></li><li><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p></li></ul><p><strong>广义的进程调度包含了选择一个进程和进程切换两个步骤。</strong></p><p>进程切换的过程主要完成了:</p><ul><li><p>1.对原来运行进程各种数据的保存</p></li><li><p>2.对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</p></li></ul><p>注意 : <strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h3 id="9-调度算法的评价指标"><a href="#9-调度算法的评价指标" class="headerlink" title="9.调度算法的评价指标"></a>9.调度算法的评价指标</h3><ul><li>CPU利用率： CPU”忙碌”的时间占总时间的比例。</li><li>系统吞吐量：单位时间内完成作业的数量。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/279ed1d5604f327f61f532fa69fe2189-171885848224865.png" alt="image-20210805142159718"></p><ul><li>周转时间：是指从作业被提交给系统开始，到作业完成为止的时间间隔。</li></ul><p>（作业）周转时间&#x3D;作业完成时的时间-作业提交时间</p><p>平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数</p><p>由于在周转时间相同的情况下，运行时间不同的作业，给用户的感觉是不一样的，所以提出了带权周转时间的概念。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1ea90ebefb8ebaca1a61217854393b9d-171885848224867.png" alt="image-20210805142921145"></p><ul><li>等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</li></ul><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><ul><li>响应时间：指从用户提交请求到首次产生响应所用的时间。</li></ul><h3 id="10-调度算法（1）"><a href="#10-调度算法（1）" class="headerlink" title="10.调度算法（1）"></a>10.调度算法（1）</h3><h4 id="1-先来先服务（FCFS，First-Come-First-Serve）"><a href="#1-先来先服务（FCFS，First-Come-First-Serve）" class="headerlink" title="1.先来先服务（FCFS，First Come First Serve）"></a>1.先来先服务（FCFS，First Come First Serve）</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ddd1128e6e06e3683a8615a80c6dc92f-171885848224869.png" alt="image-20210805144150920"></p><h4 id="2-短作业优先（SJF，Shortest-Job-First）"><a href="#2-短作业优先（SJF，Shortest-Job-First）" class="headerlink" title="2.短作业优先（SJF，Shortest Job First）"></a>2.短作业优先（SJF，Shortest Job First）</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/03812d061a40da193acf0cd88103b4f3-171885848224871.png" alt="image-20210805145121363"></p><h4 id="3-高响应比优先（HRRN，Highest-Response-Ratio-Next）"><a href="#3-高响应比优先（HRRN，Highest-Response-Ratio-Next）" class="headerlink" title="3.高响应比优先（HRRN，Highest Response Ratio Next）"></a>3.高响应比优先（HRRN，Highest Response Ratio Next）</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/3cbe3e59dbebeea7180c95b433760ae1-171885848224873.png" alt="image-20210805145558483"></p><h4 id="4-三种算法对比"><a href="#4-三种算法对比" class="headerlink" title="4.三种算法对比"></a>4.三种算法对比</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/103fb44c93582d302f963c1ce7548072-171885848224875.png" alt="image-20210805145752847"></p><p>注:这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。<strong>因此这三种算法一般适合用于早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。而适合用于交互式系统的调度算法将在下个小节介绍…</p><h3 id="11-调度算法（2）"><a href="#11-调度算法（2）" class="headerlink" title="11.调度算法（2）"></a>11.调度算法（2）</h3><h4 id="1-时间片轮转调度（RR，Round-Robin）"><a href="#1-时间片轮转调度（RR，Round-Robin）" class="headerlink" title="1.时间片轮转调度（RR，Round-Robin）"></a>1.时间片轮转调度（RR，Round-Robin）</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/8c9299024e9ae9d72d4ebcc47e46140d-171885848224977.png" alt="image-20210805151053159"></p><ul><li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li><li>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</li><li>一般来说，设计时间片要让切换进程的开销占比不超过1%。</li></ul><h4 id="2-优先级调度算法"><a href="#2-优先级调度算法" class="headerlink" title="2.优先级调度算法"></a>2.优先级调度算法</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1ad11f390e65870ac70a17f5e5fa5a8d-171885848224979.png" alt="image-20210805152056532"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2dc33f9d6b1f31efaaf475c97517e2aa.png" alt="image-20210805152129027"></p><h4 id="3-多级反馈队列调度算法"><a href="#3-多级反馈队列调度算法" class="headerlink" title="3.多级反馈队列调度算法"></a>3.多级反馈队列调度算法</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/f7eca0fceaac9826bf70f59103187eca.png" alt="image-20210805152958697"></p><ul><li>通过下边的例子来加深理解</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/9a867b7870c21907cb8384fdfd17d744-171885848224984.png" alt="image-20210805153054972"></p><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此<strong>这三种算法适合用于交互式系统。</strong>(比如UNIX使用的就是多级反馈队列调度算法)</p><h3 id="12-进程同步与进程互斥"><a href="#12-进程同步与进程互斥" class="headerlink" title="12.进程同步与进程互斥"></a>12.进程同步与进程互斥</h3><h4 id="1-进程同步"><a href="#1-进程同步" class="headerlink" title="1.进程同步"></a>1.进程同步</h4><ul><li>通过进程通信——管道通信的例子来了解什么是进程同步。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ab782cbc2f93b0bd295915a8ad265113-171885848224986.png" alt="image-20210805153649199"></p><p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。<strong>如何解决这种异步问题，就是“进程同步”所讨论的内容。</strong></p><blockquote><p>含义</p></blockquote><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><h4 id="2-进程互斥"><a href="#2-进程互斥" class="headerlink" title="2.进程互斥"></a>2.进程互斥</h4><ul><li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。</li><li>许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li><li>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。</li><li><strong>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</strong></li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/a6e491f1593764945389020d3488ec2b-171885848224988.png" alt="image-20210805154317605"></p><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/fcc9ed820167671f745395456bd93c78-171885848225090.png" alt="image-20210805154539614"></p><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><h3 id="13-进程互斥的软件实现方法"><a href="#13-进程互斥的软件实现方法" class="headerlink" title="13.进程互斥的软件实现方法"></a>13.进程互斥的软件实现方法</h3><h4 id="1-单标志法"><a href="#1-单标志法" class="headerlink" title="1.单标志法"></a>1.单标志法</h4><p>算法思想:每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p><blockquote><p>代码实现</p></blockquote><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ca8d3bd22ad27e78f6a089f652f2a818-171885848225092.png" alt="image-20210805155502678"></p><blockquote><p>解释</p></blockquote><p>turn的初值为0，即刚开始只允许0号进程进入临界区。<br>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换 P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在 P0访问临界区期间即时切换回P1，P1依然会卡在⑤。只有P0在退出区将turn改为1后，P1才能进入临界区。<br>因此，<strong>该算法可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p><p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。</p><p>也就是说，对于临界区的访问，一定是按P0→P1→P0→P1→……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。<br>因此，<strong>单标志法存在的主要问题是:违背“空闲让进”原则。</strong></p><h4 id="2-双标志先检查法"><a href="#2-双标志先检查法" class="headerlink" title="2.双标志先检查法"></a>2.双标志先检查法</h4><p>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] &#x3D;ture”意味着0号进程 P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[li]设为true，之后开始访问临界区。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/0e91becb0fdb10f94f2b8fca3f0efbba-171885848225094.png" alt="image-20210805160140406"></p><p>若按照①⑤②⑥③⑦….的顺序执行，P0和P1将会同时访问临界区。因此，<strong>双标志先检查法的主要问题是:违反“忙则等待”原则。</strong><br>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p><h4 id="3-双标志后检查法"><a href="#3-双标志后检查法" class="headerlink" title="3.双标志后检查法"></a>3.双标志后检查法</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/e7244375b3afd7f547061b9d5d8460fd.png" alt="image-20210805160459552"></p><h4 id="4-Peterson算法"><a href="#4-Peterson算法" class="headerlink" title="4.Peterson算法"></a>4.Peterson算法</h4><p>算法思想:双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，<strong>如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/9e38525505d28fd8c7d5be7965292a90-171885848225097.png" alt="image-20210805161159117"></p><ul><li>Peterson算法用软件方法解决了<strong>进程互斥问题，遵循了空闲让进、忙则等待、有限等待</strong>三个原则，但是依然未遵循让权等待的原则。</li><li>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</li></ul><h3 id="14-进程互斥的硬件实现方法"><a href="#14-进程互斥的硬件实现方法" class="headerlink" title="14.进程互斥的硬件实现方法"></a>14.进程互斥的硬件实现方法</h3><h4 id="1-中断屏蔽方法"><a href="#1-中断屏蔽方法" class="headerlink" title="1.中断屏蔽方法"></a>1.中断屏蔽方法</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/43cb79615ff03f08e55e1135c9965333-171885848225099.png" alt="image-20210805163248064"></p><h4 id="2-TestAndSet指令"><a href="#2-TestAndSet指令" class="headerlink" title="2.TestAndSet指令"></a>2.TestAndSet指令</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/1ecf20d2bfc8482acd0186d3718004a9.png" alt="image-20210805163700544"></p><h4 id="3-Swap指令"><a href="#3-Swap指令" class="headerlink" title="3.Swap指令"></a>3.Swap指令</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/449b870fd8f5c9073aec9ad0c0330262-1718858482251102.png" alt="image-20210805163905058"></p><h3 id="15-信号量机制"><a href="#15-信号量机制" class="headerlink" title="15.信号量机制"></a>15.信号量机制</h3><h4 id="1-什么是信号量"><a href="#1-什么是信号量" class="headerlink" title="1.什么是信号量"></a>1.什么是信号量</h4><ul><li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li><li><strong>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量)，</strong>可以用一个信号量来表示系统中某种资源的数量，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</li><li>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。</li><li>一对原语: wait(S)原语和 signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量s其实就是函数调用时传入的一个参数。</li><li>wait、signal原语常简称为P、V操作（来自荷兰语proberen和 verhogen)。因此，做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、V(S)。</li></ul><h4 id="2-整型信号量"><a href="#2-整型信号量" class="headerlink" title="2.整型信号量"></a>2.整型信号量</h4><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p><p>与普通整数变量的区别：对信号量的操作只有三种，初始化，P操作，V操作。</p><p>下面以打印机为例：</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/d3e9ed36c7bac31fc1dbf78aa751e000-1718858482251104.png" alt="image-20210806131030861"></p><h4 id="3-记录型信号量"><a href="#3-记录型信号量" class="headerlink" title="3.记录型信号量"></a>3.记录型信号量</h4><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用<strong>记录型数据结构表示的信号量</strong>。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/f694412f66de5efcbd4d4f4a9db4b041-1718858482251106.png" alt="image-20210806131433220"></p><h3 id="16-用信号量实现进程互斥，同步，前驱关系"><a href="#16-用信号量实现进程互斥，同步，前驱关系" class="headerlink" title="16.用信号量实现进程互斥，同步，前驱关系"></a>16.用信号量实现进程互斥，同步，前驱关系</h3><h4 id="1-信号量机制实现进程互斥"><a href="#1-信号量机制实现进程互斥" class="headerlink" title="1.信号量机制实现进程互斥"></a>1.信号量机制实现进程互斥</h4><ol><li>分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区)</li><li>设置互斥信号量mutex，初值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/87e5c5164591e6b5934f832272f201ab-1718858482251108.png" alt="image-20210806132725957"></p><p>注意： 对不同的临界资源（如摄像头，打印机）需要设置不同的互斥信号量。</p><p><strong>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</strong></p><h4 id="2-信号量机制实现进程同步"><a href="#2-信号量机制实现进程同步" class="headerlink" title="2.信号量机制实现进程同步"></a>2.信号量机制实现进程同步</h4><p>进程同步：要让各并发进程按要求有序的进行。</p><p>那么如何实现呢？</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li><li>设置同步信号量s,初始为0</li><li>在“前操作”之后执行v(S)</li><li>在“后操作”之前执行P(S)</li></ol><p>下面通过一个例子来解释，要求：进程2的代码4必须在进程1的代码2之后执行。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/081e617577b927356337cc0e9fd189d4-1718858482251110.png" alt="image-20210806133559929"></p><h4 id="3-信号量机制实现前驱关系"><a href="#3-信号量机制实现前驱关系" class="headerlink" title="3.信号量机制实现前驱关系"></a>3.信号量机制实现前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2 …P… P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行:<br>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作)，因此，<br>1．要为每一对前驱关系各设置一个同步变量</p><p>2．在“前操作”之后对相应的同步变量执行V操作</p><p>3.在“后操作”之前对相应的同步变量执行Р操作</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ee8027dccb57609b12bd84bb7163a7be-1718858482251112.png" alt="image-20210806133958251"></p><h3 id="17-生产者——消费者问题"><a href="#17-生产者——消费者问题" class="headerlink" title="17.生产者——消费者问题"></a>17.生产者——消费者问题</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)</p><ul><li>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须互斥地访问。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/772d66766aaa0182f31b1558d9cc18c1-1718858482251114.png" alt="image-20210806134848101"></p><h4 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/6dd4f6b27a8d9f02c97a790519dc7a83.png" alt="image-20210806134953024"></p><h4 id="3-如何实现"><a href="#3-如何实现" class="headerlink" title="3.如何实现"></a>3.如何实现</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/f48264b874b5a5198ddd6796e26bd415-1718858482252117.png" alt="image-20210806135800310"></p><h4 id="4-能够改变相邻P，V的顺序"><a href="#4-能够改变相邻P，V的顺序" class="headerlink" title="4.能够改变相邻P，V的顺序"></a>4.能够改变相邻P，V的顺序</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/d1a0a5110093ccfe6d8cba675f23907e-1718858482252119.png" alt="image-20210806135911104"></p><h3 id="18-多生产者——多消费者"><a href="#18-多生产者——多消费者" class="headerlink" title="18.多生产者——多消费者"></a>18.多生产者——多消费者</h3><h4 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/f310ca95c670b6f61db93333e070134a-1718858482252121.png" alt="image-20210806140946552"></p><h4 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2.如何实现"></a>2.如何实现</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/4ac991dd36cb6f27f554522a4cc5f8f9-1718858482252123.png" alt="image-20210806141024230"></p><p>问题：可不可以不使用问题信号量？</p><p>结论:即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p><p>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻,最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p><p>如果盘子（缓冲区）数量为2，可能会出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><ol><li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</li><li>建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</li></ol><h3 id="19-吸烟者问题"><a href="#19-吸烟者问题" class="headerlink" title="19.吸烟者问题"></a>19.吸烟者问题</h3><h4 id="1-问题描述-2"><a href="#1-问题描述-2" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/6725edf55ad6a75ccbb8373c947733f2-1718858482252125.png" alt="image-20210807131831561"></p><h4 id="2-如何解决"><a href="#2-如何解决" class="headerlink" title="2.如何解决"></a>2.如何解决</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/aa825efe6a5b9ccb9544b2d5c59d6599-1718858482252127.png" alt="image-20210807131924674"></p><h3 id="20-读者——写者问题"><a href="#20-读者——写者问题" class="headerlink" title="20.读者——写者问题"></a>20.读者——写者问题</h3><h4 id="1-问题描述-3"><a href="#1-问题描述-3" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求:</p><p>①允许多个读者可以同时对文件执行读操作;</p><p>②只允许一个写者往文件中写信息;</p><p>③任一写者在完成写操作之前不允许其他读者或写者工作;</p><p>④写者执行写操作前，应让已有的读者和写者全部退出。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/177ebb9d437f0a037bb81df8faf39a04-1718858482253129.png" alt="image-20210807133416464"></p><h4 id="2-如何实现-1"><a href="#2-如何实现-1" class="headerlink" title="2.如何实现"></a>2.如何实现</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/20eb775044267cfb7ef9926fb41d6104-1718858482253131.png" alt="image-20210807133502764"></p><ul><li>潜在的问题：只要读进程还在读，写进程就要一直堵塞等待，可能会饿死。因此在这种算法中，读进程优先。下面来实现“ 先来先服务”算法，这样就不会导致写进程饿死。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/4e603a19e928c08bf3caf6eee68ef233-1718858482253133.png" alt="image-20210807133533828"></p><h4 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3.总结"></a>3.总结</h4><p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。<br>其核心思想在于<strong>设置了一个计数器count用来记录当前正在访问共享文件的读进程数</strong>。我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。<br>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，<strong>如果需要实现“一气呵成”，自然应该想到用互斥信号量。</strong><br>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p><h3 id="21-哲学家吃饭"><a href="#21-哲学家吃饭" class="headerlink" title="21.哲学家吃饭"></a>21.哲学家吃饭</h3><h4 id="1-问题描述-4"><a href="#1-问题描述-4" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/360ff5d3aeb35f194be861f686519311-1718858482253135.png" alt="image-20210807134907136"></p><h4 id="2-问题分析-1"><a href="#2-问题分析-1" class="headerlink" title="2.问题分析"></a>2.问题分析</h4><p>1.关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p><p>2.整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。<br>3.信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}，用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</p><h4 id="3-如何实现-1"><a href="#3-如何实现-1" class="headerlink" title="3.如何实现"></a>3.如何实现</h4><ul><li>如果使用下图所示的方法，则会导致死锁问题。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/725536caf67af3d7caa18e9ce79305be-1718858482253137.png" alt="image-20210807135145340"></p><ul><li>那么如何解决呢？</li></ul><p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p><p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p><p>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p><p>下面用代码实现第三种方式。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b0977fc37a695dcf08f2bb2ff1b77f9d-1718858482253139.png" alt="image-20210807135344301"></p><h3 id="22-管程"><a href="#22-管程" class="headerlink" title="22.管程"></a>22.管程</h3><h4 id="1-为什么引入管程？"><a href="#1-为什么引入管程？" class="headerlink" title="1. 为什么引入管程？"></a>1. 为什么引入管程？</h4><p>信号量机制存在的问题 : 编写程序困难、易出错。 因此人们想设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松。1973年，Brinch Hansen首次在程序设计语言(Pascal)中引入了“管程”成分――一种高级同步机制。</p><h4 id="2-管程的定义和基本特征"><a href="#2-管程的定义和基本特征" class="headerlink" title="2.管程的定义和基本特征"></a>2.管程的定义和基本特征</h4><p><strong>管程相当于对临界区资源进行抽象而编写的一个类。</strong></p><p>管程是一种特殊的软件模块，有这些部分组成:</p><p>1.局部于管程的共享数据结构说明;     （一个类）</p><p>2.对该数据结构进行操作的一组过程;    （类中的方法）</p><p>3．对局部于管程的共享数据设置初始值的语句;   （类中的变量）</p><p>4.管程有一个名字。 （类名）</p><p>管程的基本特征:</p><p>1．局部于管程的数据只能被局部于管程的过程所访问;      （类中变量有自己的作用范围）</p><p>**2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据; ** <strong>这种互斥特性是由编译器来实现的。</strong></p><p><strong>3．每次仅允许一个进程在管程内执行某个内部过程。</strong></p><h4 id="3-java中类似于管程的机制（单例模式）"><a href="#3-java中类似于管程的机制（单例模式）" class="headerlink" title="3.java中类似于管程的机制（单例模式）"></a>3.java中类似于管程的机制（单例模式）</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ae7939e60bc5b80ee6ba3e825b5cba77-1718858482253141.png" alt="image-20210807141404776"></p><h3 id="23-死锁"><a href="#23-死锁" class="headerlink" title="23.死锁"></a>23.死锁</h3><h4 id="1-含义-1"><a href="#1-含义-1" class="headerlink" title="1.含义"></a>1.含义</h4><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁“。</p><p>发生死锁后若无外力干涉,这些进程都将无法向前推进。</p><h4 id="2-死锁，饥饿，死循环的区别"><a href="#2-死锁，饥饿，死循环的区别" class="headerlink" title="2.死锁，饥饿，死循环的区别"></a>2.死锁，饥饿，死循环的区别</h4><ul><li>死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li>饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</li><li>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/e6b26d2c084370559acda853d2d8c42e-1718858482253143.png" alt="image-20210807142049088"></p><h4 id="3-死锁产生的必要条件"><a href="#3-死锁产生的必要条件" class="headerlink" title="3.死锁产生的必要条件"></a>3.死锁产生的必要条件</h4><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li><p><strong>互斥条件</strong>:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源）。</p></li><li><p><strong>不剥夺条件</strong>:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p></li><li><p><strong>请求 和 保持条件</strong>:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p></li><li><p><strong>循环等待条件</strong>:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p></li></ul><p>注意 : 发生死锁时一定有循环等待 , 但是发生循环等待时未必死锁（<strong>循环等待是死锁的必要不充分条件</strong>)</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p><h4 id="4-什么时候会发生死锁"><a href="#4-什么时候会发生死锁" class="headerlink" title="4.什么时候会发生死锁"></a>4.什么时候会发生死锁</h4><ol><li><p><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</p></li><li><p><strong>进程推进顺序非法</strong>。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程p1又紧接着申请资源R2，而进程p2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p></li><li><p><strong>信号量的使用不当也会造成死锁</strong>。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</p></li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h4 id="5-死锁的处理策略"><a href="#5-死锁的处理策略" class="headerlink" title="5.死锁的处理策略"></a>5.死锁的处理策略</h4><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><h3 id="24-预防死锁"><a href="#24-预防死锁" class="headerlink" title="24.预防死锁"></a>24.预防死锁</h3><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/fb6587d81b2b63eda36043138bb6f0ca-1718858482256145.png" alt="image-20210807144115187"></p><h3 id="25-避免死锁"><a href="#25-避免死锁" class="headerlink" title="25.避免死锁"></a>25.避免死锁</h3><h4 id="11-什么是安全序列"><a href="#11-什么是安全序列" class="headerlink" title="11.什么是安全序列"></a>11.什么是安全序列</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/75e60e10c3364d0e57206bc73035417b.png" alt="image-20210807145513416"></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/38e23117bf18e59e503260594a952a93-1718858482256148.png" alt="image-20210807145554354"></p><ul><li>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</li><li><strong>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，则可能会发生死锁。（不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</strong></li><li>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</li></ul><h4 id="2-银行家算法"><a href="#2-银行家算法" class="headerlink" title="2.银行家算法"></a>2.银行家算法</h4><p><strong>数据结构:</strong><br>长度为m的一维数组 Available表示还有多少可用资源</p><p>n<em>m矩阵Max表示各进程对资源的最大需求数</em></p><p><em>n</em>m矩阵Allocation表示已经给各进程分配了多少资源</p><p>Max - Allocation &#x3D; Need矩阵表示各进程最多还需要多少资源</p><p>用长度为m的一位数组Request表示进程此次申请的各种资源数</p><p><strong>银行家算法步骤:</strong><br>①检查此次申请是否超过了之前声明的最大需求数</p><p>②检查此时系统剩余的可用资源是否还能满足这次请求</p><p>③试探着分配，更改各数据结构</p><p>④用安全性算法检查此次分配是否会导致系统进入不安全状态</p><p><strong>安全性算法步骤:</strong><br>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。<br>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><h3 id="26-死锁的检测和解除"><a href="#26-死锁的检测和解除" class="headerlink" title="26.死锁的检测和解除"></a>26.死锁的检测和解除</h3><h4 id="1-死锁的检测"><a href="#1-死锁的检测" class="headerlink" title="1.死锁的检测"></a>1.死锁的检测</h4><p>为了能对系统是否已发生了死锁进行检测，必须:</p><p>①用某种数据结构来保存资源的请求和分配信息;<br>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/97dc902bcb246554f9de99acb1fb6fe1-1718858482256150.png" alt="image-20210807151232864"></p><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程.<br><strong>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列)。</strong><br>如果最终不能消除所有边，那么此时就是发生了死锁。</p><p><strong>死锁定理:如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</strong></p><h4 id="2-死锁的解除"><a href="#2-死锁的解除" class="headerlink" title="2.死锁的解除"></a>2.死锁的解除</h4><p>一旦检测出死锁的发生，就应该立即解除死锁。<br>补充:并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程<br>解除死锁的主要方法有 :</p><ol><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ol><p>如何选择对哪些进程动手？</p><ol><li>进程优先级   (优先级低的)</li><li>已执行多长时间 （执行时间短的）</li><li>还要多久能完成   （时间长的进行处理）</li><li>进程己经使用了多少资源    （资源多的）</li><li>进程是交互式的还是批处理式的   （进行批处理的）</li></ol><h2 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3.内存管理"></a>3.内存管理</h2><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h3><p><strong>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5151089654a429d7ba63d56994a1ebba-1718858482257152.png" alt="image-20210807162229945"></p><blockquote><p>相对地址和绝对地址</p></blockquote><p><strong>编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</strong><br>Eg: 编译时只需确定变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU 想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p><p><strong>相对地址又称逻辑地址，绝对地址又称物理地址。</strong></p><blockquote><p>写程序到程序运行</p></blockquote><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/d86f101e631d897b3ac517264e448198-1718858482257154.png" alt="image-20210807162523347"></p><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2.内存管理"></a>2.内存管理</h3><p>操作系统对内存进行管理，那么要管理哪些内容呢？</p><ol><li>内存空间的分配和回收</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li></ol><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/07a609df0fdec29ab43654773e37b5ab-1718858482257156.png" alt="image-20210808144126553"></p><ol start="4"><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li></ol><p>内存保护可采取两种方法:</p><p>方法一:在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/52b901e6ea188a24f8baad9d72b8cdbe-1718858482257158.png" alt="image-20210808144249365"></p><p>方法二:采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/fd5a139a2c073fd55e9da9b70e93c423-1718858482257160.png" alt="image-20210808144341286"></p><h3 id="3-覆盖和交换"><a href="#3-覆盖和交换" class="headerlink" title="3.覆盖和交换"></a>3.覆盖和交换</h3><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/8e4c90ff0a0fc6dc5be5db64e6627e22-1718858482257162.png" alt="image-20210808144501243"></p><h4 id="1-覆盖技术"><a href="#1-覆盖技术" class="headerlink" title="1.覆盖技术"></a>1.覆盖技术</h4><p>覆盖技术的思想 : <strong>将程序分为多个段（多个模块）</strong>。常用的段常驻内存，不常用的段在需要时调入内存。<br>内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束)不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/edd42b2c38af07a4a6021b4527f0efc0-1718858482257164.png"></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/edd42b2c38af07a4a6021b4527f0efc0-1718858482257164.png" alt="image-20210808151012190"></p><p>必须由程序员声明覆盖结构，操作系统完成自动覆盖。<strong>缺点:对用户不透明，增加了用户编程负担。</strong>覆盖技术只用于早期的操作系统中，现在已成为历史。</p><h4 id="2-交换技术"><a href="#2-交换技术" class="headerlink" title="2.交换技术"></a>2.交换技术</h4><p>交换（对换）技术的设计思想: <strong>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</strong>。之前讲的中级调度（内存调度）就是为这个服务的。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/94f1d714b7b6c1f486a1d60150f5f4be-1718858482258166.png" alt="image-20210808151250246"></p><p>1.应该在外存（磁盘）的什么位置保存被换出的进程?</p><p>具有对换功能的操作系统中，通常把<strong>磁盘空间分为文件区和对换区</strong>两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用<strong>离散分配方式</strong>;对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用<strong>连续分配</strong>方式（学过文件管理章节后即可理解）。总之，对换区的I&#x2F;O速度比文件区的更快。</p><p>2.什么时候应该交换?</p><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</p><p>3.应该换出哪些进程?</p><p>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</p><p><strong>(注意:PCB会常驻内存，不会被换出外存)</strong></p><h3 id="4-连续分配管理方式"><a href="#4-连续分配管理方式" class="headerlink" title="4.连续分配管理方式"></a>4.连续分配管理方式</h3><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b2c1dc99b722bace451d4df89c041ec3-1718858482258168.png" alt="image-20210808151616403"></p><h4 id="1-单一连续分配"><a href="#1-单一连续分配" class="headerlink" title="1.单一连续分配"></a>1.单一连续分配</h4><ul><li>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。</li><li>内存中只能有一道用户程序，用户程序独占整个用户区空间。</li><li>优点: 实现简单 ;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护（eg:早期的 PC操作系统MS-DOS)。</li><li>缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/f37af84459a5776ef29988ba7e63b5ac-1718858482258170.png" alt="image-20210808153202643"></p><h4 id="2-固定分区分配"><a href="#2-固定分区分配" class="headerlink" title="2.固定分区分配"></a>2.固定分区分配</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/a5549d30aa3ec597fe0f0770b441d046.png" alt="image-20210808153255068"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0b4097c2a3f3c66b33767dbf49546bfd.png" alt="image-20210808153337606"></p><h4 id="3-动态分区分配"><a href="#3-动态分区分配" class="headerlink" title="3.动态分区分配"></a>3.动态分区分配</h4><p>动态分区分配又称为可变分区分配。<strong>这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要</strong>。因此系统分区的大小和数目是可变的。</p><ul><li>使用这种方式的话，我们需要考虑以下三个问题。</li></ul><ol><li>系统要用什么样的数据结构记录内存的使用情况?</li></ol><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/98605d272e0d2cc91de3982d9ca5a19f-1718858482258176.png" alt="image-20210808153616151"></p><ol start="2"><li><p>当很多个空闲分区都能满足需求时,应该选择哪个分区进行分配?</p><pre><code> 使用动态分区算法，这个将在下一小节进行详细介绍。</code></pre></li><li><p>如何进行分区的分配与回收操作?</p></li></ol><ul><li>如何分配  ———–&gt; 使用动态分区算法之后，修改数据结构即可。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/f353febfbf73c2f3f8d924e9c1f96264-1718858482258178.png" alt="image-20210808153849729"></p><ul><li>如何回收——————————-&gt; 牢记一点即可，会把相邻的空闲区域合并为一个。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/19cf34972627d3769c9d5e80e61314e7-1718858482258180.png" alt="image-20210808154037814"></p><h4 id="4-内部碎片和外部碎片"><a href="#4-内部碎片和外部碎片" class="headerlink" title="4.内部碎片和外部碎片"></a>4.内部碎片和外部碎片</h4><ul><li>动态分区分配没有内部碎片，但是有外部碎片。</li><li><strong>内部碎片</strong>，分配给某进程的内存区域中，如果有些部分没有用上。</li><li><strong>外部碎片</strong>，是指内存中的某些空闲分区由于太小而难以利用。</li><li>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些<br>进程“碎片”不能满足进程的需求。可以通过<strong>紧凑</strong>（(拼凑，Compaction)技术来解决外部碎片。</li></ul><h3 id="5-动态分区分配算法"><a href="#5-动态分区分配算法" class="headerlink" title="5.动态分区分配算法"></a>5.动态分区分配算法</h3><p>动态分区分配算法:在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</p><h4 id="1-首次适应算法"><a href="#1-首次适应算法" class="headerlink" title="1.首次适应算法"></a>1.首次适应算法</h4><p>算法思想: 每次都从低地址开始查找，<strong>找到第一个能满足大小的空闲分区</strong>。<br>如何实现:空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/161691d8e26c7ff7f58def19ce5c6b53-1718858482259182.png" alt="image-20210808155515584"></p><h4 id="2-最佳适应算法"><a href="#2-最佳适应算法" class="headerlink" title="2.最佳适应算法"></a>2.最佳适应算法</h4><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong>。<br>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5bf66568b85d6d72094ce1e9afd34555-1718858482259184.png" alt="image-20210808155644448"></p><h4 id="3-最大适应算法"><a href="#3-最大适应算法" class="headerlink" title="3.最大适应算法"></a>3.最大适应算法</h4><p>又称最坏适应算法(Largest Fit)<br>算法思想:为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在<strong>每次分配时优先使用最大的连续空闲区</strong>，这样分配后剩余的空闲区就不会太小，更方便使用。<br>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/77ea246fc29d148c012ae77b7eeb2c4a-1718858482259186.png" alt="image-20210808155801357"></p><h4 id="4-临近适应算法"><a href="#4-临近适应算法" class="headerlink" title="4.临近适应算法"></a>4.临近适应算法</h4><p>算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。<strong>如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</strong><br>如何实现:空闲分区以地址递增的顺序排列(可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/54634cd9bc916ca1e4e19d2a61300f75.png" alt="image-20210808160041410"></p><h4 id="5-四种算法对比"><a href="#5-四种算法对比" class="headerlink" title="5.四种算法对比"></a>5.四种算法对比</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/0e9e2f352aaf86e9b6eb84e4b94fe62f.png" alt="image-20210808160008902"></p><h3 id="6-基本分页存储管理"><a href="#6-基本分页存储管理" class="headerlink" title="6.基本分页存储管理"></a>6.基本分页存储管理</h3><p>连续分配:为用户进程分配的必须是一个连续的内存空间。</p><p>非连续分配:为用户进程分配的可以是一些分散的内存空间。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/0f4e93675ac646001a63d9f6ce517c34-1718858482259190.png" alt="image-20210808163001835"></p><p><strong>基本分页存储管理的思想――把内存分为一个个相等的小分区,再按照分区大小把进程拆分成一个个小部分。</strong></p><p>将内存空间分为一个个大小相等的分区（比如:每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)页框号从0开始。</p><p>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。<br>(注:进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片)</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。</p><p><strong>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</strong></p><p>思考： 将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换?</p><ol><li>要算出逻辑地址对应的页号</li><li>要知道该页号对应页面在内存中的起始地址</li><li>要算出逻辑地址在页面内的“偏移量”</li><li>物理地址 &#x3D; 页面始址＋页内偏移量</li></ol><p>如何计算:</p><ol><li>页号&#x3D;逻辑地址&#x2F;页面长度(取除法的整数部分)</li><li>页内偏移量 &#x3D; 逻辑地址%页面长度（取除法的余数部分)</li><li>页面在内存中的起始位置:操作系统需要用某种数据结构记录进程各个页面的起始位置。</li></ol><p>举例:</p><p>   页号&#x3D;80 &#x2F; 50&#x3D; 1<br>   页内偏移量&#x3D;80 % 50 &#x3D; 30<br>   1号页在内存中存放的起始位置450</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/af74511cebf32839b2cfd846e1b6da35-1718858482259192.png" alt="image-20210808163353323"></p><p>思考: 如何知道该页号对应页面在内存中的起始地址?</p><p>操作系统为每一个进程创建一个页表?</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/87a39f7c9df30d864141b888e9d690f9-1718858482260194.png" alt="image-20210808163849055"></p><ul><li>如何理解每个页表项的长度是相同的，页号是“隐含的”？</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/2f305a7358bd0ceef112786dfbcb948c.png" alt="image-20210809132717571"></p><h3 id="7-基本地址变换机构"><a href="#7-基本地址变换机构" class="headerlink" title="7.基本地址变换机构"></a>7.基本地址变换机构</h3><p>基本地址变换机构可以<strong>借助进程的页表将逻辑地址转换为物理地址</strong>。<br>通常会在系统中设置一个页表寄存器(PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><ul><li>执行流程</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/96dba8e1d26bfce90588d95fa3d67093-1718858482260197.png" alt="image-20210809132912720"></p><ul><li>页表项长度，页表长度，页面大小</li></ul><p>页表长度是指这个页表中总共有几个页表项，即总共有多少页。页面大小是指一个页面占多大的存储空间。页表项长度是指每个页表项占多大的存储空间。</p><p>通过下面这个例子来理解页表项长度。</p><p>Eg:假设某系统物理内存大小为4GB，页面大小为4KB，内存总共会被分为2^32&#x2F; 2^12&#x3D;2^20个内存块，因此内存块号的范围应该是0~2^20 - 1。因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够(每个字节8个二进制位，3个字节共24个二进制位)。每个块号用三个字节来表示。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/a32ce137c88c5004cc868d3ec65a1d94-1718858482260199.png" alt="image-20210809133518059"></p><h3 id="8-具有快表的地址变换机构"><a href="#8-具有快表的地址变换机构" class="headerlink" title="8.具有快表的地址变换机构"></a>8.具有快表的地址变换机构</h3><h4 id="1-局部性原理"><a href="#1-局部性原理" class="headerlink" title="1.局部性原理"></a>1.局部性原理</h4><p><strong>时间局部性</strong>:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)<br><strong>空间局部性</strong>:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)</p><p>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢?</p><h4 id="2-快表"><a href="#2-快表" class="headerlink" title="2.快表"></a>2.快表</h4><p>快表，又称联想寄存器（TLB），是一种<strong>访问速度比内存快很多的高速缓冲存储器</strong>，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><ul><li>执行流程</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/77ffe868216a19436cb741628724760a.png" alt="image-20210809134807098"></p><h3 id="9-两级页表"><a href="#9-两级页表" class="headerlink" title="9.两级页表"></a>9.两级页表</h3><p>两级页表的出现主要是为了解决单级页表的问题。那么单级页表有什么问题呢？</p><p>问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。<br>问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p><h4 id="1-解决问题一"><a href="#1-解决问题一" class="headerlink" title="1.解决问题一"></a>1.解决问题一</h4><p>我们可以回想以下当初是如何解决进程必须连续的问题 ？ </p><p>我们可以把页表放在不同的页框中，再用一个表来记录各个各个子页表所在位置，我们把这个表叫做页目录表（外层页表，顶级页表）。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ee7a1b90d78aeb48ba7df15070bc0625.png" alt="image-20210809141121083"></p><h4 id="2-解决问题二"><a href="#2-解决问题二" class="headerlink" title="2.解决问题二"></a>2.解决问题二</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/c1ac36edcad8ed9f6bdb1f9955966772.png" alt="image-20210809141302977"></p><h4 id="3-其他细节"><a href="#3-其他细节" class="headerlink" title="3. 其他细节"></a>3. 其他细节</h4><ol><li><p>若采用多级页表机制，则各级页表的大小不能超过一个页面</p></li><li><p>两级页表的访存次数分析（假设没有快表机构）</p></li></ol><ul><li>第一次访存:访问内存中的页目录表</li><li>第二次访存:访问内存中的二级页表</li><li>第三次访存:访问目标内存单元</li></ul><p>&#x3D;&#x3D;N级页表访问一个逻辑地址需要N+1次访问内存。&#x3D;&#x3D;</p><h3 id="10-基本分段存储管理方式"><a href="#10-基本分段存储管理方式" class="headerlink" title="10.基本分段存储管理方式"></a>10.基本分段存储管理方式</h3><h4 id="1-分段"><a href="#1-分段" class="headerlink" title="1.分段"></a>1.分段</h4><p>进程的地址空间:<strong>按照程序自身的逻辑关系划分为若干个段</strong>，每个段都有一个段名（在低级语言中，程序员使用段名来编程)，每段从0开始编址。<br>内存分配规则 : 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/0484baeb6ada8fd5aab483625ed40c94.png" alt="image-20210809144740848"></p><ul><li>分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/8647b91e9abb594953a6263b67542d96.png" alt="image-20210809144846609"></p><p><strong>段号的位数决定了每个进程最多可以分几个段。</strong></p><p><strong>段内地址位数决定了每个段的最大长度是多少。</strong></p><h4 id="2-段表"><a href="#2-段表" class="headerlink" title="2.段表"></a>2.段表</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/e44ef24b52156fe644fc9d4dfeff3e15.png" alt="image-20210809145109741"></p><h4 id="3-段内寻址"><a href="#3-段内寻址" class="headerlink" title="3.段内寻址"></a>3.段内寻址</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/dcfc379fc1eec971565205809465ed3b.png" alt="image-20210809145221546"></p><h4 id="4-分段，分页对比"><a href="#4-分段，分页对比" class="headerlink" title="4.分段，分页对比"></a>4.分段，分页对比</h4><ul><li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li><li>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li><li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li><li>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</li><li>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li><li><strong>分段比分页更容易实现信息的共享和保护。</strong></li></ul><h3 id="11-段页式管理方式"><a href="#11-段页式管理方式" class="headerlink" title="11.段页式管理方式"></a>11.段页式管理方式</h3><h4 id="1-分页，分段的优缺点"><a href="#1-分页，分段的优缺点" class="headerlink" title="1.分页，分段的优缺点"></a>1.分页，分段的优缺点</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1313cc914e1a38bc5ae7292f2a376f7c.png" alt="image-20210809150649428"></p><p>既然两者都有优缺点，那么可不可以把他们结合起来呢？答案当然是可以的。如下图所示。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/9b82b9db7d56adce8bb4be42d84b6859.png" alt="image-20210809150813503"></p><h4 id="2-段页式管理的逻辑结构"><a href="#2-段页式管理的逻辑结构" class="headerlink" title="2.段页式管理的逻辑结构"></a>2.段页式管理的逻辑结构</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/06426999bd3386b49cac332e1f3e2045.png" alt="image-20210809150857246"></p><p>段号的位数决定了每个进程最多可以分几个段</p><p>页号位数决定了每个段最大有多少页</p><p>页内偏移量决定了页面大小、内存块大小是多少</p><h4 id="3-段内寻址-1"><a href="#3-段内寻址-1" class="headerlink" title="3.段内寻址"></a>3.段内寻址</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/4cd303aceff43ce2ffcaa393b091b9df.png" alt="image-20210809151045913"></p><h3 id="12-虚拟内存"><a href="#12-虚拟内存" class="headerlink" title="12.虚拟内存"></a>12.虚拟内存</h3><h4 id="1-传统存储管理方式的特征和缺点"><a href="#1-传统存储管理方式的特征和缺点" class="headerlink" title="1.传统存储管理方式的特征和缺点"></a>1.传统存储管理方式的特征和缺点</h4><ul><li>一次性:作业必须一次性全部装入内存后才能开始运行。这会造成两个问题:①作业很大时，不能全部装入内存，导致大作业无法运行;②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li><li>驻留性:一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/4afc02ebeca0040c34574d75ecb93861.png" alt="image-20210809152229610"></p><h4 id="2-虚拟内存的定义和特征"><a href="#2-虚拟内存的定义和特征" class="headerlink" title="2.虚拟内存的定义和特征"></a>2.虚拟内存的定义和特征</h4><ul><li>基于局部性原理（忘记的话，可以到第8节查看），在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</li><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</li><li>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</li></ul><p>易混知识点:</p><p><strong>虚拟内存的最大容量是由计算机的地址结构（ CPU寻址范围）确定的</strong></p><p><strong>虚拟内存的实际容量&#x3D; min(内存和外存容量之和，CPU寻址范围)</strong></p><p>如:  某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB.</p><p>则虚拟内存的最大容量为2^32B&#x3D; 4GB  。 虚拟内存的实际容量&#x3D;min (2^32B,512MB+2GB)&#x3D; 2GB+512MB</p><p>虚拟内存有一下三个主要特征:</p><ul><li>多次性:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ul><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b2797826b0323b52e4b1a07b1f89df7e.png" alt="image-20210809153046973"></p><h3 id="13-请求分页管理方式"><a href="#13-请求分页管理方式" class="headerlink" title="13.请求分页管理方式"></a>13.请求分页管理方式</h3><h4 id="1-页表机制"><a href="#1-页表机制" class="headerlink" title="1.页表机制"></a>1.页表机制</h4><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，</p><ol><li>操作系统需要知道每个页面是否已经调入内存;</li><li>如果还没调入，那么也需要知道该页面在外存中存放的位置。</li><li>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面;</li><li>有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</li></ol><p>因此页表会增加四个字段来上面的信息。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/2ecf5884ab1959d0b5c090cc57629ab8.png" alt="image-20210809154307694"></p><h4 id="2-缺页中断机制"><a href="#2-缺页中断机制" class="headerlink" title="2.缺页中断机制"></a>2.缺页中断机制</h4><p>假设此时要访问逻辑地址 &#x3D; (页号，页内偏移量）&#x3D; (0，1024)</p><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。</p><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p><p>一条指令在执行期间，可能产生多次缺页中断。(如: copy AtoB，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/0a2f46ccc0da552d63b2dcdac3745099.png" alt="image-20210809154630244"></p><h4 id="3-地址变换"><a href="#3-地址变换" class="headerlink" title="3.地址变换"></a>3.地址变换</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/9920dd67a33a7aefb18540e58e8042c8.png" alt="image-20210809154720385"></p><h4 id="4-补充知识点"><a href="#4-补充知识点" class="headerlink" title="4.补充知识点"></a>4.补充知识点</h4><p>①只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</p><p>②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</p><p>③需要用某种“页面置换算法”来决定一个换出页面（下节内容)</p><p>④换入&#x2F;换出页面都需要启动慢速的I&#x2F;o操作，可见，如果换入&#x2F;换出太频繁，会有很大的开销。</p><p>⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</p><h3 id="14-页面置换算法"><a href="#14-页面置换算法" class="headerlink" title="14.页面置换算法"></a>14.页面置换算法</h3><h4 id="1-最佳置换算法"><a href="#1-最佳置换算法" class="headerlink" title="1.最佳置换算法"></a>1.最佳置换算法</h4><p>最佳置换算法（OPT，Optimal):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/20243797dc9f1c3bf67a6e1a8bee2721.png" alt="image-20210809161659809"></p><h4 id="2-先进先出置换算法"><a href="#2-先进先出置换算法" class="headerlink" title="2.先进先出置换算法"></a>2.先进先出置换算法</h4><p>先进先出置换算法（FIFO):每次选择淘汰的页面是最早进入内存的页面</p><p>实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>Belady异常―一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p><strong>只有FIFO算法会产生Belady异常</strong>。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差。</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ddec656e73421061245bddb66da4550c.png" alt="image-20210809161847953"></p><h4 id="3-最近最久未使用算法"><a href="#3-最近最久未使用算法" class="headerlink" title="3.最近最久未使用算法"></a>3.最近最久未使用算法</h4><p>最近最久未使用置换算法（LRU，least recently used):每次淘汰的页面是最近最久未使用的页面。</p><p>实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/dd607f957cd695304dc9422d84d5c66d.png" alt="image-20210809162117351"></p><h4 id="4-时钟置换算法"><a href="#4-时钟置换算法" class="headerlink" title="4.时钟置换算法"></a>4.时钟置换算法</h4><p>最佳置换算法性能最好，但无法实现;先进先出置换算法实现简单，但算法性能差;最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p><p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，NotRecently Used)</p><p>简单的CLOCK 算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，<strong>因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/0c6a83cab0e240d3ae2ea189b149f868.png" alt="image-20210809162337421"></p><h4 id="5-改进型的时钟置换算法"><a href="#5-改进型的时钟置换算法" class="headerlink" title="5.改进型的时钟置换算法"></a>5.改进型的时钟置换算法</h4><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;o操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。<br>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;o操作。这就是改进型的时钟置换算法的思想。修改位&#x3D;0，表示页面没有被修改过;修改位&#x3D;1，表示页面被修改过。<br>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1)表示一个页面近期被访问过，且被修改过。</p><p>算法规则: 将所有可能被置换的页面排成一个循环队列<br>第一轮:从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位<br>第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0<br>第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0，0）的帧用于替换。本轮扫描不修改任何标志位<br>第四轮:若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。<br>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此<strong>改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/a601016bafd5e28fad0c3a920ef8f618.png" alt="image-20210809162555604"></p><h4 id="6-五种算法对比"><a href="#6-五种算法对比" class="headerlink" title="6.五种算法对比"></a>6.五种算法对比</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/10cf20937acd90e5e521376e1f7a15ac.png" alt="image-20210809162647669"></p><h3 id="15-页面分配策略"><a href="#15-页面分配策略" class="headerlink" title="15.页面分配策略"></a>15.页面分配策略</h3><h4 id="1-页面分配，置换策略"><a href="#1-页面分配，置换策略" class="headerlink" title="1.页面分配，置换策略"></a>1.页面分配，置换策略</h4><p><strong>驻留集:指请求分页存储管理中给进程分配的物理块的集合。</strong></p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际上用于进程推进的时间很少。</p><p>驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p><p>固定分配:操作系统为每个进程分配一组固定数目的物理块，在进程运行期间大小不变。即，<strong>驻留集大小不变。</strong></p><p>可变分配:先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，<strong>驻留集大小可变</strong></p><p>局部置换:发生缺页时只能选进程自己的物理块进行置换。</p><p>全局置换:可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/47b2b1f4af5a606cd9c2a947270d322b.png" alt="image-20210809164303593"></p><p>下面来分别介绍这几种方式。</p><ul><li><p>固定分配局部置换:系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)</p></li><li><p>可变分配全局置换:刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程;若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页都将获的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是进程中任意一个进程的页，因此被选中的这个进程物理块会减少，缺页率会增加。</p></li><li><p>可变分配局部置换： 刚开始会为每个进程分配一定数量的物理块，当某进程发生缺页时，只允许从该进程自己的物理块中选出一个换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当，反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p></li></ul><p>可变分配全局置换:只要缺页就给分配新物理块<br>可变分配局部置换:要根据发生缺页的频率来动态地增加或减少进程的物理块</p><h4 id="2-何时调入页面"><a href="#2-何时调入页面" class="headerlink" title="2.何时调入页面"></a>2.何时调入页面</h4><p>1．预调页策略:根据局部性原理（主要是空间局部性），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。<strong>它是运行前调入</strong>。</p><p>2．请求调页策略:进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘l&#x2F;o操作，因此I&#x2F;o开销较大。<strong>它是运行时调入</strong>。</p><h4 id="3-从何处调入页面"><a href="#3-从何处调入页面" class="headerlink" title="3.从何处调入页面"></a>3.从何处调入页面</h4><ol><li>系统拥有足够的对换区空间:页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li></ol><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/d57fdf9f7db93b3ae3790b3846367b29.png" alt="image-20210809165455533"></p><ol start="2"><li>系统缺少足够的对换区空间:凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</li></ol><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ce0ac4f20a08b61518dbcc45b78b7599.png" alt="image-20210809165517173"></p><ol start="3"><li>UNIX方式:运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li></ol><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/99bf3270b91f33c4f070cf24d6da60ff.png" alt="image-20210809165535864"></p><h4 id="4-抖动（颠簸）现象，工作集"><a href="#4-抖动（颠簸）现象，工作集" class="headerlink" title="4.抖动（颠簸）现象，工作集"></a>4.抖动（颠簸）现象，工作集</h4><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。<strong>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数</strong>（分配给进程的物理块不够)。</p><p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</p><p>为了研究为应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念。</p><p>驻留集:指请求分页存储管理中给进程分配的内存块的集合。</p><p><strong>工作集:指在某段时间间隔里，进程实际访问页面的集合。</strong></p><p>一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/9b2abc20a7a0141d0bfab172b93782d5.png" alt="image-20210809165818657"></p><h2 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4.文件系统"></a>4.文件系统</h2><h3 id="1-文件管理"><a href="#1-文件管理" class="headerlink" title="1.文件管理"></a>1.文件管理</h3><ul><li><p>文件――就是一组有意义的信息&#x2F;数据集合。</p></li><li><p>一个文件有哪些属性？</p><ol><li>文件名:由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</li><li>标识符:一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li><li>类型:指明文件的类型</li><li>位置:文件存放的路径（让用户使用)、在外存中的地址(操作系统使用，对用户不可见)</li><li>大小:指明文件大小创建时间、上次修改时间文件所有者信息</li><li>保护信息:对文件进行保护的访问控制信息</li></ol></li><li><p>文件分为有结构文件和无结构文件。</p></li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5c0ebd6dd5cacb9801719b98bcf70850.png" alt="image-20210810142605554"></p><ul><li>操作系统向上（用户和应用程序）提供的功能</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/914c3a4bb38a17995adb6db607593dcd.png" alt="image-20210810142721956"></p><h3 id="2-文件的逻辑结构"><a href="#2-文件的逻辑结构" class="headerlink" title="2.文件的逻辑结构"></a>2.文件的逻辑结构</h3><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/348809239c946d13944d59f2339305ce.png" alt="image-20210810144248520"></p><p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。</p><p>无结构文件:文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如:Windows操作系统中的.txt文件。</p><p>有结构文件:由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如:数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID)</p><p>我们主要研究有结构文件。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/0b19abd7adcc698dbcaa240c5905f272.png" alt="image-20210810144515415"></p><h4 id="1-顺序文件"><a href="#1-顺序文件" class="headerlink" title="1.顺序文件"></a>1.顺序文件</h4><p>顺序文件:文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储（相当于数组）或链式存储（相当于链表）。</p><p>顺序存储又可以分为串结构和顺序结构。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/442c25a2230e519a015eb644375e3c77.png" alt="image-20210810144803262"></p><p>那么这几种存储方式可以快速找到第i个记录对应的地址呢？</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/8e34230949612ec31dbfbe27be7e6ba5.png" alt="image-20210810145032903"></p><p>结论:定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取;若能再保证记录的顺序结构，则可实现快速检索(即根据关键字快速找到对应记录)</p><h4 id="2-索引文件"><a href="#2-索引文件" class="headerlink" title="2.索引文件"></a>2.索引文件</h4><p>思考：对于可变长记录文件，要找到第i个记录，必须先顺序第查找前i-1个记录,但是很多应用场景中又必须使用可变长记录。如何解决这个问题?</p><p>这时我们可以建立一张索引表来快速找到第i个记录。如图所示：</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/0ed08cb468263930fb8ce29d870f9d1a.png" alt="image-20210810145421034"></p><p><strong>索引表本身是定长记录的顺序文件。</strong>因此可以快速找到第i个记录对应的索引项。</p><p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p><p>每当要增加&#x2F;删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。</p><p>另外，可以用不同的数据项建立多个索引表。如:学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。(Eg: SQL就支持根据某个数据项建立索引的功能)</p><h4 id="3-索引顺序文件"><a href="#3-索引顺序文件" class="headerlink" title="3.索引顺序文件"></a>3.索引顺序文件</h4><p>思考索引文件的缺点:每个记录对应一个索引表项，因此索引表可能会很大。比如:文件的每个记录平均只占8字节，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p><p>那么如何解决呢？</p><p>我们可以建立一个索引顺序文件。</p><p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是:<strong>并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。</strong></p><p>在本例中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不需要按关键字排序。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1f6bc1e1774b9f5c4387ef54e3b6983f.png" alt="image-20210810145653881"></p><h4 id="4-多级索引顺序文件"><a href="#4-多级索引顺序文件" class="headerlink" title="4.多级索引顺序文件"></a>4.多级索引顺序文件</h4><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。</p><p>例如，对于一个含10^6个记录的文件，可先为该文件建立一张低级索引表，每100个记录为一组，故低级索引表中共有10000个表项(即10000个定长记录)，再把这10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有100个表项。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/c57391f7d0fd8cb6fe66d30df8060bdd.png" alt="image-20210810145950405"></p><h3 id="3-文件目录"><a href="#3-文件目录" class="headerlink" title="3.文件目录"></a>3.文件目录</h3><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/53120cd1e8d7e5ffa75a3785d838aad7.png" alt="image-20210810151340203"></p><ul><li>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件。如图所示</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/455ae681993634c26745abb4a5ef3877.png" alt="image-20210810151448625"></p><h4 id="1-文件控制块（FCB）"><a href="#1-文件控制块（FCB）" class="headerlink" title="1.文件控制块（FCB）"></a>1.文件控制块（FCB）</h4><ul><li>目录文件中的一条记录就是一个“文件控制块（FCB)</li></ul><p>FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。</p><p>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读&#x2F;可写、禁止访问的用户名单等)，使用信息（如文件的建立时间、修改时间等）。</p><p>最重要，最基本的还是文件名、文件存放的物理地址。</p><h4 id="2-单级目录结构"><a href="#2-单级目录结构" class="headerlink" title="2.单级目录结构"></a>2.单级目录结构</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/6916bba80959bfb9bd318ea0fae93071.png" alt="image-20210810151856934"></p><h4 id="3-二级目录结构"><a href="#3-二级目录结构" class="headerlink" title="3.二级目录结构"></a>3.二级目录结构</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/24461e7a115feda74dfd5a328857af71.png" alt="image-20210810151925508"></p><h4 id="4-多级目录结构（树形目录结构）"><a href="#4-多级目录结构（树形目录结构）" class="headerlink" title="4.多级目录结构（树形目录结构）"></a>4.多级目录结构（树形目录结构）</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/09b5390d37938510db4ce5d774398940.png" alt="image-20210810152024749"></p><p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p><h4 id="5-无环图目录结构"><a href="#5-无环图目录结构" class="headerlink" title="5.无环图目录结构"></a>5.无环图目录结构</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/6460c75fa54a21687994959945c75e6d.png" alt="image-20210810152149951"></p><p>可以用不同的文件名指向同一个文件，甚至可以指向同一个目录(共享同一目录下的所有内容）。</p><p>需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。</p><p>只有共享计数器减为0时，才删除结点。</p><p>注意:共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</p><h4 id="6-索引结点（对FCB的改进）"><a href="#6-索引结点（对FCB的改进）" class="headerlink" title="6.索引结点（对FCB的改进）"></a>6.索引结点（对FCB的改进）</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/c37cb7773063eb6a3e639f5106d9734b.png" alt="image-20210810152356089"></p><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p><p>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如:文件是否被修改、此时有几个进程正在访问该文件等。</p><h3 id="4-文件分配方式（文件物理结构）"><a href="#4-文件分配方式（文件物理结构）" class="headerlink" title="4.文件分配方式（文件物理结构）"></a>4.文件分配方式（文件物理结构）</h3><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/254ba278ff55f9d078c5833f2d19e1ed.png" alt="image-20210810160612269"></p><p>在介绍这些分配方式之前，先介绍一下什么是文件块，磁盘块。</p><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面。</p><p>同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。</p><p>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。</p><p><strong>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/2e337392fe6b347faf9b8c052b6f8203.png" alt="image-20210810160801866"></p><h4 id="1-连续分配"><a href="#1-连续分配" class="headerlink" title="1.连续分配"></a>1.连续分配</h4><p><strong>连续分配方式要求每个文件在磁盘上占有一组连续的块。</strong>如图所示</p><p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB) </p><p><strong>物理块号&#x3D;起始块号＋逻辑块号</strong></p><p>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号≥长度就不合法)、</p><p>优点:支持顺序访问和直接访问（即随机访问)；连续分配的文件在顺序访问时速度最快</p><p>缺点:不方便文件拓展;存储空间利用率低，会产生磁盘碎片</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/d6919ae11bb4e125b3f0e6d81f80c7c9.png" alt="image-20210810161040710"></p><h4 id="2-链接分配——隐式链接"><a href="#2-链接分配——隐式链接" class="headerlink" title="2.链接分配——隐式链接"></a>2.链接分配——隐式链接</h4><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><ul><li>从逻辑块号到物理块号的转变</li></ul><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项(FCB)</p><p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。</p><p>因此，读入i号逻辑块，总共需要i+1次磁盘l&#x2F;O。</p><p>结论:采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/78021e0d2ec00fecab38cb0fe87d71f8.png" alt="image-20210810161314939"></p><h4 id="3-链接分配——显式链接"><a href="#3-链接分配——显式链接" class="headerlink" title="3.链接分配——显式链接"></a>3.链接分配——显式链接</h4><p>把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表（FAT，File Allocation Table)。如图所示</p><p>注意:一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。</p><ul><li>从逻辑块号到物理块号的转变</li></ul><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项( FCB) </p><p>从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作。</p><p>结论:采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的 0~i-1号逻辑块)，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p><p>显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/01d002c1a099e83f3981fceb95e89dce.png" alt="image-20210810161613102"></p><h4 id="4-两种链接分配方式总结"><a href="#4-两种链接分配方式总结" class="headerlink" title="4.两种链接分配方式总结"></a>4.两种链接分配方式总结</h4><p>隐式链接――除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p><ul><li>优点:很方便文件拓展，不会有碎片问题，外存利用率高。</li><li>缺点:只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul><p>显式链接――把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表（FAT，FileAllocation Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><ul><li>优点:很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点:文件分配表的需要占用一定的存储空间。</li></ul><h4 id="5-索引分配"><a href="#5-索引分配" class="headerlink" title="5.索引分配"></a>5.索引分配</h4><p>索引分配允许文件离散地分配在各个磁盘块中，<strong>系统会为每个文件建立一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系)。<strong>索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</strong></p><ul><li>从逻辑块号到物理块号的转变</li></ul><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项（FCB)</p><p>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可知道i号逻辑块在外存中的存放位置。</p><p>可见，索引分配方式可以支持随机访问。文件拓展也很容易实现(只需要给文件分配一个空闲块，并增加一个索引表项即可)</p><p>但是索引表需要占用一定的存储空间</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/27c2d5bff551562e2c981f36b44f677f.png" alt="image-20210810162255818"></p><ul><li>如果一个文件的索引表太大，一个磁盘块放不下，那么如何解决呢？</li></ul><p>可以用以下三种方式解决。</p><p>①链接方案:如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/25b3f3f2f52c118046dc13d067320719.png" alt="image-20210810162649614"></p><p>②多层索引:建立多层索引（原理类似于多级页表)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/d5527ab48037c33ea4b86291fef38692.png" alt="image-20210810162724018"></p><p>③混合索引:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引（指向两层索引表)。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/29c46f644f01928a558baa7390cff6ff.png" alt="image-20210810162801596"></p><blockquote><p>总结</p></blockquote><p>①链接方案 : 如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点:若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须先依次读入0~i-1号索引块，这就导致磁盘I&#x2F;O次数过多，查找效率低下。</p><p>②多层索引:建立多层索引(原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作。缺点:即使是小文件，访问一个数据块依然需要K+1次读磁盘。</p><p>③混合索引:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引(指向两层索引表)。优点:对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p><h4 id="6-三种分配方式总结"><a href="#6-三种分配方式总结" class="headerlink" title="6.三种分配方式总结"></a>6.三种分配方式总结</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/a935e9d61703ac76486ce85fff02032c.png" alt="image-20210810163334462"></p><h3 id="5-对空闲磁盘块的管理（文件存储空间管理）"><a href="#5-对空闲磁盘块的管理（文件存储空间管理）" class="headerlink" title="5.对空闲磁盘块的管理（文件存储空间管理）"></a>5.对空闲磁盘块的管理（文件存储空间管理）</h3><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/65d8f4e50b9f5ee8319a406ae5bd9399.png" alt="image-20210810165416231"></p><h4 id="1-文件卷"><a href="#1-文件卷" class="headerlink" title="1.文件卷"></a>1.文件卷</h4><p>存储空间的划分:将物理磁盘划分为一个个文件卷(逻辑卷、逻辑盘)。所谓的文件卷就相当于电脑上的C盘，D盘等。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/9190ef1cc05c0bc46256935a1505c2ef.png" alt="image-20210810165312412"></p><h4 id="2-空闲表法"><a href="#2-空闲表法" class="headerlink" title="2.空闲表法"></a>2.空闲表法</h4><p>为一个磁盘创建一个表，来存储空闲磁盘块的位置。</p><p>如何分配磁盘块 : 与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p><p>如何回收磁盘块:与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况―—①回收区的前后都没有相邻空闲区;②回收区的前后都是空闲区;③回收区前面是空闲区;④回收区后面是空闲区。总之，回收时需要注意表项的合并问题。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/23f116036ca8eb3fb7b85496ef93769b.png" alt="image-20210810165513344"></p><h4 id="3-空闲链表法"><a href="#3-空闲链表法" class="headerlink" title="3.空闲链表法"></a>3.空闲链表法</h4><p>空闲链表发分为空闲盘块链和空闲盘区链。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b77bd000a1f9e5ee32f2373a8c5ac6c4.png" alt="image-20210810165802397"></p><h5 id="1-空闲盘块链"><a href="#1-空闲盘块链" class="headerlink" title="1.空闲盘块链"></a>1.空闲盘块链</h5><ul><li>操作系统保存着链头、链尾指针。</li><li>如何分配:若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</li><li>如何回收:回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li><li>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/7292df03815fd9209ca5e8595b19d9c4.png" alt="image-20210810170003033"></p><h5 id="2-空闲盘区链"><a href="#2-空闲盘区链" class="headerlink" title="2.空闲盘区链"></a>2.空闲盘区链</h5><ul><li>操作系统保存着链头、链尾指针。</li><li>如何分配:若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</li><li>如何回收:若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</li><li>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b9dfcb60830df513bd8446b4197658b6.png" alt="image-20210810170223448"></p><h4 id="4-位示图法"><a href="#4-位示图法" class="headerlink" title="4.位示图法"></a>4.位示图法</h4><p>位示图:每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块。因此可以用(字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号)</p><p>(字号,位号)&#x3D;(i j)  的二进制位对应的盘块号 b&#x3D; ni + j</p><p>b号盘块对应的字号i &#x3D; b&#x2F;n，位号j &#x3D; b%n。</p><p>如何分配:若文件需要K个块，</p><p>①顺序扫描位示图，找到K个相邻或不相邻的“0”;</p><p>②根据字号、位号算出对应的盘块号，将相应盘块分配给文件;</p><p>③将相应位设置为“1”。</p><p>如何回收:</p><p>①根据回收的盘块号计算出对应的字号、位号;</p><p>②将相应二进制位设为“0”。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/88f18be166ec7bc85acebf36a2ddeb3c.png" alt="image-20210810170334688"></p><h4 id="5-成组链接法"><a href="#5-成组链接法" class="headerlink" title="5.成组链接法"></a>5.成组链接法</h4><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。<br>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。如图所示。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b884e81fa6bd4f0b022600eafce9b82c.png" alt="image-20210810170623901"></p><ul><li>超级块中存储的内容</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/326b4386246193c4e7d558161cb21a03.png" alt="image-20210810170801760"></p><ul><li><p>如何分配?<br>Eg :需要100个空闲块<br>①检查第一个分组的块数是否足够。100&#x3D;100，是足够的。</p><p>②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中。</p><p>Eg :需要1个空闲块<br>①检查第一个分组的块数是否足够。1&lt;100，因此是足够的。</p><p>②分配第一个分组中的1个空闲块，并修改相应数据</p></li><li><p>如何回收?<br>Eg :假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块。</p><p>Eg : 假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</p></li></ul><h3 id="6-文件的基本操作"><a href="#6-文件的基本操作" class="headerlink" title="6.文件的基本操作"></a>6.文件的基本操作</h3><h4 id="1-创建文件"><a href="#1-创建文件" class="headerlink" title="1.创建文件"></a>1.创建文件</h4><p>进行Create系统调用时，需要提供的几个主要参数:</p><ol><li><p>所需的外存空间大小（如:一个盘块，即1KB)</p></li><li><p>文件存放路径（“D:&#x2F;Demo”)</p></li><li><p>文件名（这个地方默认为“新建文本文档.txt”)</p><p>操作系统在处理Create系统调用时，主要做了两件事:</p></li></ol><p>1.在外存中找到文件所需的空间（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间)<br>2.根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:&#x2F;Demo目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</p><h4 id="2-删除文件"><a href="#2-删除文件" class="headerlink" title="2.删除文件"></a>2.删除文件</h4><p>进行Delete系统调用时，需要提供的几个主要参数:</p><p>1.文件存放路径（“D:&#x2F;Demo”)</p><p>2.文件名（“test.txt”)</p><p>操作系统在处理Delete系统调用时，主要做了几件事:</p><p>1．根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</p><p>2．根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)</p><p>3.从目录表中删除文件对应的目录项。</p><h4 id="3-打开文件"><a href="#3-打开文件" class="headerlink" title="3.打开文件"></a>3.打开文件</h4><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数:<br>1．文件存放路径（“D:&#x2F;Demo”)</p><p>2.文件名（ “test.txt”)</p><p>3．要对文件的操作类型（如:r只读;rw读写等)</p><p>操作系统在处理open系统调用时，主要做了几件事:</p><p>1．根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</p><p>2．将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/244f8f3efa56916fab688288de724d43.png" alt="image-20210813142750578"></p><ul><li>需要注意的是，有两张打开文件表，一个是进程自带的，另一个是系统的（只有一张）。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/6c2bc848e4337717642c135d1eac31d1.png" alt="image-20210813142335669"></p><h4 id="4-关闭文件"><a href="#4-关闭文件" class="headerlink" title="4.关闭文件"></a>4.关闭文件</h4><p>进程使用完文件后，要“关闭文件”。<br>操作系统在处理Close系统调用时，主要做了几件事:</p><p>1.将进程的打开文件表相应表项删除</p><p>2.回收分配给该文件的内存空间等资源</p><p>3.系统打开文件表的打开计数器count 减1，若count &#x3D;0，则删除对应表项。</p><h4 id="5-读文件"><a href="#5-读文件" class="headerlink" title="5.读文件"></a>5.读文件</h4><p>进程使用read系统调用完成写操作。</p><p>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可)，</p><p>还需要指明要读入多少数据（如:读入1KB）、</p><p>指明读入的数据要放在内存中的什么位置。</p><p>操作系统在处理read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p><h4 id="6-写文件"><a href="#6-写文件" class="headerlink" title="6.写文件"></a>6.写文件</h4><p>进程使用write系统调用完成写操作，</p><p>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），</p><p>还需要指明要写出多少数据（如:写出1KB)、</p><p>写回外存的数据放在内存中的什么位置</p><p>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p><h3 id="7-文件共享"><a href="#7-文件共享" class="headerlink" title="7.文件共享"></a>7.文件共享</h3><h4 id="1-基于索引节点的共享方式（硬链接）"><a href="#1-基于索引节点的共享方式（硬链接）" class="headerlink" title="1.基于索引节点的共享方式（硬链接）"></a>1.基于索引节点的共享方式（硬链接）</h4><p>知识回顾:索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1a5b412df0b98fbe964d16684e05af82.png" alt="image-20210813144036702"></p><p><strong>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</strong><br>若count &#x3D;2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。<br>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。当count &#x3D;0时系统负责删除文件。</p><h4 id="2-基于符号链的共享方式（软链接）"><a href="#2-基于符号链的共享方式（软链接）" class="headerlink" title="2.基于符号链的共享方式（软链接）"></a>2.基于符号链的共享方式（软链接）</h4><p>当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。类似于快捷方式。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/d608b1a370f5c8b07ae74529ca59a093.png" alt="image-20210813144244690"></p><h3 id="8-文件保护"><a href="#8-文件保护" class="headerlink" title="8.文件保护"></a>8.文件保护</h3><h4 id="1-口令保护"><a href="#1-口令保护" class="headerlink" title="1.口令保护"></a>1.口令保护</h4><p>为文件设置一个“口令”(如: abc112233），用户请求访问该文件时必须提供“口令”。</p><p>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件。</p><p>优点:保存口令的空间开销不多，验证口令的时间开销也很小。</p><p>缺点:正确的“口令”存放在系统内部，不够安全。</p><h4 id="2-加密保护"><a href="#2-加密保护" class="headerlink" title="2.加密保护"></a>2.加密保护</h4><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。<br>Eg:一个最简单的加密算法――异或加密。<br>假设用于加密&#x2F;解密的“密码”为“01001”。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/16b36ff5f4c1142c476390fe8675b67d.png" alt="image-20210813145725112"></p><p>优点:保密性强，不需要在系统中存储“密码”。</p><p>缺点:编码&#x2F;译码，或者说加密&#x2F;解密要花费一定时间。</p><h4 id="3-访问控制"><a href="#3-访问控制" class="headerlink" title="3.访问控制"></a>3.访问控制</h4><p>在每个文件的FCB（或索引结点）中增加一个访问控制列表(Access-Control List, ACL)，该表中记录了各个用户可以对该文件执行哪些操作。如图所示：</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b17edf512d307f91a1a15cdb6a068ac4.png" alt="image-20210813145849324"></p><p>精简的访问列表:以“组”为单位，标记各“组”用户可以对文件执行哪些操作。如:分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/e4fff7eb5201827e7cc9ef083e72a7dd.png" alt="image-20210813145938099"></p><h4 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4.总结"></a>4.总结</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/946de3aa6b1036fb14827d65f9b3c7f6.png" alt="image-20210813150016165"></p><h3 id="9-文件的层次结构"><a href="#9-文件的层次结构" class="headerlink" title="9.文件的层次结构"></a>9.文件的层次结构</h3><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/10668e3ef884278c3255e9922dbf2dda.png" alt="image-20210813150515554"></p><p>用一个例子来辅助记忆文件系统的层次结构:</p><p>假设某用户请求删除文件“D:&#x2F;工作目录&#x2F;学生信息.xlsx”的最后100条记录。</p><ol><li>用户需要通过操作系统提供的接口发出上述请求一用户接口。</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项――文件目录系统</li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限―一存取控制模块（存取控制验证层)</li><li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址――逻辑文件系统与文件信息缓冲区</li><li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址――物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求――设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收――辅助分配模块。</li></ol><h3 id="10-磁盘结构"><a href="#10-磁盘结构" class="headerlink" title="10.磁盘结构"></a>10.磁盘结构</h3><ul><li>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</li><li>磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道。</li><li>一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同（如1KB)。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5d3e9a9610fef48c7bec9b2bdc1ca781.png" alt="image-20210813151311575"></p><ul><li>所有盘面中相对位置相同的磁道组成柱面。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/2086cd965a3b65368cc829804454175c.png" alt="image-20210813151500796"></p><ul><li><p><strong>可用(柱面号，盘面号，扇区号）来定位任意一个“磁盘块”。</strong></p></li><li><p>可根据该地址读取一个“块”<br>①根据“柱面号”移动磁臂，让磁头指向指定柱面;<br>②激活指定盘面对应的磁头;<br>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</p></li><li><p>磁盘分类</p></li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/44eb50127c6e7aa9eac2063f6e4efc14.png" alt="image-20210813151834210"></p><h3 id="11-磁盘调度算法"><a href="#11-磁盘调度算法" class="headerlink" title="11.磁盘调度算法"></a>11.磁盘调度算法</h3><h4 id="1-一次磁盘读-写操作需要的时间"><a href="#1-一次磁盘读-写操作需要的时间" class="headerlink" title="1.一次磁盘读&#x2F;写操作需要的时间"></a>1.一次磁盘读&#x2F;写操作需要的时间</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1b76fd0a459e00dddb9a38233d4bc18c.png" alt="image-20210813155004975"></p><ul><li><p><strong>寻找时间</strong>(寻道时间)Ts:在读&#x2F;写数据前，将磁头移动到指定磁道所花的时间。<br>①启动磁头臂是需要时间的。假设耗时为s;<br>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则:<br>寻道时间Ts &#x3D; s + m*n </p></li><li><p><strong>延迟时间</strong>T:通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位:转&#x2F;秒，或转&#x2F;分），则平均所需的延迟时间T&#x3D;(1&#x2F;2)*(1&#x2F;r)&#x3D; 1&#x2F;2r。</p><p>1&#x2F;r就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1&#x2F;2</p></li><li><p><strong>传输时间</strong>Tt:从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读&#x2F;写的字节数为b，每个磁道上的字节数为N。则:<br>传输时间Tt &#x3D; (1&#x2F;r)*(b&#x2F;N) &#x3D; b&#x2F;(rN)</p><p>每个磁道要可存N字节的数据，因此b字节的数据需要b&#x2F;N个磁道才能存储。而读&#x2F;写一个磁道所需的时间刚好又是转一圈所需要的时间1&#x2F;r。</p></li><li><p>总的平均存取时间    T&#x3D;Ts+ 1&#x2F;2r + b&#x2F;(rN)</p></li></ul><p>延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。但是操作系统的磁盘调度算法会直接影响寻道时间。</p><h4 id="2-先来先服务算法"><a href="#2-先来先服务算法" class="headerlink" title="2.先来先服务算法"></a>2.先来先服务算法</h4><ul><li>根据进程请求访问磁盘的先后顺序进行调度。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/257d07ab99e1e4c9a5454a0882fd2902.png" alt="image-20210813154130996"></p><h4 id="3-最短寻找时间优先（SSTF）"><a href="#3-最短寻找时间优先（SSTF）" class="headerlink" title="3. 最短寻找时间优先（SSTF）"></a>3. 最短寻找时间优先（SSTF）</h4><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/47fabb28ddaecfd76ea4d2dfa0b4167c.png" alt="image-20210813154241694"></p><h4 id="4-扫描算法（SCAN）"><a href="#4-扫描算法（SCAN）" class="headerlink" title="4.扫描算法（SCAN）"></a>4.扫描算法（SCAN）</h4><p>SSTF算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法（SCAN)的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/9829ac37c98996d23f4d4bc981c76853.png" alt="image-20210813154355809"></p><h4 id="5-LOOK调度算法"><a href="#5-LOOK调度算法" class="headerlink" title="5.LOOK调度算法"></a>5.LOOK调度算法</h4><p>扫描算法（SCAN)中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LOOK调度算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。(边移动边观察，因此叫LOOK)。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/750e7461ef9890cd4995284f060d32ea.png" alt="image-20210813154445923"></p><h4 id="6-循环扫描算法（C—SCAN）"><a href="#6-循环扫描算法（C—SCAN）" class="headerlink" title="6.循环扫描算法（C—SCAN）"></a>6.循环扫描算法（C—SCAN）</h4><p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/4886bb838661f65adc18c2fdd2480e4e.png" alt="image-20210813154603757"></p><h4 id="7-C-LOOK调度算法"><a href="#7-C-LOOK调度算法" class="headerlink" title="7.C-LOOK调度算法"></a>7.C-LOOK调度算法</h4><p>C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/fdce0d6e9a21aafe91c6c34f05f0364b.png" alt="image-20210813154656781"></p><h3 id="12-减少延迟时间的方法"><a href="#12-减少延迟时间的方法" class="headerlink" title="12.减少延迟时间的方法"></a>12.减少延迟时间的方法</h3><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/925f80e8771b6865bb4aaf7359240a22.png" alt="image-20210813160340909"></p><p>假设要连续读取橙色区域的2、3、4扇区:<br>磁头读取一块的内容（也就是一个扇区的内容）后，需要一小段时间处理，而盘片又在不停地旋转<br>因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断地读入3号扇区<br>必须等盘片继续旋转，3号扇区再次划过磁头，才能完成扇区读入。</p><p>结论:磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/fecc8f266994899bfc69f872d275fcd8.png" alt="image-20210813160402020"></p><h4 id="1-交替编号"><a href="#1-交替编号" class="headerlink" title="1.交替编号"></a>1.交替编号</h4><p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。如图所示。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/706a5c85cb0c50130e486122a77f8c02.png" alt="image-20210813160529803"></p><h4 id="2-磁盘地址结构的设计"><a href="#2-磁盘地址结构的设计" class="headerlink" title="2.磁盘地址结构的设计"></a>2.磁盘地址结构的设计</h4><p>思考:为什么磁盘的物理地址是（柱面号，盘面号，扇区号)，而不是(盘面号，柱面号，扇区号)？</p><p>答:读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</p><p>注：不是很理解</p><h4 id="3-错位命名"><a href="#3-错位命名" class="headerlink" title="3.错位命名"></a>3.错位命名</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/33b98e507dedcb34fa42516b3b954afd.png" alt="image-20210813160725166"></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ef5527060892742253d8ba60f3d9775c.png" alt="image-20210813160747164"></p><h3 id="13-磁盘的管理"><a href="#13-磁盘的管理" class="headerlink" title="13.磁盘的管理"></a>13.磁盘的管理</h3><h4 id="1-磁盘初始化"><a href="#1-磁盘初始化" class="headerlink" title="1.磁盘初始化"></a>1.磁盘初始化</h4><p>磁盘初始化:<br>Step 1:进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)</p><p>Step 2:将磁盘分区，每个分区由若干柱面（磁道）组成（即分为我们熟悉的C盘、D盘、E盘)</p><p>step 3:进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表)</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/4cd21c25564fd0f4c5a686c336d5802e.png" alt="image-20210813161518921"></p><h4 id="2-引导块"><a href="#2-引导块" class="headerlink" title="2.引导块"></a>2.引导块</h4><ul><li><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。</p></li><li><p>初始化程序可以放在ROM(只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改 。</p></li></ul><p>初始化程序程序（自举程序）放在ROM中存在什么问题?万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改。如何解决呢?</p><ul><li><p>ROM中只存放很小的“自举装入程序”。开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</p></li><li><p>完整的自举程序放在磁盘的启动块(即引导块&#x2F;启动分区)上，启动块位于磁盘的固定位置。</p></li><li><p>拥有启动分区的磁盘称为启动磁盘或系统磁盘（c:盘)</p></li></ul><h4 id="3-坏块的管理"><a href="#3-坏块的管理" class="headerlink" title="3.坏块的管理"></a>3.坏块的管理</h4><ul><li>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。 </li><li>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时)对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如:在FAT表上标明。（在这种方式中，坏块对操作系统不透明)</li><li>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<br>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。<br>会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</li></ul><h2 id="5-I-O管理"><a href="#5-I-O管理" class="headerlink" title="5.I&#x2F;O管理"></a>5.I&#x2F;O管理</h2><h3 id="1-I-O设备的概念"><a href="#1-I-O设备的概念" class="headerlink" title="1.I&#x2F;O设备的概念"></a>1.I&#x2F;O设备的概念</h3><ul><li>“I&#x2F;O” 就是“输入&#x2F;输出”(Input&#x2F;Output)</li><li>I&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</li></ul><h3 id="2-I-O控制器"><a href="#2-I-O控制器" class="headerlink" title="2.I&#x2F;O控制器"></a>2.I&#x2F;O控制器</h3><h4 id="1-含义-2"><a href="#1-含义-2" class="headerlink" title="1.含义"></a>1.含义</h4><ul><li>CPU无法直接控制l&#x2F;O设备的机械部件，因此I&#x2F;O设备还要有一个电子部件作为CPU和I&#x2F;O设备机械部件之间的“中介”，用于实现CPU对设备的控制。</li><li>这个电子部件就是I&#x2F;O控制器，又称设备控制器。CPU可控制I&#x2F;o控制器，又由I&#x2F;O控制器来控制设备的机械部件。</li></ul><h4 id="2-功能"><a href="#2-功能" class="headerlink" title="2.功能"></a>2.功能</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b245e1b6ad88b4dfe3719359142edd4d.png" alt="image-20210804154622720"></p><h4 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成"></a>3.组成</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/8c9ebb99a1a9074a142f333bee867ea2.png" alt="image-20210804155007898"></p><h3 id="3-I-O控制方式"><a href="#3-I-O控制方式" class="headerlink" title="3.I&#x2F;O控制方式"></a>3.I&#x2F;O控制方式</h3><h4 id="1-程序直接控制方式"><a href="#1-程序直接控制方式" class="headerlink" title="1.程序直接控制方式"></a>1.程序直接控制方式</h4><ul><li>完成一次读&#x2F;写操作的流程图(以读操作为例)</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/306152b917fc4eadafdf980ebb4e7eee.png" alt="在这里插入图片描述"></p><ul><li>流程图</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/c270e30fb0374ce426893887ce4e9d3b.png" alt="在这里插入图片描述"></p><h4 id="2-中断驱动方式"><a href="#2-中断驱动方式" class="headerlink" title="2.中断驱动方式"></a>2.中断驱动方式</h4><ul><li>由于程序直接控制方式CPU利用率低，忙等，所以提出了中断驱动方式。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/f74e1473feb475dd14eeca4f37b5a021.png" alt="在这里插入图片描述"></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/c795c5127f304fc4a5f02a349bbcc9a0.png" alt="在这里插入图片描述"></p><h4 id="3-DMA方式"><a href="#3-DMA方式" class="headerlink" title="3.DMA方式"></a>3.DMA方式</h4><ul><li>虽然中断驱动方式解决了程序直接控制方式的问题，但是每一次只能读&#x2F;写一个字，导致CPU频繁切换，耗费了很多时间。于是人们又发明了DMA方式。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ce47762f25cfbf9839a181db27141e14.png" alt="在这里插入图片描述"></p><ul><li>DMA控制器</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/98c04f667c7ed1631bff510e3fc5937c.png" alt="在这里插入图片描述"></p><p>- </p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/3f387b03b08612e01e051f18ff44e33a.png" alt="在这里插入图片描述"></p><h4 id="4-通道控制方式"><a href="#4-通道控制方式" class="headerlink" title="4.通道控制方式"></a>4.通道控制方式</h4><ul><li>通道控制方式是为了解决DMA方式连续存储的问题</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/6457dfe15349fbddab5a18be6aa21916.png" alt="在这里插入图片描述"></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/2713e1afa5f6e44bb77f1199efa43c38.png" alt="在这里插入图片描述"></p><h4 id="5-四种方式总结"><a href="#5-四种方式总结" class="headerlink" title="5.四种方式总结"></a>5.四种方式总结</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/23c164533617729d7433e1227332177d.png" alt="在这里插入图片描述"></p><h3 id="4-I-O软件层次结构"><a href="#4-I-O软件层次结构" class="headerlink" title="4.I&#x2F;O软件层次结构"></a>4.I&#x2F;O软件层次结构</h3><h4 id="1-知识总览"><a href="#1-知识总览" class="headerlink" title="1.知识总览"></a>1.知识总览</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5847e7daab7e2dd23fa2d4358f37b71d.png" alt="image-20210813172017447"></p><h4 id="2-用户层软件"><a href="#2-用户层软件" class="headerlink" title="2.用户层软件"></a>2.用户层软件</h4><ul><li>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;o操作相关的库函数对设备进行操作。</li><li>用户层软件将用户请求翻译成格式化的I&#x2F;o请求，并通过“系统调用”请求操作系统内核的服务。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/756c09b8cd0bd1e5e6ad714f0ba8b070.png" alt="image-20210813172214640"></p><h4 id="3-设备独立性软件"><a href="#3-设备独立性软件" class="headerlink" title="3.设备独立性软件"></a>3.设备独立性软件</h4><p>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>主要功能：</p><ol><li>向上层提供统一的调用接口（如read&#x2F;write系统调用)</li><li>设备的保护。（原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。）</li><li>差错处理（设备独立性软件需要对一些设备的错误进行处理）</li><li>设备的分配与回收</li><li>数据缓冲区管理（可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异）</li><li>建立逻辑设备名到物理设备名的映射关系;根据设备类型选择调用相应的驱动程序</li></ol><p>用户或用户层软件发出I&#x2F;o操作相关系统调用的系统调用时，需要指明此次要操作的I&#x2F;o设备的逻辑设备名（eg:去学校打印店打印时，需要选择打印机1&#x2F;打印机2&#x2F;打印机3，其实这些都是逻辑设备名)<br>设备独立性软件需要通过“逻辑设备表（LUT，Logical UnitTable）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。如图所示：</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/e09722205b779262ad239f569279491a.png" alt="image-20210813172808277"></p><p>操作系统系统可以采用两种方式管理逻辑设备表(LUT) :<br>第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</p><p>第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</p><h4 id="4-驱动设备"><a href="#4-驱动设备" class="headerlink" title="4.驱动设备"></a>4.驱动设备</h4><p>思考:为何不同的设备需要不同的设备驱动程序?</p><p>不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/959f5d25bffa0a2c27f15966d1bead07.png" alt="image-20210813173131230"></p><h4 id="5-中断处理程序"><a href="#5-中断处理程序" class="headerlink" title="5.中断处理程序"></a>5.中断处理程序</h4><p>当I&#x2F;o任务完成时，I&#x2F;o控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下:</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/6331bc728bc60ecf52d671ea760e97d2.png" alt="image-20210813173226846"></p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/e75bd4df046d748f7891e08bab14db8f.png" alt="image-20210813173303452"></p><h3 id="5-I-O核心子系统"><a href="#5-I-O核心子系统" class="headerlink" title="5.I&#x2F;O核心子系统"></a>5.I&#x2F;O核心子系统</h3><h4 id="1-知识总览-1"><a href="#1-知识总览-1" class="headerlink" title="1.知识总览"></a>1.知识总览</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/c0a6413a509710ba2cf7b3cd60545d68.png" alt="image-20210813173804207"></p><ul><li>这些功能在哪些层次上实现呢？</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5ae321d874294707abfd86536c4f9d64.png" alt="image-20210813173845210"></p><h4 id="2-I-O调度"><a href="#2-I-O调度" class="headerlink" title="2.I&#x2F;O调度"></a>2.I&#x2F;O调度</h4><p><strong>I&#x2F;O调度:用某种算法确定一个好的顺序来处理各个I&#x2F;o请求。</strong><br>如:磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。</p><p>当多个磁盘I&#x2F;o请求到来时，用某种调度算法确定满足I&#x2F;o请求的顺序。</p><p>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定IV&#x2F;o调度顺序。</p><h4 id="3-设备保护"><a href="#3-设备保护" class="headerlink" title="3.设备保护"></a>3.设备保护</h4><p>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如:只读、读和写等）。<br>在UNIx系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。(参考“文件保护”小节)</p><h3 id="6-假脱机技术（SPOOLing技术）"><a href="#6-假脱机技术（SPOOLing技术）" class="headerlink" title="6.假脱机技术（SPOOLing技术）"></a>6.假脱机技术（SPOOLing技术）</h3><h4 id="1-脱机技术"><a href="#1-脱机技术" class="headerlink" title="1.脱机技术"></a>1.脱机技术</h4><ul><li>手工操作阶段:主机直接从l&#x2F;o设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。因此在批处理阶段引入了脱机输入&#x2F;输出技术（用磁带完成).</li></ul><p>Tips:为什么称为“脱机”？一脱离主机的控制进行的输入&#x2F;输出操作。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b8655545ac79350b99d5648c9308b19a.png" alt="image-20210813174939614"></p><h4 id="2-假脱机技术"><a href="#2-假脱机技术" class="headerlink" title="2.假脱机技术"></a>2.假脱机技术</h4><p>“假脱机技术”，又称“SPOOLing 技术”，用软件的方式模拟脱机技术。SPOQLing系统的组成如下:</p><ul><li>“输入井”模拟脱机输入时的磁带，用于收容I&#x2F;o设备输入的数据</li><li>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据 </li><li>“输入进程”模拟脱机输入时的外围控制机</li><li>“输出进程”模拟脱机输出时的外围控制机</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1cb679f7403e661ca47fe0cd5de69f70.png"></p><p>要实现SPOOLing 技术，必须要有多道程序技术的支持。系统会建立“输入进程”和“输出进程”。</p><h3 id="7-设备的分配和回收"><a href="#7-设备的分配和回收" class="headerlink" title="7.设备的分配和回收"></a>7.设备的分配和回收</h3><h4 id="1-知识总览-2"><a href="#1-知识总览-2" class="headerlink" title="1.知识总览"></a>1.知识总览</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b325e2ddf44d20ed7843f032ed557773.png" alt="image-20210813182209052"></p><h4 id="2-设备分配时考虑的因素"><a href="#2-设备分配时考虑的因素" class="headerlink" title="2.设备分配时考虑的因素"></a>2.设备分配时考虑的因素</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/cc7c4db27ad593251cb8949c2c574bcb.png" alt="image-20210813182256861"></p><h5 id="1-固有属性"><a href="#1-固有属性" class="headerlink" title="1.固有属性"></a>1.固有属性</h5><p>设备的固有属性可分为三种:独占设备、共享设备、虚拟设备。</p><ul><li>独占设备—— 一个时段只能分配给一个进程（如打印机)</li><li>共享设备――可同时分配给多个进程使用（如磁盘)，各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li><li>虚拟设备――采用SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）</li></ul><h5 id="2-分配算法"><a href="#2-分配算法" class="headerlink" title="2.分配算法"></a>2.分配算法</h5><p>先来先服务，优先级高者优先，短任务优先…….</p><h5 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3.安全性"></a>3.安全性</h5><p>从进程运行的安全性上考虑，设备分配有两种方式:</p><p><strong>安全分配方式</strong>:为进程分配一个设备后就将进程阻塞，本次I&#x2F;O完成后才将进程唤醒。(eg:考虑进程请求打印机打印输出的例子)</p><ul><li>一个时段内每个进程只能使用一个设备</li><li>优点:破坏了“请求和保持”条件，不会死锁</li><li>缺点:对于一个进程来说，CPU和I&#x2F;o设备只能串行工作</li></ul><p><strong>不安全分配方式</strong>:进程发出I&#x2F;o请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;o请求。只有某个l&#x2F;o请求得不到满足时才将进程阻塞。</p><ul><li>一个进程可以同时使用多个设备</li><li>优点:进程的计算任务和I&#x2F;o任务可以并行处理，使进程迅速推进</li><li>缺点:有可能发生死锁(死锁避免、死锁的检测和解除)</li></ul><h4 id="3-静态分配和动态分配"><a href="#3-静态分配和动态分配" class="headerlink" title="3.静态分配和动态分配"></a>3.静态分配和动态分配</h4><ul><li>静态分配:进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了“请求和保持”条件，不会发生死锁</li><li>动态分配:进程运行过程中动态申请设备资源</li></ul><h4 id="4-设备分配中的数据结构"><a href="#4-设备分配中的数据结构" class="headerlink" title="4.设备分配中的数据结构"></a>4.设备分配中的数据结构</h4><p>“设备、控制器、通道”之间的关系:</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/eed8f3381d1ca8d9a3eca4c3d3940a84.png" alt="image-20210813183138648"></p><ul><li>**设备控制表（DCT):**系统为每个设备配置一张DCT，用于记录设备情况</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/754953b8778912c40240516d506e3600.png" alt="image-20210813183223442"></p><ul><li>**控制器控制表(COCT):**每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5910d8c0e2e8b9ec83d77427a1b3dcfe.png" alt="image-20210813183256911"></p><ul><li>**通道控制表（CHCT):**每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/2fd201a632d64cfd73b3121eabaac8d1.png" alt="image-20210813183402979"></p><ul><li><strong>系统设备表(SDT)</strong>:记录了系统中全部设备的情况，每个设备对应一个表目。</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/ba7cc6105c8ebb3a419734edadaa39de.png" alt="image-20210813183445007"></p><h4 id="5-设备分配的步骤"><a href="#5-设备分配的步骤" class="headerlink" title="5.设备分配的步骤"></a>5.设备分配的步骤</h4><p>①根据进程请求的物理设备名查找SDT（注:物理设备名是进程请求分配设备时提供的参数)</p><p>②根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</p><p>③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</p><p>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</p><p>注∶只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可后动&#x2F;O设备进行数据传送。</p><p>缺点:<br>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</p><p>②若换了一个物理设备，则程序无法运行</p><p>③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</p><p>改进方法:建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/b193222294d78fd22bc3cbe099337365.png" alt="image-20210813183902617"></p><h4 id="6-设备分配步骤的改进"><a href="#6-设备分配步骤的改进" class="headerlink" title="6.设备分配步骤的改进"></a>6.设备分配步骤的改进</h4><p>①根据进程请求的逻辑设备名查找SDT(注:用户编程时提供的逻辑设备名其实就是“设备类型”)</p><p>②查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT)中新增一个表项。</p><p>③根据DCT找到cOCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</p><p>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/4ceb806da6cb08069408544586626927.png" alt="image-20210813183835147"></p><ul><li>逻辑设备表</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/bc3f8875a6fc4046cd09b15a14028d6f.png" alt="image-20210813183947599"></p><h3 id="8-缓冲区管理"><a href="#8-缓冲区管理" class="headerlink" title="8.缓冲区管理"></a>8.缓冲区管理</h3><h4 id="1-知识总览-3"><a href="#1-知识总览-3" class="headerlink" title="1.知识总览"></a>1.知识总览</h4><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/7584d0bcc82642831f254ac6495d8b0e.png" alt="image-20210813184118658"></p><h4 id="2-含义和作用"><a href="#2-含义和作用" class="headerlink" title="2.含义和作用"></a>2.含义和作用</h4><blockquote><p>含义</p></blockquote><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)</p><p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</p><blockquote><p>作用</p></blockquote><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1856920cb50c0e6e4719e0e92932a2ae.png" alt="image-20210813184305965"></p><h4 id="3-单缓冲"><a href="#3-单缓冲" class="headerlink" title="3.单缓冲"></a>3.单缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。如图所示<br><strong>注意:当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</strong></p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5a212ffd1b1beccd83b63bf80ebed731.png" alt="image-20210813184442012"></p><ul><li>处理一块数据的平均时间</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/395562b2e164baffc952ef7f163c4dcf.png" alt="image-20210813184559073"></p><h4 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4.双缓冲"></a>4.双缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块)。</p><ul><li>假设T&gt;C+M</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/e5ec5cd1f55a449d7e0470a32a6a066e.png" alt="image-20210813184707380"></p><ul><li>假设T&lt;C+M</li></ul><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/5a08a579ba2812f775a45fd937aaf195.png" alt="image-20210813184750672"></p><p>**结论:采用双缓冲策略，处理一个数据块的平均耗时为Max (T,C+M)**。</p><h4 id="5-循环缓冲区"><a href="#5-循环缓冲区" class="headerlink" title="5.循环缓冲区"></a>5.循环缓冲区</h4><p>将多个大小相等的缓冲区链接成一个循环队列。<br>注:以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/9677c6126845a9fb17c029f01deda580.png" alt="image-20210813184911606"></p><h4 id="6-缓冲池"><a href="#6-缓冲池" class="headerlink" title="6.缓冲池"></a>6.缓冲池</h4><p>缓冲池由系统中共用的缓冲区组成。</p><p>这些缓冲区按使用状况可以分为:空缓冲队列、装满输入数据的缓冲队列(输入队列)、装满输出数据的缓冲队列（输出队列）。</p><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:用于收容输入数据的工作缓冲区(hin)、用于提取输入数据的工作缓冲区（sin)、用于收容输出数据的工作缓冲区(hout） 、用于提取输出数据的工作缓冲区(sout)。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/12d72547f589f1652a3e165289a83ec7.png" alt="image-20210813185014461"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接器与逻辑、物理地址解析</title>
      <link href="/hexo-blog/2024/06/20/%E9%93%BE%E6%8E%A5%E5%99%A8%E4%B8%8E%E9%80%BB%E8%BE%91%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90/"/>
      <url>/hexo-blog/2024/06/20/%E9%93%BE%E6%8E%A5%E5%99%A8%E4%B8%8E%E9%80%BB%E8%BE%91%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="链接器与逻辑、物理地址解析"><a href="#链接器与逻辑、物理地址解析" class="headerlink" title="链接器与逻辑、物理地址解析"></a>链接器与逻辑、物理地址解析</h1><p><img src="/hexo-blog/img/note/%E9%93%BE%E6%8E%A5%E5%99%A8%E4%B8%8E%E9%80%BB%E8%BE%91%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90/image-20240620115456830.png" alt="image-20240620115456830"></p><p>在软件开发与执行流程中，链接器、逻辑地址、物理地址三者紧密相关，共同支撑起程序从源码到可执行文件的桥梁。下面是对这三个概念及其相互作用的简要概述。</p><h2 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h2><p><strong>逻辑地址</strong>，在程序设计和编译阶段使用，是程序内部视角的内存地址表示。它为程序提供了一个抽象的地址空间，使得开发者无需考虑实际物理内存布局。逻辑地址通过编译和链接过程逐步构建，但不直接对应硬件内存的实际位置。</p><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p><strong>物理地址</strong>，又称绝对地址，是计算机内存芯片上的实际存储位置，由CPU直接寻址。它是内存中数据的实际存放地址，与硬件直接关联，与操作系统如何管理内存无关。</p><h2 id="链接器的作用"><a href="#链接器的作用" class="headerlink" title="链接器的作用"></a>链接器的作用</h2><p><strong>链接器</strong>作为编译后的重要一环，帮助可执行程序形成完整的逻辑地址，其主要职责是：</p><ol><li><strong>整合目标文件</strong>：将编译器生成的多个目标文件（包含代码、数据及其逻辑地址信息）合并为单一可执行文件。</li><li><strong>解析符号</strong>：解决目标文件间函数、变量的引用问题，确保逻辑地址的有效链接。</li><li><strong>重定位</strong>：调整代码和数据段的逻辑地址，为最终加载到内存做准备。虽然链接器处理的是逻辑地址，但它通过重定位为物理地址映射打下基础。</li><li><strong>库集成</strong>：集成静态库或动态库，处理外部符号引用，保持逻辑地址的一致性。</li><li><strong>生成可执行文件</strong>：最终输出的可执行文件中，逻辑地址布局已定，但具体映射到物理内存的过程通常在程序加载或运行时由操作系统完成。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>链接器在程序生命周期中起到了承前启后的作用，它基于逻辑地址进行整合与优化，为程序的物理地址映射奠定了基础。理解链接器的工作原理，以及逻辑地址与物理地址的区别，是深入学习操作系统内存管理和程序执行流程的关键。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统ch3</title>
      <link href="/hexo-blog/2024/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fch3/"/>
      <url>/hexo-blog/2024/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fch3/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统ch3"><a href="#操作系统ch3" class="headerlink" title="操作系统ch3"></a>操作系统ch3</h1><h2 id="一、银行家算法补充题-必做"><a href="#一、银行家算法补充题-必做" class="headerlink" title="一、银行家算法补充题(必做)"></a>一、银行家算法补充题(必做)</h2><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fch3/image-20240619134927087.png" alt="image-20240619134927087"><img src="/img/note/操作系统ch3/image-20240619135128430.png" alt="image-20240619135128430" style="zoom: 50%;" />   </p><h2 id="二、死锁检测补充题目"><a href="#二、死锁检测补充题目" class="headerlink" title="二、死锁检测补充题目"></a>二、死锁检测补充题目</h2><p>1.系统拥有的资源有 R1、R2、R3、R4、R5 和 R6 数量分别为 2、1、1、1、1 和 2，当前进程有 A、B、C、D 和 E，已知当前进程和资源的申请、分配关系，如下表所示。</p><p>请画出当前系统的资源分配图，并给出简化过程。</p><p><img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fch3/wps1.png" alt="img"> </p><p> <img src="/hexo-blog/img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fch3/image-20240619154927198.png" alt="image-20240619154927198"></p><p>2.若系统有同类资源m个，被n个进程共享，当m&gt;n时，每个进程最多可以请求(m&#x2F;n向上取整)个这类资源，使系统一定不会发生死锁。当m≤时每个进程最多可以请求1个这类资源，使系统一定不会发生死锁。注意：本题是求最大值。</p><h2 id="三、思维导图"><a href="#三、思维导图" class="headerlink" title="三、思维导图"></a>三、思维导图</h2><h2 id="四、选择题"><a href="#四、选择题" class="headerlink" title="四、选择题"></a>四、选择题</h2><ol><li><p>银行家算法是一种算法 __<br>A、死锁解除<br>B、死锁检测<br>C、死锁预防<br>D、死锁避免  </p></li><li><p>某系统中有3个并发进程，都需要同类资源4个，请问该系统中不会发生死锁的最少资源数是__<br>A、9<br>B、10<br>C、11<br>D、12  </p></li><li><p>某计算机系统中有8台打印机，有K个进程竞争使用，每个进程最多需要3台打印机。该系统可能会发生死锁的K的最小值是__<br>A、2<br>B、3<br>C、4<br>D、5  </p></li><li><p>3个进程共享4个同类资源，这些资源的分配与释放只能一次一个。已知每一个进程最多需要两个该类资源，则该系统__<br>A、有某进程可能永远得不到该类资源<br>B、必然有玩死锁<br>C、当进程请求该类资源时立刻就能得到<br>D、必然无死锁  </p></li><li><p>破坏死锁的4个必要条件之一就可以预防死锁。若规定一个进程在请求新资源之前，首先释放已占有的资源，这是破坏了哪一个条件？__<br>A、不可抢占条件<br>B、互斥条件<br>C、请求和保持条件<br>D、环路等待条件</p></li></ol><p><strong>1-5</strong>    DBCDC</p><h2 id="五、填空题"><a href="#五、填空题" class="headerlink" title="五、填空题"></a>五、填空题</h2><p>1 在计算机系统当中，资源可以分为两种类型：可抢占的资源和不可抢占的资源。对于可抢占的资源，可以通过重新分配资源的方法来避免死锁。那么在计算机系统当中，哪一些资源是可抢占的资源？请给出两个具体的例子：<strong>CPU</strong>和<strong>内存</strong> 。</p><p>2 在一个系统中，要想形成死锁，至少要有<strong>2</strong>个进程。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go中并发编程</title>
      <link href="/hexo-blog/2024/06/16/go%E4%B8%AD%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/hexo-blog/2024/06/16/go%E4%B8%AD%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="go中并发编程"><a href="#go中并发编程" class="headerlink" title="go中并发编程"></a>go中并发编程</h1><p>原子操作相关的包 <code>sync/atomic</code>。然而，atomic 仅支持单个变量的原子操作「Load, Store, Swap, CompareAndSwap」。如果需要一块程序片段在任意时刻最多只能有一个 CPU 执行，需要怎么做呢？我们将这块程序片段叫做临界区。也就是说，临界区内的代码在同一时间只能被一个 CPU 执行，且不会被打断。</p><h2 id="什么是-Mutex"><a href="#什么是-Mutex" class="headerlink" title="什么是 Mutex"></a>什么是 Mutex</h2><p><code>Mutex(Mutual exclusion)</code> 又叫互斥锁，用于保护临界区，防止多个 goroutine 同时访问临界区。仍然以计数器为例，现在使用 Mutex 创建一个计数器。其中 count 就是临界区，使用 Mutex 的 Lock() 和 Unloack() 方法 保证了任意时刻至多只有一个 goroutine 执行 c.count++ 操作，从而保证了计数的准确性。WaitGroup 后续会详细介绍，这里可以先忽略。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    m     sync.Mutex</span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Incr() &#123;</span><br><span class="line">    c.m.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Counter&#123;&#125;</span><br><span class="line">    wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          <span class="keyword">defer</span> wg.Done()</span><br><span class="line">          c.Incr()</span><br><span class="line">       &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(c.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Mutex 中，如果临界区正在被访问，则后续的请求会被阻塞，直到资源被释放，获得锁。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">          <span class="comment">// 后续的 goroutine 会一直阻塞</span></span><br><span class="line">          m.Lock()</span><br><span class="line">          time.Sleep(time.Second)</span><br><span class="line">          fmt.Printf(<span class="string">&quot;%d get lock\n&quot;</span>, i)</span><br><span class="line">          m.Unlock()</span><br><span class="line">          wg.Done()</span><br><span class="line">       &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于有些场景，如果临界区正在被访问，则放弃访问临界区，转而执行其他操作。这时就可以使用 mutex 提供的 TryLock() 方法，如果临界区正在被访问则返回 false。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">          <span class="keyword">defer</span> wg.Done()</span><br><span class="line">          <span class="comment">// 拿不到锁直接执行 else</span></span><br><span class="line">          <span class="keyword">if</span> m.TryLock() &#123;</span><br><span class="line">             fmt.Printf(<span class="string">&quot;%d get lock\n&quot;</span>, i)</span><br><span class="line">             time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">             m.Unlock()</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             fmt.Printf(<span class="string">&quot;%d not get lock\n&quot;</span>, i)</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutex-实现"><a href="#Mutex-实现" class="headerlink" title="Mutex 实现"></a>Mutex 实现</h2><p>上节说到，Lock() 方法会一直阻塞，直到上一个 goroutine 释放资源。如果有多个 goroutine 同时等待释放临界区资源，那谁会先获得资源？goroutine 阻塞期间是否会持续占用 cpu 资源？这一切都需要看 Mutex 的具体实现。</p><p>整体来说，go 中的 mutex 的演进共经历了四个阶段。</p><p><img src="/hexo-blog/img/note/go%E4%B8%AD%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%92%E6%96%A5%E9%94%81Mutex/image-20240616025057015.png" alt="image-20240616025057015"></p><h3 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h3><p>在第一版实现中，Mutex 共有两个字段组成。key: 标识锁是否被持有，值 0 表示锁处于空闲状态，值 1 表示锁被持有且没有等待者，值 n「n&gt;1」表示有 n-1 个 goroutine 等待获取锁。sema 等待者队列使用的信号量，用于阻塞和唤醒 goroutine，后面会详细介绍信号量。</p><p>Lock()：获取锁，执行原子操作「+1」；如果原子操作返回的结果为 1 则抢锁成功；如果原子操作返回的结果不为 1 则表示已经有其他 goroutine 抢锁成功，则调用 semacquire() 让当前的 goroutine 进入等待状态。</p><p>Unlock(): 释放锁，执行原子操作「-1」；如果原子操作返回结果为 0 则没有其他等待者，直接返回；否则即有其他 goroutine 在阻塞等待锁释放，调用 semrelease() 唤醒阻塞的 goroutine。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CAS操作，当时还没有抽象出atomic包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cas</span><span class="params">(val *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semacquire</span><span class="params">(*<span class="type">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease</span><span class="params">(*<span class="type">int32</span>)</span></span></span><br><span class="line"><span class="comment">// 互斥锁的结构，包含两个字段</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  <span class="type">int32</span> <span class="comment">// 锁是否被持有的标识</span></span><br><span class="line">    sema <span class="type">int32</span> <span class="comment">// 信号量专用，用以阻塞/唤醒goroutine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证成功在val上增加delta的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xadd</span><span class="params">(val *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v := *val</span><br><span class="line">        <span class="keyword">if</span> cas(val, v, v+delta) &#123;</span><br><span class="line">            <span class="keyword">return</span> v + delta</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unreached&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">1</span>) == <span class="number">1</span> &#123; <span class="comment">//标识加1，如果等于1，成功获取到锁</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    semacquire(&amp;m.sema) <span class="comment">// 否则阻塞等待，当信号量大于 0 时，信号量 -1， return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">-1</span>) == <span class="number">0</span> &#123; <span class="comment">// 将标识减去1，如果等于0，则没有其它等待者</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    semrelease(&amp;m.sema) <span class="comment">// 唤醒其它阻塞的goroutine,信号量 +1</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="给新人机会"><a href="#给新人机会" class="headerlink" title="给新人机会"></a>给新人机会</h3><p>在初版 Mutex 实现中，如果锁已经被持有，后续的 Lock 操作将会让 goroutine 阻塞。goroutine 的阻塞和唤醒是利用信号量来实现，采用的是先进先出的机制。也就是先被阻塞 goroutine 最先被唤醒。然而，在高并发场景，将阻塞的 goroutine 唤醒涉及一定的资源开销。那有没有方法让正在运行的 goroutine 优先获取锁，从而避免将正在运行的 gorotine 切换到阻塞状态造成额外开销。</p><p>Go 开发者在 2011 年 6 月 30 日的 commit 中对 Mutex 做了一次大的调整，调整后的 Mutex 实现如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">    mutexWoken</span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这个版本中，state 一个字段表示了三个数据，第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的 goroutine，剩余的位数代表的是等待此锁的 goroutine 数。</p><p><img src="/hexo-blog/img/note/go%E4%B8%AD%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%92%E6%96%A5%E9%94%81Mutex/image-20240616024950007.png" alt="image-20240616024950007"></p><p>下面看一下 Lock 方法。如果 state 为零，表示锁处于空闲状态，通过 CAS 操作设置为持有锁，成功直接返回。如果锁已经被持有，在需要通过 for 循环不断检查是否可以获取锁。和初版的区别在于，初版直接通过 semacquire 进入阻塞等待。在这个版本中，新创建的 goroutine 和被唤醒的 goroutine 同时抢锁。从而有一定的几率让正在运行的 goroutine 直接获取到锁，而不用进入阻塞等待。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// Fast path: 幸运case，能够直接获取到锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建的 goroutine 抢锁</span></span><br><span class="line">    awoke := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// 新建的 goroutine 和唤醒的 goroutine 同时抢锁</span></span><br><span class="line">        old := m.state <span class="comment">// 获取 state</span></span><br><span class="line">        <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态加锁</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> &#123;<span class="comment">// 旧状态为锁已经被持有</span></span><br><span class="line">            <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift <span class="comment">//等待者数量加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="comment">// goroutine是被唤醒的，</span></span><br><span class="line">            <span class="comment">// 新状态清除唤醒标志</span></span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原子操作，保证在此次操作之间没有其他 goroutine 更改状态</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;<span class="comment">//设置新状态</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">// 锁原状态未加锁，抢锁成功</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            runtime.Semacquire(&amp;m.sema) <span class="comment">// 请求信号量，进入阻塞等待</span></span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 Unlock 方法。通过 -1 来去掉锁标志，这里是因为 state 的其他位置的数据是不确定的，所以只能通过 -1 来去掉锁标记。如果本来就没有加锁，调用 Unlock 会直接 panic。除了将锁标记位置位 0 之外，还需要唤醒阻塞的 goroutine 并设置唤醒标记位。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked) <span class="comment">//去掉锁标志</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">//本来就没有加锁</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    old := <span class="built_in">new</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> &#123; <span class="comment">// 没有等待者，或者有唤醒的waiter，或者锁原来已加锁</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken <span class="comment">// 新状态，准备唤醒goroutine，并设置唤醒标志</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            runtime.Semrelease(&amp;m.sema)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        old = m.state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多给些机会"><a href="#多给些机会" class="headerlink" title="多给些机会"></a>多给些机会</h3><p>在 2015 年 2 月的改动中，如果新来的 goroutine 或者是被唤醒的 goroutine 首次获取不到锁，它们就会通过自旋（spin，通过循环不断尝试，spin 的逻辑是在runtime 实现的）的方式，尝试检查锁是否被释放。在尝试一定的自旋次数后，再执行原来的逻辑。</p><p>因为临界区的代码耗时很短，锁很快就能释放，而抢夺锁的 goroutine 不用通过休眠唤醒方式等待调度，直接 spin 几次，可能就获得了锁。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// Fast path: 幸运之路，正好获取到锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    awoke := <span class="literal">false</span></span><br><span class="line">    iter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁</span></span><br><span class="line">        old := m.state <span class="comment">// 先保存当前锁的状态</span></span><br><span class="line">        <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态设置加锁标志</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> &#123; <span class="comment">// 锁还没被释放</span></span><br><span class="line">            <span class="keyword">if</span> runtime_canSpin(iter) &#123; <span class="comment">// 还可以自旋</span></span><br><span class="line">                <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                    awoke = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                runtime_doSpin()</span><br><span class="line">                iter++</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">// 自旋，再次尝试请求锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> awoke &#123; <span class="comment">// 唤醒状态</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">// 旧状态锁已释放，新状态成功持有了锁，直接返回</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            runtime_Semacquire(&amp;m.sema) <span class="comment">// 阻塞等待</span></span><br><span class="line">            awoke = <span class="literal">true</span> <span class="comment">// 被唤醒</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决饥饿"><a href="#解决饥饿" class="headerlink" title="解决饥饿"></a>解决饥饿</h3><p>在 go 的 Mutex 设计中，既要考虑锁的性能，又要考虑锁的公平性。在上面的版本中，可能会导致阻塞队列中的 goroutine 一致获取不到锁，也就是饥饿问题。</p><p>2016 年 Go 1.9 中 Mutex 增加了饥饿模式，让锁变得更公平，不公平的等待时间限制在 1 毫秒，并且修复了一个大 Bug：总是把唤醒的 goroutine 放在等待队列的尾部，会导致更加不公平的等待时间。这里就不对源码进行分析了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">    mutexWoken</span><br><span class="line">    mutexStarving <span class="comment">// 从state字段中分出一个饥饿标记</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// Fast path: 幸运之路，一下就获取到了锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争</span></span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">    starving := <span class="literal">false</span> <span class="comment">// 此goroutine的饥饿标记</span></span><br><span class="line">    awoke := <span class="literal">false</span> <span class="comment">// 唤醒标记</span></span><br><span class="line">    iter := <span class="number">0</span> <span class="comment">// 自旋次数</span></span><br><span class="line">    old := m.state <span class="comment">// 当前的锁的状态</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 锁是非饥饿状态，锁还没被释放，尝试自旋</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            iter++</span><br><span class="line">            old = m.state <span class="comment">// 再次获取锁的状态，之后会检查是否锁被释放了</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked <span class="comment">// 非饥饿状态，加锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift <span class="comment">// waiter数量加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving <span class="comment">// 设置饥饿状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功设置新状态</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理饥饿状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果以前就在队列里面，加入到队列头</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 唤醒之后检查锁是否应该处于饥饿状态</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">// 如果锁已经处于饥饿状态，直接抢到锁，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有点绕，加锁并且将waiter数减1</span></span><br><span class="line">                delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                    delta -= mutexStarving <span class="comment">// 最后一个waiter或者已经不饥饿了，清除饥饿标记</span></span><br><span class="line">                &#125;</span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">        m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，为了同时保证锁的性能和公平性。Mutex 一共经历了四次大的变更。第一次是最简单的实现，goroutine 按照队列的形式抢锁，如果不能获取到锁则需要进入阻塞队列。由于正在运行的 goroutine 有更多的本地缓存，执行速度快。因此，在第二次版本中让新创建的 goroutine 和唤醒的 goroutine 同时抢锁。在第三次变更中，引入自旋操作，让正在运行的 goroutine 有更多的机会获取锁。然后，正在运行的 goroutine 获取锁的几率越大，意味着阻塞的 goroutine 会一致在等待。为了保证锁的公平性，对于等待时长大于 1ms，优先让等待者获取锁。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>Mutex 对使用者屏蔽了复杂的实现细节，只暴露了 Lock() 和 Unlcok() 方法。然后，在具体使用的过程中也需要注意以下问题。</p><h3 id="Lock-Unlcok-不是成对出现"><a href="#Lock-Unlcok-不是成对出现" class="headerlink" title="Lock &#x2F; Unlcok 不是成对出现"></a>Lock &#x2F; Unlcok 不是成对出现</h3><p>最常见的问题就是 Lock 和 Unlock 没有成对的出现。这就会导致互斥锁无法释放&#x2F;重复释放导致程序异常。例如下面的例子，忘记写 Unlock，程序运行时会检测出死锁。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          <span class="keyword">defer</span> wg.Done()</span><br><span class="line">          m.Lock()</span><br><span class="line">          sum++</span><br><span class="line">          <span class="comment">//m.Unlock()</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//goroutine 1 [semacquire]:</span></span><br><span class="line"><span class="comment">//sync.runtime_Semacquire(0x140000021a0?)</span></span><br><span class="line"><span class="comment">//        /Users/bytedance/go/go1.21.4/src/runtime/sema.go:62 +0x2c</span></span><br><span class="line"><span class="comment">//sync.(*WaitGroup).Wait(0x1400009c030)</span></span><br><span class="line"><span class="comment">//        /Users/bytedance/go/go1.21.4/src/sync/waitgroup.go:116 +0x74</span></span><br><span class="line"><span class="comment">//main.main()</span></span><br><span class="line"><span class="comment">//        /Users/bytedance/Desktop/code/tetris/demo/c1/d.go:33 +0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//goroutine 19 [sync.Mutex.Lock]:</span></span><br><span class="line"><span class="comment">//sync.runtime_SemacquireMutex(0x0?, 0x0?, 0x0?)</span></span><br><span class="line"><span class="comment">//        /Users/bytedance/go/go1.21.4/src/runtime/sema.go:77 +0x28</span></span><br><span class="line"><span class="comment">//sync.(*Mutex).lockSlow(0x1400009c020)</span></span><br><span class="line"><span class="comment">//        /Users/bytedance/go/go1.21.4/src/sync/mutex.go:171 +0x174</span></span><br><span class="line"><span class="comment">//sync.(*Mutex).Lock(...)</span></span><br><span class="line"><span class="comment">//        /Users/bytedance/go/go1.21.4/src/sync/mutex.go:90</span></span><br><span class="line"><span class="comment">//main.main.func1()</span></span><br><span class="line"><span class="comment">//        /Users/bytedance/Desktop/code/tetris/demo/c1/d.go:27 +0xac</span></span><br><span class="line"><span class="comment">//created by main.main in goroutine 1</span></span><br><span class="line"><span class="comment">//        /Users/bytedance/Desktop/code/tetris/demo/c1/d.go:25 +0x60</span></span><br><span class="line"><span class="comment">//exit status 2</span></span><br></pre></td></tr></table></figure><p>如果重复进行 Unlock 则直接 panic，在分析源码的时候就已经看到了 panic 代码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          <span class="keyword">defer</span> wg.Done()</span><br><span class="line">          m.Lock()</span><br><span class="line">          sum++</span><br><span class="line">          m.Unlock()</span><br><span class="line">          <span class="comment">// fatal error: sync: unlock of unlocked mutex</span></span><br><span class="line">          m.Unlock()</span><br><span class="line">       &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Copy-已经使用-Mutex"><a href="#Copy-已经使用-Mutex" class="headerlink" title="Copy 已经使用 Mutex"></a>Copy 已经使用 Mutex</h3><p>通过 Mutex 的源码分析得知，互斥锁的实现是依赖 Mutex 变量的内部状态「state 和 sema」控制的。这就表示在使用 Mutex 时，在多个 goroutine 中只能使用同一个 Mutex 变量，而不能使用变量的值拷贝。</p><p>在下面的例子中，在对 sum++ 加锁时使用的是 Mutex 变量的值 copy 而导致锁逻辑失败。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(m sync.Mutex)</span></span> &#123;</span><br><span class="line">          <span class="keyword">defer</span> wg.Done()</span><br><span class="line">          m.Lock()</span><br><span class="line">          sum++</span><br><span class="line">          m.Unlock()</span><br><span class="line">       &#125;(m)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么最直接的修复方法就是传递一个指针，不同的 goroutine 使用是同一个 Mutex。或者使用闭包的形式，直接访问匿名函数的外部变量 m。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(m *sync.Mutex)</span></span> &#123;</span><br><span class="line">          <span class="keyword">defer</span> wg.Done()</span><br><span class="line">          m.Lock()</span><br><span class="line">          sum++</span><br><span class="line">          m.Unlock()</span><br><span class="line">       &#125;(&amp;m)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，go 提供了 vet 工具，可以帮助我们检查程序中 copy Mutex 的问题。运行 <code>go vet d.go</code>，会直接告诉我们函数在传递 Mutex 时，使用了一个值，而不是指针。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># command-<span class="keyword">line</span>-arguments</span></span><br><span class="line">./d.go:<span class="number">24</span>:<span class="number">5</span>: <span class="function">call of <span class="title">func</span>(<span class="params">m sync.Mutex</span>)</span> &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        m.Lock()</span><br><span class="line">        sum++</span><br><span class="line">        m.Unlock()</span><br><span class="line">&#125; copies <span class="keyword">lock</span> <span class="keyword">value</span>: sync.Mutex</span><br><span class="line">./d.go:<span class="number">19</span>:<span class="number">13</span>: func passes <span class="keyword">lock</span> <span class="keyword">by</span> <span class="keyword">value</span>: sync.Mutex</span><br></pre></td></tr></table></figure><p><code>go vet</code> 是 Go 语言的一个静态分析工具，它可以检查 Go 语言源码中可能存在的错误，这些错误通常是编译器无法检查出来的。不仅可以检查语法错误，更重要的是可以检查出一些逻辑错误，比如常见的变量未使用、函数调用参数个数及类型错误、格式化字符串与参数不匹配、可能的空指针解引用等问题。可以通过 <code>go vet ./...</code> 命令运行 <code>vet</code> 检查当前目录及其子目录下的所有 Go 文件。</p><h3 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h3><p>可重入锁，又称为递归锁，是指在同一个线程内，外层函数获得锁之后，内层递归函数仍然有获取该锁的权限，这避免了递归调用时的死锁现象。</p><p>在一些多线程的编程环境中，可重入锁是必要的，因为它可以避免一个线程在获取了一个已经由它自己持有的锁时产生死锁。例如，一个线程在调用某个需要获取锁的函数后，由于某些原因（如满足某个条件或者发生了异常等），需要再次调用这个函数，如果这个锁是不可重入的，那么这个线程就会阻塞，等待它自己释放这个锁，这显然是不可能的，结果就会导致死锁。</p><p>而可重入锁在这种情况下就可以避免死锁，因为它允许一个线程多次获取同一把锁。不过，每获取一次，锁的计数器就会增加一次，只有当计数器的值降为0时，其他线程才能获取该锁。</p><p>需要注意的是，虽然可重入锁解决了上述问题，但是也带来了一些新的问题，比如可能会导致一个线程长时间持有锁，从而降低系统的并发性能。</p><p>毫无疑问，Mutex 是不可重入锁。它本身并没有存储 goroutine 的任何信息，更别说支持可重入了。</p><h2 id="功能扩展"><a href="#功能扩展" class="headerlink" title="功能扩展"></a>功能扩展</h2><p>原生的 Mutex 体现了 go 的设计哲学：大道至简。只提供 Lock 和 Unlock 方法，极大的降低了使用者的学习成本。对于一些否则的功能则需要开发者自己去实现。这里将实现可重入锁和并发安全的队列，来巩固学习 Mutex。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁实现的关键是在 Mutex 中保存 goroutine 信息，用于区分不同的 goroutine，从而实现可重入的能力。在具体实现时，有两种方案，一种是通过 hack 的方式获取 goroutine id；另一种就是调用 Lock 和 Unlock 显性的传入一个 token，用于标识不同的 goroutine。这里使用第一种方式实现一个可重入锁。</p><p>封装一个 struct RecursiveMutex，里面包含一个互斥锁 Mutex 用于不同 goroutine 获取锁；owner 记录获取锁的 goroutine 的信息；rec 记录重入的次数。这里需要注意的是，对于 owner 的操作是不同 goroutine 的并发读写，因此需要使用原子操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// RecursiveMutex 可重入锁</span></span><br><span class="line"><span class="keyword">type</span> RecursiveMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    owner <span class="type">int64</span> <span class="comment">// 持有锁的 goroutine id</span></span><br><span class="line">    rec   <span class="type">int32</span> <span class="comment">// 重入次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rm *RecursiveMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// goroutine 重复获取锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadInt64(&amp;rm.owner) == goid.Get() &#123;</span><br><span class="line">       <span class="comment">// 增加重入次数，只有持有锁的 goroutine 才会写 rec, 不需要进行原子操作</span></span><br><span class="line">       rm.rec++</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// goroutine 第一次获取锁，设置 owner 和 rec</span></span><br><span class="line">    rm.Mutex.Lock()</span><br><span class="line">    atomic.StoreInt64(&amp;rm.owner, goid.Get())</span><br><span class="line">    rm.rec = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rm *RecursiveMutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadInt64(&amp;rm.owner) == goid.Get() &#123;</span><br><span class="line">       <span class="comment">// 先减少重入次数</span></span><br><span class="line">       rm.rec--</span><br><span class="line">       <span class="keyword">if</span> rm.rec != <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 可重入锁全部释放，重置 owner</span></span><br><span class="line">       atomic.StoreInt64(&amp;rm.owner, <span class="number">-1</span>)</span><br><span class="line">       rm.Mutex.Unlock()</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非持有 mutex 的 goroutine 释放锁</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;wrong owner&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rl := RecursiveMutex&#123;&#125;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    signal := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 第一个 goroutine 重复获取锁</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">defer</span> wg.Done()</span><br><span class="line">       rl.Lock()</span><br><span class="line">       signal &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">       fmt.Println(<span class="string">&quot;goroutine 1 get lock with rec = &quot;</span>, rl.rec)</span><br><span class="line">       rl.Lock()</span><br><span class="line">       fmt.Println(<span class="string">&quot;goroutine 1 get lock with rec = &quot;</span>, rl.rec)</span><br><span class="line">       rl.Unlock()</span><br><span class="line">       rl.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">defer</span> wg.Done()</span><br><span class="line">       &lt;-signal</span><br><span class="line">       rl.Lock()</span><br><span class="line">       fmt.Println(<span class="string">&quot;goroutine 2 get lock with rec = &quot;</span>, rl.rec)</span><br><span class="line">       rl.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发安全的队列"><a href="#并发安全的队列" class="headerlink" title="并发安全的队列"></a>并发安全的队列</h3><p>在 go 的源码中，并没有提供并发安全的队列。我们可以基于 Mutex 实现一个并发安全的队列。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncQueue[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []T</span><br><span class="line">    m    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSyncQueue</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(<span class="built_in">cap</span> <span class="type">int</span>)</span></span> *SyncQueue[T] &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SyncQueue[T]&#123;</span><br><span class="line">       data: <span class="built_in">make</span>([]T, <span class="number">0</span>, <span class="built_in">cap</span>),</span><br><span class="line">       m:    sync.Mutex&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *SyncQueue[T])</span></span> Enqueue(v T) &#123;</span><br><span class="line">    q.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.m.Unlock()</span><br><span class="line">    q.data = <span class="built_in">append</span>(q.data, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *SyncQueue[T])</span></span> Dequeue() *T &#123;</span><br><span class="line">    q.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q.data) == <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    r := q.data[<span class="number">0</span>]</span><br><span class="line">    q.data = q.data[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> &amp;r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q := NewSyncQueue[<span class="type">int</span>](<span class="number">10</span>)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">          <span class="keyword">defer</span> wg.Done()</span><br><span class="line">          q.Enqueue(i)</span><br><span class="line">       &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       fmt.Println(*q.Dequeue())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程复习</title>
      <link href="/hexo-blog/2024/06/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
      <url>/hexo-blog/2024/06/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程复习"><a href="#软件工程复习" class="headerlink" title="软件工程复习"></a>软件工程复习</h1><p><img src="/hexo-blog/img/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/1.jpg"></p><p><img src="/hexo-blog/img/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/2.jpg" alt="2"></p><p><img src="/hexo-blog/img/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/3.jpg" alt="3"></p><p><img src="/hexo-blog/img/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/4.jpg" alt="4"></p><p><img src="/hexo-blog/img/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/5.jpg" alt="5"></p><p><img src="/hexo-blog/img/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/6.jpg" alt="6"></p><p><img src="/hexo-blog/img/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/7.jpg" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaweb考试</title>
      <link href="/hexo-blog/2024/06/13/javaweb%E8%80%83%E8%AF%95/"/>
      <url>/hexo-blog/2024/06/13/javaweb%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="（1）MVC模式的详细说明及MyShop实例分析"><a href="#（1）MVC模式的详细说明及MyShop实例分析" class="headerlink" title="（1）MVC模式的详细说明及MyShop实例分析"></a>（1）MVC模式的详细说明及MyShop实例分析</h3><p><strong>MVC模式概述：</strong><br>     MVC（Model-View-Controller）是一种软件架构设计模式，将应用程序划分为三个核心组件：</p><ul><li><p><strong>Model（模型）</strong>：负责封装数据和业务逻辑，如数据库操作、计算等，它是应用程序的核心，独立于用户界面。</p></li><li><p><strong>View（视图）</strong>：负责展示数据给用户，它从模型获取数据并格式化输出，但不包含业务逻辑。</p></li><li><p><strong>Controller（控制器）</strong>：接收用户输入并调用模型和视图去完成用户请求，起到中间人的角色。</p><p><img src="/hexo-blog/./img/note/javaweb%E8%80%83%E8%AF%95/7e498763c1af4882952a82b5b0bc6ca1tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="传统MVC"></p></li></ul><h4 id="Model（模型）"><a href="#Model（模型）" class="headerlink" title="Model（模型）"></a>Model（模型）</h4><p><strong>模型层</strong>主要负责数据处理和业务逻辑。</p><ul><li><strong>GoodsSingle.java</strong>：这是模型层的一部分，代表了商品单品的数据结构，包括商品的ID、名称、图片名、数量和价格等属性，以及它们的getter和setter方法。此外，还定义了特殊的方法如<code>toString()</code>和特定构造方法来处理数据的转换和初始化，这些都属于模型层的职责。</li><li><strong>ShopCar.java</strong>：同样属于模型层，负责维护购物车的状态，包括添加商品、移除商品、更新商品数量和清空购物车等操作。<code>ArrayList&lt;GoodsSingle&gt; buylist</code>用来存储购物车中的商品，而<code>addItem</code>, <code>removeItem</code>, <code>clearCar</code>等方法则是对购物车数据进行操作的业务逻辑。</li><li><strong>MyTools.java</strong>：包含了一些静态方法，用于数据的读取、保存和处理，比如从预设数据生成商品列表、保存商品信息到本地、从本地加载商品信息等。这些方法体现了模型层对于数据持久化和数据准备的处理能力。</li></ul><h4 id="View（视图）"><a href="#View（视图）" class="headerlink" title="View（视图）"></a>View（视图）</h4><p><strong>视图层</strong>负责用户界面的展示，即用户看到并与之交互的部分。</p><ul><li><strong>show.jsp</strong>：展示商品列表的页面，属于视图层，它接收模型层（如通过<code>application.getAttribute(&quot;goodslist&quot;)</code>）传递过来的商品数据，并以适合用户查看的方式展现，同时提供购买链接，引导用户进行操作。</li><li><strong>shopcar.jsp</strong>：显示购物车详情的页面，也是视图层的一部分，它展示了购物车中的商品名称、数量、单价和总价等信息，并提供了继续购物和清空购物车的功能按钮。</li><li><strong>littleShopcar.jsp</strong>：这是一个简化版的购物车视图，仅展示购物车中商品的名称和图片，用于快速概览购物车内容，同样属于视图层。</li></ul><h4 id="Controller（控制器）"><a href="#Controller（控制器）" class="headerlink" title="Controller（控制器）"></a>Controller（控制器）</h4><p><strong>控制器层</strong>负责接收用户的输入，处理用户请求，并将处理结果转发给模型和视图。</p><ul><li><strong>虽然没有直接列出具体的Java控制器类（如在Spring MVC或Struts框架中常见的Controller类），但从描述中可以推测</strong>：<code>docar.jsp</code>承担了一定程度上的控制器角色。在传统的JSP模式下，JSP页面本身可能混合了视图和控制器的逻辑，通过脚本let（如<code>&lt;% %&gt;</code>）来处理请求参数（例如<code>request.getParameter(&quot;action&quot;)</code>），根据不同的用户动作（如“购买商品”、“移除商品”、“清空购物车”）执行相应的业务逻辑，这实际上就是在扮演控制器的角色。它负责解析用户的请求，调用模型层的方法处理数据，并最终决定返回哪个视图给用户。</li></ul><h3 id="（2）转发与重定向的详细区别及应用场景"><a href="#（2）转发与重定向的详细区别及应用场景" class="headerlink" title="（2）转发与重定向的详细区别及应用场景"></a>（2）转发与重定向的详细区别及应用场景</h3><p><strong>转发（Forward）：</strong></p><ul><li><p><strong>服务器行为</strong>：转发发生在服务器端，当客户端发送请求后，服务器接收到请求并在服务器内部处理，决定将请求转发给另一个资源，整个过程中客户端并不知道这个过程。</p></li><li><p><strong>一次请求</strong>：对客户端而言，整个过程是一次请求，服务器处理完后直接将结果返回给客户端，因此效率较高。</p></li><li><p><strong>地址栏不变</strong>：浏览器的地址栏不会显示转发的目标地址，仍然是最初的请求URL。</p></li><li><p><strong>数据共享</strong>：由于是单次请求，请求对象（如HttpServletRequest）中的数据可以在转发过程中被传递，多个资源之间可以共享请求数据。</p></li><li><p><strong>限制在同一Web应用内</strong>：转发通常限于将请求转发给同一Web应用内的其他资源。</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;welcome.jsp&quot;</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">&quot;message&quot;</span> value=<span class="string">&quot;Hello from Index Page&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>重定向（Redirect）：</strong></p><ul><li><p><strong>客户端行为</strong>：重定向是由服务器向客户端发送一个状态码（通常是HTTP状态码302或301），指示客户端重新发起一个新请求到指定的URL。这意味着客户端需要再次发送请求。</p></li><li><p><strong>两次请求</strong>：整个过程涉及两次独立的HTTP请求，因此相对慢一些。</p></li><li><p><strong>地址栏改变</strong>：浏览器地址栏会显示重定向后的新URL。</p></li><li><p><strong>不保留请求数据</strong>：两次独立的请求意味着第一次请求的数据不会自动传递给第二次请求，因此不适用于需要共享数</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">  response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);</span><br><span class="line">  response.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;welcome.jsp&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>HttpServletResponse.SC_MOVED_PERMANENTLY</code>（301状态码，表示永久移动）</p><p><code>HttpServletResponse.SC_FOUND</code>（302状态码，临时重定向）</p></blockquote></li></ul><h3 id="（3）JSP中include指令与include动作的对比"><a href="#（3）JSP中include指令与include动作的对比" class="headerlink" title="（3）JSP中include指令与include动作的对比"></a>（3）JSP中include指令与include动作的对比</h3><h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令 (&lt;%@ include %&gt;)"></a>include指令 (<code>&lt;%@ include %&gt;</code>)</h4><ul><li><strong>类型</strong>：静态包含。</li><li><strong>时机</strong>：编译时，JSP页面转换为Servlet代码时执行。</li><li><strong>特点</strong>：包含页面的内容直接嵌入到主页面中，如同一个文件。<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">&quot;header.jsp&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><code>header.jsp</code>的内容会在编译阶段直接插入到当前JSP页面中，生成的Servlet代码中将包含这部分内容。</li></ul><h4 id="include动作"><a href="#include动作" class="headerlink" title="include动作 (&lt;jsp:include&gt;)"></a>include动作 (<code>&lt;jsp:include&gt;</code>)</h4><ul><li><strong>类型</strong>：动态包含。</li><li><strong>时机</strong>：运行时，当JSP页面被执行时。</li><li><strong>特点</strong>：每次请求时独立执行包含页面，可以传递参数。<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;menu.jsp&quot;</span>&gt;</span><br><span class="line">  &lt;jsp:param name=<span class="string">&quot;category&quot;</span> value=<span class="string">&quot;newArrivals&quot;</span> /&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><code>menu.jsp</code>在每次请求时都会被单独执行，而且可以通过<code>jsp:param</code>标签传递参数<code>category</code>到被包含页面。</li></ul><h3 id="（4）三层架构与MVC模式的详细对比"><a href="#（4）三层架构与MVC模式的详细对比" class="headerlink" title="（4）三层架构与MVC模式的详细对比"></a>（4）三层架构与MVC模式的详细对比</h3><h4 id="三层架构包含dao，service，controller"><a href="#三层架构包含dao，service，controller" class="headerlink" title="三层架构包含dao，service，controller"></a>三层架构包含dao，service，controller</h4><p><strong>控制层（Controller）</strong>：控制层位于架构的最前端，直接面对用户或外部请求。它负责接收用户的输入，并将请求转发给相应的服务层处理，最后返回处理结果给用户。控制层的主要任务是请求处理和数据转发，它不包含业务逻辑，确保了用户接口的轻量化。</p><p><strong>业务逻辑层（Service）</strong>：服务层是三层架构中的中心，承担着处理应用程序核心业务逻辑的任务。这一层解释用户的请求，执行必要的业务计算，调用数据访问层进行数据持久化操作，并返回执行结果。将业务逻辑封装在服务层中有助于保持业务处理的一致性和复用性。</p><p><strong>数据访问层（DAO）</strong>：数据访问层是与数据库或其他持久化存储方式直接交互的层次。DAO层的职责是执行具体的数据库操作，如增删查改（CRUD），并返回操作结果。通过抽象化数据访问，DAO层使得业务逻辑层与数据存储细节解耦，提高了系统的适应性和稳定性。</p><p><img src="/hexo-blog/./img/note/javaweb%E8%80%83%E8%AF%95/3426074a4dc44548bb471ffa571a070atplv-k3u1fbpfcp-jj-mark3024000q75.webp" alt="0_g2X2HxArvJCp3RQ0.png"></p><h4 id="与MVC模式的关系："><a href="#与MVC模式的关系：" class="headerlink" title="与MVC模式的关系："></a><strong>与MVC模式的关系：</strong></h4><p>MVC的View和Controller可以看作是三层架构中的表现层，而MVC的Model与三层架构的业务逻辑层和数据访问层相对应。MVC更侧重于界面的构建和用户交互，而三层架构侧重于逻辑分层和职责划分，两者结合可以构建出结构清晰、易于维护的大型应用系统。</p><blockquote><p>三层架构更适合大型应用，主要是将controller解耦合，只需在controller层调用service层的逻辑代码，service再调用dao数据访问层的代码，并且<strong>方便测试</strong>,</p><p>如果说所有逻辑代码都写在controller，会导致<strong>复用性降低</strong>，<strong>测试难度增加</strong>，<strong>扩展性受限</strong>，分层利于解耦，dao层函数复用</p><p>如果说这个是个小层应用，不需要太多的业务代码，只需要curd，使用mvc即可，否则全写在controller成容易造成<strong>代码冗余</strong></p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h4><p><img src="/hexo-blog/./img/note/javaweb%E8%80%83%E8%AF%95/image-20240613192032910.png" alt="image-20240613192032910"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openguass第一次实验</title>
      <link href="/hexo-blog/2024/06/12/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/"/>
      <url>/hexo-blog/2024/06/12/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="openguass第一次实验"><a href="#openguass第一次实验" class="headerlink" title="openguass第一次实验"></a>openguass第一次实验</h1><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517203830614.png" alt="image20240517203830614"></p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517203848163.png" alt="image20240517203848163"></p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517203940501.png" alt="image20240517203940501"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 社团表(</span><br><span class="line">    社团号 <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    名称 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    活动地点 <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 学生表(</span><br><span class="line">    学号 <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    姓名 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    性别 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    出生日期 <span class="type">char</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 参加社团表(</span><br><span class="line">    社团号 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    学号 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    加入时间 <span class="type">char</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(社团号,学号),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (学号) <span class="keyword">REFERENCES</span> 学生表(学号),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (社团号) <span class="keyword">REFERENCES</span> 社团表(社团号)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入社团表的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 社团表 (社团号, 名称, 活动地点) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;C001&#x27;</span>, <span class="string">&#x27;篮球社&#x27;</span>, <span class="string">&#x27;体育馆&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C002&#x27;</span>, <span class="string">&#x27;书法社&#x27;</span>, <span class="string">&#x27;艺术楼202&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C003&#x27;</span>, <span class="string">&#x27;编程社&#x27;</span>, <span class="string">&#x27;计算机房305&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C004&#x27;</span>, <span class="string">&#x27;音乐社&#x27;</span>, <span class="string">&#x27;音乐教室101&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C005&#x27;</span>, <span class="string">&#x27;摄影社&#x27;</span>, <span class="string">&#x27;摄影工作室501&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入学生表的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 学生表 (学号, 姓名, 性别, 出生日期) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;S001&#x27;</span>, <span class="string">&#x27;张伟&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;2001-05-12&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;S002&#x27;</span>, <span class="string">&#x27;李娜&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;2002-08-09&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;S003&#x27;</span>, <span class="string">&#x27;王强&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;2001-12-21&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;S004&#x27;</span>, <span class="string">&#x27;赵敏&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;2003-03-15&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;S005&#x27;</span>, <span class="string">&#x27;陈思&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;2002-11-30&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入参加社团表的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 参加社团表 (社团号, 学号, 加入时间) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;C001&#x27;</span>, <span class="string">&#x27;S001&#x27;</span>, <span class="string">&#x27;2023-09-01&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C001&#x27;</span>, <span class="string">&#x27;S003&#x27;</span>, <span class="string">&#x27;2023-09-05&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C002&#x27;</span>, <span class="string">&#x27;S002&#x27;</span>, <span class="string">&#x27;2023-09-03&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C003&#x27;</span>, <span class="string">&#x27;S004&#x27;</span>, <span class="string">&#x27;2023-09-07&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C004&#x27;</span>, <span class="string">&#x27;S005&#x27;</span>, <span class="string">&#x27;2023-09-10&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C005&#x27;</span>, <span class="string">&#x27;S001&#x27;</span>, <span class="string">&#x27;2023-09-12&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C003&#x27;</span>, <span class="string">&#x27;S003&#x27;</span>, <span class="string">&#x27;2023-09-15&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;C002&#x27;</span>, <span class="string">&#x27;S005&#x27;</span>, <span class="string">&#x27;2023-09-17&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517202502390.png" alt="image20240517202502390"></p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/1715931937588.png" alt="1715931937588"></p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517155006915.png" alt="image20240517155006915"></p><h3 id="p1"><a href="#p1" class="headerlink" title="p1"></a>p1</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> p1(</span><br><span class="line">    community_id    <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    student_id    <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">     SQL_STR <span class="type">VARCHAR</span>(<span class="number">100</span>);</span><br><span class="line">     join_date <span class="type">VARCHAR</span>(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    SQL_STR :<span class="operator">=</span> <span class="string">&#x27;SELECT 加入时间 FROM 参加社团表 WHERE 社团号 = $1 AND 学号 = $2;&#x27;</span>;</span><br><span class="line">    <span class="keyword">EXECUTE</span> IMMEDIATE SQL_STR <span class="keyword">INTO</span> join_date <span class="keyword">USING</span> community_id,student_id;</span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;加入时间: %&#x27;</span>, join_date;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> p1(<span class="string">&#x27;C001&#x27;</span>,<span class="string">&#x27;S003&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517202219418.png" alt="image20240517202219418"></p><h3 id="p2"><a href="#p2" class="headerlink" title="p2"></a>p2</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> p2(</span><br><span class="line">    community_id    <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">     SQL_STR <span class="type">VARCHAR</span>(<span class="number">100</span>);</span><br><span class="line">     person_num <span class="type">INTEGER</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    SQL_STR :<span class="operator">=</span> <span class="string">&#x27;SELECT count(*) FROM 参加社团表 WHERE 社团号 = $1&#x27;</span>;</span><br><span class="line">    <span class="keyword">EXECUTE</span> IMMEDIATE SQL_STR <span class="keyword">INTO</span> person_num <span class="keyword">USING</span> community_id;</span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;参加该社团人数: %&#x27;</span>, person_num;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> p2(<span class="string">&#x27;C002&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517202240826.png" alt="image20240517202240826"></p><h3 id="p3"><a href="#p3" class="headerlink" title="p3"></a>p3</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> p3(</span><br><span class="line">    <span class="keyword">IN</span> community_id <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    male_count <span class="type">INT</span> :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    female_count <span class="type">INT</span> :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">CURSOR</span> cursor_student(community_id <span class="type">CHAR</span>(<span class="number">10</span>)) <span class="keyword">is</span> </span><br><span class="line">        <span class="keyword">SELECT</span> s.性别</span><br><span class="line">        <span class="keyword">FROM</span> 参加社团表 c</span><br><span class="line">        <span class="keyword">JOIN</span> 学生表 s <span class="keyword">ON</span> c.学号 <span class="operator">=</span> s.学号</span><br><span class="line">        <span class="keyword">WHERE</span> c.社团号 <span class="operator">=</span> community_id;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 打开游标</span></span><br><span class="line">    <span class="keyword">OPEN</span> cursor_student(community_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 循环遍历游标结果集</span></span><br><span class="line">    LOOP</span><br><span class="line">        <span class="keyword">FETCH</span> cursor_student <span class="keyword">INTO</span> gender;</span><br><span class="line">        EXIT <span class="keyword">WHEN</span> <span class="keyword">NOT</span> FOUND;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 计算男生和女生人数</span></span><br><span class="line">        IF gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">            male_count :<span class="operator">=</span> male_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        ELSIF gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">            female_count :<span class="operator">=</span> female_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 关闭游标</span></span><br><span class="line">    <span class="keyword">CLOSE</span> cursor_student;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 显示结果</span></span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;社团号: %, 男生人数: %, 女生人数: %&#x27;</span>, community_id, male_count, female_count;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> p3(<span class="string">&#x27;C003&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517202305051.png" alt="image20240517202305051"></p><h3 id="p4"><a href="#p4" class="headerlink" title="p4"></a>p4</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> p4()</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    TYPE CURSOR_TYPE <span class="keyword">IS</span> <span class="keyword">REF</span> <span class="keyword">CURSOR</span>;    <span class="comment">--定义ref游标类型CURSOR_TYPE</span></span><br><span class="line">    C CURSOR_TYPE;</span><br><span class="line">     SQL_STR <span class="type">VARCHAR</span>(<span class="number">100</span>);</span><br><span class="line">     community_id <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line">     community_name <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    SQL_STR :<span class="operator">=</span> <span class="string">&#x27;SELECT 社团号,名称 FROM 社团表;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">OPEN</span> C <span class="keyword">FOR</span> SQL_STR;        <span class="comment">--绑定游标</span></span><br><span class="line">    LOOP                                    <span class="comment">--开启循环</span></span><br><span class="line">        <span class="keyword">FETCH</span> C <span class="keyword">INTO</span> community_id,community_name;            <span class="comment">--将结果赋值给变量join_date</span></span><br><span class="line">        EXIT <span class="keyword">WHEN</span> C<span class="operator">%</span>NOTFOUND;            <span class="comment">--如果查询结果为空则退出</span></span><br><span class="line">        RAISE NOTICE <span class="string">&#x27;社团号: %,名称: %&#x27;</span>, community_id,community_name;        <span class="comment">--将结果输入到屏幕上</span></span><br><span class="line">    <span class="keyword">END</span> LOOP;                                <span class="comment">--结束循环</span></span><br><span class="line">    <span class="keyword">CLOSE</span> C;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> p4();</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517202335626.png" alt="image20240517202335626"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openguass第三次实验</title>
      <link href="/hexo-blog/2024/06/12/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/"/>
      <url>/hexo-blog/2024/06/12/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="openguass第三次实验"><a href="#openguass第三次实验" class="headerlink" title="openguass第三次实验"></a>openguass第三次实验</h1><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517203830614.png" alt="image20240517203830614"></p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517203848163.png" alt="image20240517203848163"></p><h2 id="作业四"><a href="#作业四" class="headerlink" title="作业四"></a>作业四</h2><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612231618046.png" alt="image-20240612231618046"></p><h3 id="第一步：创建视图或策略"><a href="#第一步：创建视图或策略" class="headerlink" title="第一步：创建视图或策略"></a>第一步：创建视图或策略</h3><p>由于OpenGauss不直接支持动态参数的行级安全策略，我们可以创建一个视图，该视图仅展示给定教师所在学院的学生的成绩信息。这需要预先知道每位老师的学院信息，并基于此信息构建视图。</p><p>创建一张<code>teachers</code>表记录教师信息，包含字段<code>teacher_name</code>和<code>college</code>，以及一张<code>grades</code>表记录成绩信息，包含字段<code>student_college</code>, <code>score</code></p><h4 id="创建一个视图限制访问"><a href="#创建一个视图限制访问" class="headerlink" title="创建一个视图限制访问"></a>创建一个视图限制访问</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> grades_view_for_teacher <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> g.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> grades g</span><br><span class="line"><span class="keyword">JOIN</span> teachers t <span class="keyword">ON</span> g.student_college <span class="operator">=</span> t.college</span><br><span class="line"><span class="keyword">WHERE</span> t.teacher_name <span class="operator">=</span> <span class="string">&#x27;Mary&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="第二步：以老师Mary身份操作"><a href="#第二步：以老师Mary身份操作" class="headerlink" title="第二步：以老师Mary身份操作"></a>第二步：以老师Mary身份操作</h3><p>在OpenGauss中，通常通过角色和权限来管理用户的访问权限，而不是直接在SQL查询中使用<code>set_config</code>函数来动态改变查询上下文。因此，如果希望老师Mary只能看到自己学院学生的成绩，你需要确保Mary角色对上述视图有查询权限，而不是直接对原始成绩表有权限。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> grades_view_for_teacher <span class="keyword">TO</span> Mary;</span><br></pre></td></tr></table></figure><p>然后，Mary登录后可以直接查询这个视图：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">gsql <span class="operator">-</span>d Club <span class="operator">-</span>U Mary <span class="operator">-</span>c &quot;SELECT * FROM grades_view_for_teacher;&quot;</span><br></pre></td></tr></table></figure><h2 id="作业五"><a href="#作业五" class="headerlink" title="作业五"></a>作业五</h2><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612215803660.png" alt="image-20240612215803660"></p><h3 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h3><ol><li><p><strong>进入数据库命令行</strong>:<br>假设您已经通过某种方式直接进入了数据库命令行界面，直接开始操作即可。</p></li><li><p><strong>创建Club数据库和Student表</strong>:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE Club;</span><br><span class="line">\c Club</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student (</span><br><span class="line">    student_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612220158537.png" alt="image-20240612220158537"></p><h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><p>备份操作需要通过Docker容器的命令行而非直接在数据库交互模式下执行。您可能需要先退出数据库交互模式回到容器的shell环境。备份文件将首先存储在容器内部，然后手动复制到宿主机的指定位置。</p><h4 id="1-逻辑备份整个Club数据库"><a href="#1-逻辑备份整个Club数据库" class="headerlink" title="(1) 逻辑备份整个Club数据库"></a>(1) 逻辑备份整个Club数据库</h4><p>执行备份命令。备份到容器内的临时位置，&#x2F;tmp&#x2F;club_database.sql&#96;：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gs_dump club -F c -f /tmp/club_database.sql</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612224524795.png" alt="image-20240612224524795"></p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612224601594.png" alt="image-20240612224601594"></p><h4 id="2-逻辑备份Student表"><a href="#2-逻辑备份Student表" class="headerlink" title="(2) 逻辑备份Student表"></a>(2) 逻辑备份Student表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gs_dump club -t Student -F c -f /tmp/student.dump</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612224658953.png" alt="image-20240612224658953"></p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612224824459.png" alt="image-20240612224824459"></p><h4 id="3-逻辑备份整个OpenGauss数据库的操作"><a href="#3-逻辑备份整个OpenGauss数据库的操作" class="headerlink" title="(3) 逻辑备份整个OpenGauss数据库的操作"></a>(3) 逻辑备份整个OpenGauss数据库的操作</h4><h3 id="将备份文件从容器复制到宿主机"><a href="#将备份文件从容器复制到宿主机" class="headerlink" title="将备份文件从容器复制到宿主机"></a>将备份文件从容器复制到宿主机</h3><p>执行完备份后，使用<code>docker cp</code>命令将备份文件从容器复制到宿主机指定目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 097bbf2d385bde771643f315eb7b4b32860a5049a94fd16a3490ac15cd916334:/tmp/club_backup /home/omm/logical/eam</span><br><span class="line">docker <span class="built_in">cp</span> 097bbf2d385bde771643f315eb7b4b32860a5049a94fd16a3490ac15cd916334:/tmp/student.dump /home/omm/logical/</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612225302423.png" alt="image-20240612225302423"></p><p><strong>宿主机中的备份数据库文件</strong></p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612225600344.png" alt="image-20240612225600344"></p><h3 id="删除与恢复操作"><a href="#删除与恢复操作" class="headerlink" title="删除与恢复操作"></a>删除与恢复操作</h3><h4 id="4-删除并恢复Club数据库"><a href="#4-删除并恢复Club数据库" class="headerlink" title="(4) 删除并恢复Club数据库"></a>(4) 删除并恢复Club数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsql -d postgres -c <span class="string">&quot;DROP DATABASE Club;&quot;</span></span><br><span class="line">gs_restore -d postgres /tmp/club_database.sql</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612230006101.png" alt="image-20240612230006101"></p><h4 id="5-删除并恢复Student表"><a href="#5-删除并恢复Student表" class="headerlink" title="(5) 删除并恢复Student表"></a>(5) 删除并恢复Student表</h4><p>先回到Club数据库，删除表，然后恢复：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\c Club</span><br><span class="line">DROP TABLE IF EXISTS Student;</span><br><span class="line">gs_restore -d Club /home/omm/logical/student.dump</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612230856758.png" alt="image-20240612230856758"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openguass第二次实验</title>
      <link href="/hexo-blog/2024/06/12/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/"/>
      <url>/hexo-blog/2024/06/12/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="openguass第二次实验"><a href="#openguass第二次实验" class="headerlink" title="openguass第二次实验"></a>openguass第二次实验</h1><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517203830614.png" alt="image20240517203830614"></p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240517203848163.png" alt="image20240517203848163"></p><h2 id="作业三"><a href="#作业三" class="headerlink" title="作业三"></a>作业三</h2><h2 id="实验一、"><a href="#实验一、" class="headerlink" title="实验一、"></a>实验一、</h2><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/wps1.jpg" alt="img"></p><h3 id="1-建立表Stu-Union并设置主键约束"><a href="#1-建立表Stu-Union并设置主键约束" class="headerlink" title="(1) 建立表Stu_Union并设置主键约束"></a>(1) 建立表<code>Stu_Union</code>并设置主键约束</h3><p>首先，我们需要在<code>schoo</code>l数据库中创建一个名为<code>Stu_Union</code>的表，并为它定义一个主键约束以确保实体完整性。这里我们假设<code>StuID</code>作为主键。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Stu_Union (</span><br><span class="line">    StuID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    Age <span class="type">INT</span>,</span><br><span class="line">    Major <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612210309552.png" alt="image-20240612210309552"></p><p>接着，插入一条记录，确保不违反实体完整性（即主键<code>StuID</code>不能重复）：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union (StuID, Name, Age, Major) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;计算机科学&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612210346359.png" alt="image-20240612210346359"></p><p>更新这条记录也是允许的，只要不改变主键值：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Stu_Union <span class="keyword">SET</span> Age <span class="operator">=</span> <span class="number">21</span> <span class="keyword">WHERE</span> StuID <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612210507681.png" alt="image-20240612210507681"></p><h3 id="2-演示违反实体完整性的插入操作"><a href="#2-演示违反实体完整性的插入操作" class="headerlink" title="(2) 演示违反实体完整性的插入操作"></a>(2) 演示违反实体完整性的插入操作</h3><p>尝试插入一条具有已存在于表中<code>StuID</code>的记录，这会违反主键约束，导致错误：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union (StuID, Name, Age, Major) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;电子工程&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行上述插入语句时，因为<code>StuID</code>为1的记录已经存在，所以数据库会返回错误信息，提示违反了唯一性约束或主键约束。</p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612210531708.png" alt="image-20240612210531708"></p><h3 id="3-演示违反实体完整性的更新操作"><a href="#3-演示违反实体完整性的更新操作" class="headerlink" title="(3) 演示违反实体完整性的更新操作"></a>(3) 演示违反实体完整性的更新操作</h3><p>尝试更新表中某条记录的<code>StuID</code>为已存在的另一个<code>StuID</code>值，同样会违反实体完整性：</p><p>先插入一条记录:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union (StuID, Name, Age, Major) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;物理&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在已有记录：</p><ul><li><code>StuID</code>&#x3D;2, <code>Name</code>&#x3D;’王五’, <code>Age</code>&#x3D;22, <code>Major</code>&#x3D;’物理’</li></ul><p>尝试更新记录使其<code>StuID</code>与现有另一记录相同：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Stu_Union <span class="keyword">SET</span> StuID <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> StuID <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612210803947.png" alt="image-20240612210803947"></p><h2 id="实验二、"><a href="#实验二、" class="headerlink" title="实验二、"></a>实验二、</h2><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/wps2.jpg" alt="img"></p><h4 id="1-为演示参照完整性，建立表Course，令cno为其主键，并在Stu-Union中插入数据。"><a href="#1-为演示参照完整性，建立表Course，令cno为其主键，并在Stu-Union中插入数据。" class="headerlink" title="(1) 为演示参照完整性，建立表Course，令cno为其主键，并在Stu_Union中插入数据。"></a>(1) 为演示参照完整性，建立表<code>Course</code>，令<code>cno</code>为其主键，并在<code>Stu_Union</code>中插入数据。</h4><p>首先，创建<code>Course</code>表，并定义<code>cno</code>为主键：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course (</span><br><span class="line">    cno <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    cname <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    teacher <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来，在<code>Stu_Union</code>表中插入一些数据，以便后续关联使用：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union (StuID, Name, Age, Major) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;物理&#x27;</span>);</span><br></pre></td></tr></table></figure><p>同时，在<code>Course</code>表中插入数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Course (cno, cname, teacher) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;计算机科学导论&#x27;</span>, <span class="string">&#x27;赵老师&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;高等数学&#x27;</span>, <span class="string">&#x27;钱老师&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612211531295.png" alt="image-20240612211531295"></p><h4 id="2-建立表SC，令sno和cno分别为参照Stu-Union表以及Course表的外键，设定为级联删除，并令-sno-cno-为其主键。在不违反参照完整性的前提下，插入数据。"><a href="#2-建立表SC，令sno和cno分别为参照Stu-Union表以及Course表的外键，设定为级联删除，并令-sno-cno-为其主键。在不违反参照完整性的前提下，插入数据。" class="headerlink" title="(2) 建立表SC，令sno和cno分别为参照Stu_Union表以及Course表的外键，设定为级联删除，并令(sno, cno)为其主键。在不违反参照完整性的前提下，插入数据。"></a>(2) 建立表<code>SC</code>，令<code>sno</code>和<code>cno</code>分别为参照<code>Stu_Union</code>表以及<code>Course</code>表的外键，设定为级联删除，并令<code>(sno, cno)</code>为其主键。在不违反参照完整性的前提下，插入数据。</h4><p>创建<code>SC</code>表，设定外键关系并启用级联删除：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC (</span><br><span class="line">    sno <span class="type">INT</span>,</span><br><span class="line">    cno <span class="type">INT</span>,</span><br><span class="line">    grade <span class="type">FLOAT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (sno, cno),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (sno) <span class="keyword">REFERENCES</span> Stu_Union(StuID) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (cno) <span class="keyword">REFERENCES</span> Course(cno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入符合参照完整性的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC (sno, cno, grade) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">85.0</span>), (<span class="number">3</span>, <span class="number">2</span>, <span class="number">90.0</span>);</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612211653728.png" alt="image-20240612211653728"></p><h4 id="3-演示违反参照完整性的插入数据。"><a href="#3-演示违反参照完整性的插入数据。" class="headerlink" title="(3) 演示违反参照完整性的插入数据。"></a>(3) 演示违反参照完整性的插入数据。</h4><p>尝试插入一条<code>SC</code>表的记录，其中<code>sno</code>或<code>cno</code>引用了不存在于<code>Stu_Union</code>或<code>Course</code>表中的值：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC (sno, cno, grade) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">78.0</span>);</span><br></pre></td></tr></table></figure><p>这将因违反外键约束而失败，因为<code>sno=4</code>没有对应的记录在<code>Stu_Union</code>表中。</p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612211738182.png" alt="image-20240612211738182"></p><h4 id="4-在Stu-Union中删除数据，演示级联删除。"><a href="#4-在Stu-Union中删除数据，演示级联删除。" class="headerlink" title="(4) 在Stu_Union中删除数据，演示级联删除。"></a>(4) 在<code>Stu_Union</code>中删除数据，演示级联删除。</h4><p>删除<code>Stu_Union</code>中的一条记录，观察<code>SC</code>表中与之关联的数据是否会自动删除：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Stu_Union <span class="keyword">WHERE</span> StuID <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>由于设置了级联删除，当删除学生记录时，与该学生相关的<code>SC</code>表中的记录也会被自动删除。</p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612211937640.png" alt="image-20240612211937640"></p><h4 id="5-在Course中删除数据，演示级联删除。"><a href="#5-在Course中删除数据，演示级联删除。" class="headerlink" title="(5) 在Course中删除数据，演示级联删除。"></a>(5) 在<code>Course</code>中删除数据，演示级联删除。</h4><p>删除<code>Course</code>表中的一条记录，查看是否会影响到<code>SC</code>表：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Course <span class="keyword">WHERE</span> cno <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>同样的，由于设置了级联删除，当课程记录被删除时，所有与该课程相关的<code>SC</code>表中的记录也将被自动删除。</p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612212106066.png" alt="image-20240612212106066"></p><h2 id="实验三、"><a href="#实验三、" class="headerlink" title="实验三、"></a>实验三、</h2><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/wps3.jpg" alt="img"></p><h4 id="1-创建Worker表，并自定义两个约束U1以及U2，其中U1规定Name字段唯一，U2规定sage（级别）字段的上限是28。"><a href="#1-创建Worker表，并自定义两个约束U1以及U2，其中U1规定Name字段唯一，U2规定sage（级别）字段的上限是28。" class="headerlink" title="(1) 创建Worker表，并自定义两个约束U1以及U2，其中U1规定Name字段唯一，U2规定sage（级别）字段的上限是28。"></a>(1) 创建<code>Worker</code>表，并自定义两个约束<code>U1</code>以及<code>U2</code>，其中<code>U1</code>规定<code>Name</code>字段唯一，<code>U2</code>规定<code>sage</code>（级别）字段的上限是28。</h4><h5 id="创建Worker表"><a href="#创建Worker表" class="headerlink" title="创建Worker表"></a>创建<code>Worker</code>表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Worker (</span><br><span class="line">    ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    sage <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="添加约束U1和U2"><a href="#添加约束U1和U2" class="headerlink" title="添加约束U1和U2"></a>添加约束<code>U1</code>和<code>U2</code></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加唯一性约束U1</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Worker <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> U1 <span class="keyword">UNIQUE</span> (Name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加检查约束U2，限制sage字段的最大值为28</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Worker <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> U2 <span class="keyword">CHECK</span> (sage <span class="operator">&lt;=</span> <span class="number">28</span>);</span><br></pre></td></tr></table></figure><p>这样，我们就分步骤创建了<code>Worker</code>表，并明确地添加了两个约束：<code>U1</code>保证<code>Name</code>字段的唯一性，而<code>U2</code>确保<code>sage</code>字段的值不超过28。接下来，您可以按照之前的步骤继续进行插入记录的实验。</p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612212544576.png" alt="image-20240612212544576"></p><h4 id="2-在Worker表中插入一条合法记录。"><a href="#2-在Worker表中插入一条合法记录。" class="headerlink" title="(2) 在Worker表中插入一条合法记录。"></a>(2) 在<code>Worker</code>表中插入一条合法记录。</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker (ID, Name, sage) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这是一条合法记录，因为<code>Name</code>字段值未重复，且<code>sage</code>值小于等于28。</p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612212617806.png" alt="image-20240612212617806"></p><h4 id="3-演示插入违反U2约束的例子，U2规定元组的sage属性的值必须小于等于28。"><a href="#3-演示插入违反U2约束的例子，U2规定元组的sage属性的值必须小于等于28。" class="headerlink" title="(3) 演示插入违反U2约束的例子，U2规定元组的sage属性的值必须小于等于28。"></a>(3) 演示插入违反<code>U2</code>约束的例子，<code>U2</code>规定元组的<code>sage</code>属性的值必须小于等于28。</h4><p>尝试插入<code>sage</code>值超过28的记录：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker (ID, Name, sage) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>此操作会因违反<code>U2</code>约束（<code>sage</code>必须小于等于28）而失败。</p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612212639576.png" alt="image-20240612212639576"></p><h4 id="4-去除U2约束。"><a href="#4-去除U2约束。" class="headerlink" title="(4) 去除U2约束。"></a>(4) 去除<code>U2</code>约束。</h4><p>要移除一个约束，首先需要知道其名称，我们已知为<code>U2</code>。可以使用以下命令删除<code>U2</code>约束：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Worker <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> U2;</span><br></pre></td></tr></table></figure><p>这将从<code>Worker</code>表中移除对<code>sage</code>字段的上限检查。</p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612213003335.png" alt="image-20240612213003335"></p><h4 id="5-重新插入-3-中想要插入的数据，由于去除了U2约束，所以插入成功。"><a href="#5-重新插入-3-中想要插入的数据，由于去除了U2约束，所以插入成功。" class="headerlink" title="(5) 重新插入(3)中想要插入的数据，由于去除了U2约束，所以插入成功。"></a>(5) 重新插入(3)中想要插入的数据，由于去除了<code>U2</code>约束，所以插入成功。</h4><p>再次尝试插入之前违反<code>U2</code>约束的记录：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker (ID, Name, sage) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>这次插入应该会成功，因为<code>sage</code>字段的检查约束已经被移除，不再限制<code>sage</code>的值必须小于等于28。</p><p><img src="/hexo-blog/./img/note/openguass%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20240612213044723.png" alt="image-20240612213044723"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据库错题</title>
      <link href="/hexo-blog/2024/06/12/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/"/>
      <url>/hexo-blog/2024/06/12/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql数据库错题"><a href="#mysql数据库错题" class="headerlink" title="mysql数据库错题"></a>mysql数据库错题</h1><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-12-01-21-image-1718194853935-162.png"></p><p>关系代数的最基本操作中，除了并、差、笛卡尔积之外，还包括 <strong>选择</strong> 和 <strong>投影</strong>。这些操作是关系代数的基础，用于从关系中提取信息、组合关系或创建新的关系。因此，正确答案是：</p><p>A. 选择、投影</p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-12-01-35-image-1718194853937-178.png"></p><p>关系R(A，B，C，D)有4个属性，而关系S(B，C，D)有3个属性。当计算两个关系的笛卡尔积R×S时，结果关系中的每一行都会包含R的所有属性和S的所有属性，且来自R的属性与来自S的属性互不重叠（尽管它们可能有相同的属性名，但这不影响元数的计算）。</p><p>因此，R×S的元数（即属性的数量）是R的元数加上S的元数，因为没有共同的属性需要减去。</p><p>所以，R×S的元数 &#x3D; 4（R的属性数量）+ 3（S的属性数量）&#x3D; 7。</p><p>正确答案是 D. 7。</p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-12-13-11-image-1718194853935-163.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-13-02-17-image-1718194853934-161.png"></p><p>在SQL中，表达式<code>(3+null) and (4&gt;3)</code>的求值需要根据SQL的三值逻辑来理解。</p><ol><li><code>3+null</code> 的结果是 <code>null</code>，因为在SQL中，任何数值与 <code>null</code> 进行算术运算的结果都是 <code>null</code>。</li><li><code>(4&gt;3)</code> 是一个布尔表达式，它的结果是 <code>true</code>，因为4确实大于3。</li><li>在SQL的三值逻辑中，<code>true</code> 和 <code>null</code> 进行 <code>AND</code> 操作时，结果是 <code>null</code>，而不是 <code>false</code>。这是因为 <code>null</code> 表示未知，与任何确定的布尔值进行逻辑运算时，结果都是未知。</li></ol><p>综上所述，表达式 <code>(3+null) and (4&gt;3)</code> 的最终结果是 <code>null</code>。这意味着该表达式在SQL中不会被评估为 <code>true</code>，即使其中一部分 <code>(4&gt;3)</code> 是 <code>true</code>。在WHERE子句中，这样的表达式不会匹配到任何行，因为 <code>null</code> 不被视为 <code>true</code> 来满足条件。</p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-13-16-44-image-1718194853935-164.png"></p><p>（1）求供应工程J1零件的供应商号码SNO；</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> SPJ.SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO <span class="operator">=</span> <span class="string">&#x27;J1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（2）求供应工程J1零件P1的供应商号码SNO；</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> SPJ.SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO <span class="operator">=</span> <span class="string">&#x27;J1&#x27;</span> <span class="keyword">AND</span> SPJ.PNO <span class="operator">=</span> <span class="string">&#x27;P1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（3）求供应工程J1零件为红色的供应商号码SNO；</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> SPJ.SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">JOIN</span> P <span class="keyword">ON</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO <span class="operator">=</span> <span class="string">&#x27;J1&#x27;</span> <span class="keyword">AND</span> P.COLOR <span class="operator">=</span> <span class="string">&#x27;红色&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（4）求没有使用天津供应商生产的红色零件的工程好JNO；</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> J.JNO</span><br><span class="line"><span class="keyword">FROM</span> J</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">FROM</span> SPJ </span><br><span class="line">    <span class="keyword">JOIN</span> S <span class="keyword">ON</span> SPJ.SNO <span class="operator">=</span> S.SNO </span><br><span class="line">    <span class="keyword">JOIN</span> P <span class="keyword">ON</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    <span class="keyword">WHERE</span> J.JNO <span class="operator">=</span> SPJ.JNO <span class="keyword">AND</span> S.CITY <span class="operator">=</span> <span class="string">&#x27;天津&#x27;</span> <span class="keyword">AND</span> P.COLOR <span class="operator">=</span> <span class="string">&#x27;红色&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（5）求至少用了供应商S1所供应的全部零件的工程和JNO； 这个问题比较复杂，需要两层嵌套查询，首先找出S1供应的所有零件，然后查找使用了这些全部零件的工程。这里给出一个可能的解法，但请注意，实际执行可能依赖于特定数据库系统对集合操作的支持程度。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先找出S1供应的所有零件</span></span><br><span class="line"><span class="keyword">WITH</span> S1Parts <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> PNO</span><br><span class="line">    <span class="keyword">FROM</span> SPJ</span><br><span class="line">    <span class="keyword">WHERE</span> SNO <span class="operator">=</span> <span class="string">&#x27;S1&#x27;</span></span><br><span class="line">),</span><br><span class="line"><span class="comment">-- 找出使用了S1供应的所有零件的工程</span></span><br><span class="line">QualifiedProjects <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> JNO</span><br><span class="line">    <span class="keyword">FROM</span> SPJ</span><br><span class="line">    <span class="keyword">WHERE</span> PNO <span class="keyword">IN</span> (<span class="keyword">SELECT</span> PNO <span class="keyword">FROM</span> S1Parts)</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> JNO</span><br><span class="line">    <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> PNO) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> S1Parts)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> QualifiedProjects;</span><br></pre></td></tr></table></figure><p>这段SQL使用了CTE（公共表达式）来分步解决这个问题，先定义了S1供应的零件集合，然后通过比较每个工程使用的零件集合是否与S1的零件集合相等来找出符合条件的工程。注意，实际应用中可能需要根据具体的数据库系统调整查询策略。</p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-14-00-55-image-1718194853935-165.png"></p><p>1.在从E-R模型到关系模型的转化中，关系的外部键（foreign key）通常不是由联系集自带的属性直接转化而来的。外部键主要是用来表示实体之间的关联关系。在E-R模型中，联系可以是简单联系（无属性）或复杂联系（有属性）。转化时：</p><ul><li>简单联系（无属性）通常转化为一个表中的外键，引用另一个表的主键，以此来表示两个实体之间的关系。</li><li>复杂联系（有属性）则会转化为一个独立的表，该表的外键同时引用与之关联的两个实体表的主键，而这个联系表中的属性也会转换为该表的列。</li></ul><p>因此，外部键更多地体现了实体之间的关联，而非联系集自带的属性直接转化，尽管在复杂联系转化为关系表时，其自带的属性也会成为新表的一部分，但核心的外键设计是为了体现关联性。</p><p>2.正确答案是：</p><p>B. 概念设计</p><p>在数据库设计的过程中，E-R模型的设计属于概念设计阶段。这个阶段主要是将需求分析得到的信息抽象成概念模型，而E-R模型作为一种常用的概念数据模型，用于描述数据的静态结构、实体之间的关系以及实体的属性等。</p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-14-17-28-image-1718194853935-166.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-14-19-53-image-1718194853935-167.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-14-20-21-image-1718194853936-169.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-15-31-52-image-1718194853936-168.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-15-55-59-image-1718194853936-170.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-15-56-12-image-1718194853936-171.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-17-14-17-image-1718194853936-172.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-17-30-29-image-1718194853936-173.png"></p><p>在SQL中，创建一个死锁情景通常涉及到两个或更多的事务，它们互相等待对方释放锁的资源。下面是一个简化的例子，演示如何在两个事务中创建死锁情况。假设我们有一个简单的银行账户表<code>bank_account</code>，包含字段<code>account_id</code>和<code>balance</code>。</p><h3 id="事务1-在第一个SQL查询分析器中执行"><a href="#事务1-在第一个SQL查询分析器中执行" class="headerlink" title="事务1 (在第一个SQL查询分析器中执行)"></a>事务1 (在第一个SQL查询分析器中执行)</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务1尝试更新账户A的余额，但需要等待事务2完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> bank_account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这里加入WAITFOR延迟，模拟实际应用中可能存在的处理时间</span></span><br><span class="line"></span><br><span class="line">WAITFOR DELAY <span class="string">&#x27;00:00:05&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 假设接下来事务1想要更新账户B，但这会被事务2锁定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> bank_account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h3 id="事务2-在第二个SQL查询分析器中几乎同时执行"><a href="#事务2-在第二个SQL查询分析器中几乎同时执行" class="headerlink" title="事务2 (在第二个SQL查询分析器中几乎同时执行)"></a>事务2 (在第二个SQL查询分析器中几乎同时执行)</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2尝试更新账户B的余额，但需要等待事务1完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> bank_account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同样加入WAITFOR延迟</span></span><br><span class="line"></span><br><span class="line">WAITFOR DELAY <span class="string">&#x27;00:00:05&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 假设接下来事务2想要更新账户A，但这会被事务1锁定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> bank_account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>在这个场景中，如果两个事务几乎同时启动，它们会各自锁定一个账户并等待对方释放锁。事务1锁定了账户A并等待账户B，而事务2则锁定了账户B并等待账户A，形成经典的死锁情形。在实际的数据库管理系统中，大多数都配备了死锁检测机制，当检测到死锁时，会自动选择一个事务进行回滚以打破死锁状态。</p><p>在数据库中为什么要并发操作？</p><p>在数据库中采用并发操作的原因主要包括以下几点：</p><ol><li><strong>提高系统性能与响应速度</strong>：并发允许数据库同时处理多个用户的请求，提高了系统的吞吐量。这样可以减少用户等待时间，使系统能够更快地响应用户操作，提升用户体验。</li><li><strong>支持多用户访问</strong>：在现实场景中，数据库往往是多用户共享的资源。并发机制确保了多个用户能够同时访问和操作数据库，避免了单一用户独占资源的情况，提高了资源的利用率。</li><li><strong>提高资源利用率</strong>：特别是在多核处理器的系统中，通过并发执行多个线程或进程，可以充分利用多个CPU核心，避免了单线程执行时CPU资源的闲置，提升了处理能力。</li><li><strong>实现数据一致性</strong>：虽然并发操作可能引发数据不一致的问题，但通过有效的并发控制机制（如锁定、多版本并发控制（MVCC）、时间戳等），可以在保证并发性的同时维护数据库的一致性，防止丢失更新、脏读、不可重复读和幻读等并发控制问题的发生。</li><li><strong>满足实时处理需求</strong>：在需要实时数据处理和分析的应用场景中，如在线交易系统、实时监控系统等，并发操作能够即时响应用户需求，处理大量并发事务，保证服务的连续性和可用性。</li></ol><p>综上所述，数据库中的并发操作是现代信息系统高效运作的基础，它不仅关乎系统性能的优化，也直接关系到用户体验和服务质量。通过合理的并发控制策略，可以在保障数据准确性和一致性的前提下，充分发挥系统的处理潜能。</p><p>并发操作会带来哪几种数据库不一致问题，这些问题是如何产生的？</p><p>并发操作在数据库中可能会引发以下几种数据不一致问题：</p><ol><li><strong>丢失修改（Lost Update）</strong>：</li></ol><p>  当两个或多个事务同时读取同一条数据，并基于初始读取的值进行修改，然后提交时，最后一个提交的事务会覆盖之前事务所做的修改。这样，先前事务所做的修改就被丢失了。例如，两个用户试图同时更新同一笔订单的余额，如果没有适当的并发控制，后提交的事务可能会覆盖前一个事务的更新，导致前一个事务的修改丢失。</p><ol><li><strong>不可重复读（Non-Repeatable Read）</strong>：</li></ol><p>  在同一个事务内，如果两次或多次读取同一数据，第二次或之后的读取可能会得到与第一次不同的结果，这是因为其他事务在这两次读取之间修改并提交了数据。这违反了事务的隔离性，使得在同一个事务中无法重复获取相同的数据视图。</p><ol><li><strong>读“脏”数据（Dirty Read）</strong>：</li></ol><p>  当一个事务读取了另一个事务尚未提交的修改数据时，如果后者最终回滚，那么前者读取到的就是无效的、不一致的数据，即所谓的“脏”数据。这种情况同样破坏了事务的隔离性。</p><p>这些问题主要是由于并发控制不当，导致事务的隔离性被破坏而产生的。在数据库系统中，为了解决这些问题，通常会采用不同的并发控制技术，比如锁机制（乐观锁、悲观锁）、多版本并发控制（MVCC）、时间戳排序等，以确保在并发环境下数据的一致性和事务的正确执行。</p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-28-42-image-1718194853936-174.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-30-41-image-1718194853936-175.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-31-38-image-1718194853936-176.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-33-14-image-1718194853937-179.png"></p><p><img src="/hexo-blog/./img/note/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-49-55-image-1718194853936-177.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从E-R模型到关系模型</title>
      <link href="/hexo-blog/2024/06/12/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"/>
      <url>/hexo-blog/2024/06/12/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="从E-R模型到关系模型"><a href="#从E-R模型到关系模型" class="headerlink" title="从E-R模型到关系模型"></a>从E-R模型到关系模型</h1><p>E-R模型和关系模型都是现实世界抽象的逻辑表示</p><ul><li>E-R模型并不被 DBMS直接支持，更适合对现实世界建模</li><li>关系模型是 DBMS直接支持的数据模型</li></ul><p>基本 E-R图中的元素包括实体集、联系集、属性</p><p>椭圆框表示属性，矩形框表示实体集，菱形框表示联系</p><p><img src="/hexo-blog/./img/note/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqdXd4eA==,size_16,color_FFFFFF,t_70.png"></p><h2 id="属性处理"><a href="#属性处理" class="headerlink" title="属性处理"></a>属性处理</h2><p>关系模型要求关系的所有属性都是原子的。然而 E-R模型中的复合属性和多值属性不是原子的，E-R模型还允许出现派生属性，这三种属性需要特殊处理</p><p>（1）派生属性</p><p>派生属性的值可以通过计算得到，它的值不在数据库中存储，转换时直接忽略</p><p>（2）复合属性</p><p>采用”展平”技术：忽略复合属性本身，直接考虑它的成分属性。如果某个成分属性仍然是复合的，用相同方法处理</p><p><em>例如，考虑实体集职工复合属性”家庭住址”，它包含成分属性省、城市、街道、邮政编码。在将该实体集转换成关系模式时，忽略复合属性”家庭住址”，而直接使用成分属性省、城市、街道、邮政编码作为关系模式的属性</em></p><p>（3）多值属性</p><p>需要为每个多值属性 M创建一个关系 RMRMR_{M}</p><ol><li>如果多值属性 M是实体集 E的属性，K是 E的主码，则关系 RMRMR_{M}的属性由 M和 K组成</li><li>如果多值属性 M是联系集 R的属性，并且 R涉及实体集 E1，…，En，它们的主码分别是 K1，…，Kn，则关系 RMRMR_{M}的属性由 M和 K1，…，Kn组成</li></ol><p>注意：如果 M还是复合属性，则需要按复合属性的处理方法对 M做”展平”处理。关系 RMRMR_{M}的码需要根据实际问题的语义确定。此外一旦为多值属性创建了关系，后续处理就不再考虑多值属性</p><hr><p><strong>例1、多值属性转换</strong></p><p>如总图，Phones 是实体集 Departments 的多值属性，为其创建一个关系。由于 Phones还是复合属性，需要对它做”展平”处理：直接使用其成分属性 Office 和 Phone#。实体集 Departments 的码是 Dno。由此得到多值属性 Phones 的关系模式为：<strong>Phones(Phone#, Dno, Office)</strong></p><p>假定每部电话都在一个院系的办公室，因此 Phone# 可以作为 Phones 的码</p><p>注意：这里把为多值属性 Phones 创建的关系用 Phones 命名。原则上如何命名没有规定，但是采用容易记忆的名字有助于理解，并且当多值属性是复合属性时，直接使用多值属性名作为关系名是方便的</p><h2 id="实体集处理"><a href="#实体集处理" class="headerlink" title="实体集处理"></a>实体集处理</h2><blockquote><p><strong>强 &#x2F; 弱实体集</strong></p><p>一般地，如果一个实体集的<strong>任何属性集都不足以形成该实体集的码</strong>，则称该实体集为<strong>弱实体集</strong>。与此相对，存在码的实体集称为强实体集</p><p>弱实体集中的任何实体（简称弱实体）都不能独立地存在于系统中，即每个弱实体必须依赖于一个强实体。<em>例如每个家属必须存在依赖于一个特定的职工（只有这样他才被公司视为家属），当一位职工离开公司，他的配偶和子女都不再被公司视为家属</em></p><ul><li>弱实体集必须与另一个称为<strong>标识实体集</strong>或属主实体集的强实体集相关联才有意义</li><li>称标识实体集拥有它所标识的弱实体集，将弱实体集与其标识实体集相关联的的联系称为<strong>标识性联系</strong></li><li><strong>标识性联系是</strong>从弱实体集到标识实体集的<strong>多对一联系</strong>，并且弱实体集对该联系的参与是全部参与</li></ul><p>在弱实体集中，如果它的一个属性集可以唯一确定 存在依赖于同一个强实体的弱实体，则称该属性集为弱实体集的<strong>分辨符</strong>。弱实体集的标识实体集的码和该弱实体集的分辨符共同形成弱实体集的码，弱实体集的分辨符又称弱实体集的部分码</p></blockquote><p>每个强实体集用一个关系表示。实体集名可以作为关系名，实体集的全部属性构成关系的属性（复合属性按照前面的方法”展平”），实体集的码作为关系的码</p><p>每个弱实体集用一个关系表示。弱实体集名可以作为关系名，弱实体集存在依赖的标识实体集的主码和弱实体集的全部属性构成关系的属性（复合属性按照前面的方法”展平”），标识实体集的码和弱实体集的分辨符组合成关系的码。下图给出了强实体集职工和弱实体集家属转换后的关系模式</p><p><img src="/hexo-blog/./img/note/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqdXd4eA==,size_16,color_FFFFFF,t_70.png"></p><h2 id="联系集处理"><a href="#联系集处理" class="headerlink" title="联系集处理"></a>联系集处理</h2><p>每个联系集用一个关系表示，但弱实体集与其标识实体集之间的存在依赖关系忽略</p><p>联系集名可以作为关系名，参与联系的诸实体集的主码和联系集的属性（复合属性按照前面的方法”展平”）形成关系的属性</p><p>关系的码根据联系的类型按如下方法确定</p><p><img src="/hexo-blog/./img/note/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqdXd4eA==,size_16,color_FFFFFF,t_70.png"></p><p>联系集转关系时，先找到一个联系集，然后顺着连线找到关联的多个实体集。观察实体集间的连线：</p><ol><li>连线的两端都有箭头，说明是<strong>一对一的联系</strong>，<strong>新的主码是两关系的候选码中的一个</strong>（两个候选码都画有下划线，但下划线不相连，具体哪个是主码，自定）</li><li>连线的一端有箭头，说明是<strong>一对多的联系</strong>，箭头一端是”单端”，新<strong>的主码由”多端”实体集的码组成</strong></li><li>连线两端都没箭头，说明是<strong>多对多的联系</strong>，<strong>新的主码由所有实体集的码组成</strong></li></ol><h2 id="将基本-E-R图转换成关系模式"><a href="#将基本-E-R图转换成关系模式" class="headerlink" title="将基本 E-R图转换成关系模式"></a>将基本 E-R图转换成关系模式</h2><p>为了将联系转换成关系模式，要求参与同一联系的任何两个不同的实体集的主码都不包含相同的属性（这一点容易做到，属性是局部于实体集的，必要时可以对某些属性重命名）</p><p>假定复合属性已经”展平”，多值属性创建了对应的关系。将 E-R模型转换成关系模式的方法如下</p><ol><li>每个强实体集用一个关系表示</li><li>每个弱实体集用一个关系表示</li><li>将联系集用相应的方法转换成关系表示</li><li>如果两个关系具有相同的码，可以合并它们（这一步并非必须，但可以减少码重复存放空间开销，使查询可以更有效的求值）</li></ol><hr><p><strong>例2、将总图转换成关系模式</strong></p><p>总图的多值复合属性 Phones 得到关系模式：<strong>Phones(Phone#, Dno, Office)</strong></p><p>总图没有弱实体集，由强实体集得到如下关系模式：</p><p><strong>Departments(Dno, Dname)</strong></p><p><strong>Teachers(Tno, Tname, Sex, Birthday, Title)</strong></p><p><strong>Students(Sno, Sname, Sex, Birthday, Enrollyear, Speciality)</strong></p><p><strong>Courses(Cno, Cname, Perid, Credit)</strong></p><p>其中每个关系模式都源于同名实体集，码用下划线标记。多值属性 Phones 不包含在关系模式 Departments 中，已经将它转换成关系模式</p><p>由联系集得到如下关系模式：</p><p><strong>Manades(Dno,  Tno)</strong></p><p><strong>Works_in(Tno, Dno)</strong></p><p><strong>Studies_in(Sno, Dno)</strong></p><p><strong>Teaches(Tno, Cno)</strong></p><p><strong>SC(Sno, Cno, Grade)</strong></p><p><strong>Evalues(Sno, Tno, Cno, Escore)</strong></p><p>其中每个关系模式都源于同名联系集，码用下划线标记。Manages 和 Works_in 包含相同的属性，但它们含义不同，前者 Tno 表示作为系主任的教师对特定的”系”（用 Tno 表示）的管理，后者表示每位教师在一个特定的系工作</p><p>最后一步，合并具有相同码的关系模式（合并时可根据实际情况，也可根据题设要求）</p><p>Manages 可以和 Departments 合并，也可以与 Teachers 合并，前者有利于回答 <em>“某系的主任是谁”</em> 之类的问题，后者有利于回答 <em>“某教师的系主任是谁”</em> 之类的问题。前一类问题更常出现，采用前一种方法，得到关系模式 **Departments(Dno, Dname, Dheadno)**（把表示系主任的职工号的属性名 Tno 改为 Dheadno，使得属性的语义更清楚）</p><p>还有两对关系具有相同的码，<strong>Teachers</strong> 和 <strong>Works_in</strong>，<strong>Students</strong> 和 <strong>Studies_in</strong>，都可以直接合并。最终得到关系模式：</p><p><strong>Departments(Dno, Dname, Dheadno)</strong></p><p><strong>Teachers(Tno, Tname, Sex, Birthday, Title, Tno)</strong></p><p><strong>Students(Sno, Sname, Sex, Birthday, Enrollyear, Speciality, Dno)</strong></p><p><strong>Courses(Cno, Cname, Perid, Credit)</strong></p><p><strong>Teaches(Tno, Cno)</strong></p><p><strong>SC(Sno, Cno, Grade)</strong></p><p><strong>Evalues(Sno, Tno, Cno, Escore)</strong></p><p><strong>Phones(Phone#, Dno, Office)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin 生成 Swagger 接口文档</title>
      <link href="/hexo-blog/2024/06/12/gin%E4%B8%AD%E7%94%9F%E6%88%90Swagger%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
      <url>/hexo-blog/2024/06/12/gin%E4%B8%AD%E7%94%9F%E6%88%90Swagger%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Gin-生成-Swagger-接口文档"><a href="#Gin-生成-Swagger-接口文档" class="headerlink" title="Gin 生成 Swagger 接口文档"></a>Gin 生成 Swagger 接口文档</h1><h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">1.背景</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">2.Swagger</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">3.准备工作</a></li><li><ul><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">安装 swag 命令</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">添加声明式注释</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">执行 swag init 生成接口描述文件</a></li></ul></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">4.Gin 集成 Swagger</a></li><li><ul><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">import 依赖包</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">import 生成的 docs 包</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">注册 Gin router</a></li></ul></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">5.FAQ</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">参考文献</a></li></ul><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>后台服务通过接口（如 <a href="https://cloud.tencent.com/product/slshttp?from_column=20065&from=20065">RESTful API</a>）对外提供服务时，需要有明确的接口文档。</p><p>书写接口文档，我们可以手动书写，也可以采用工具自动生成。手动书写的问题在于接口协议变更后需要维护接口文档，效率低下。采用工具生成，不同的工具生成的接口文档风格不一，增加阅读者的理解成本。</p><p>因此，我们可以采用业界常用的 Swagger 为 RESTful API 生成可交互的接口文档。</p><p>本文以 Gin 框架为例，描述 Gin 中如何为接口生成 Swagger 文档。</p><h2 id="2-Swagger"><a href="#2-Swagger" class="headerlink" title="2.Swagger"></a>2.Swagger</h2><p>Swagger 是一套基于 OpenAPI 规范实现的用于编写 RESTful API 文档的开源工具。可通过编写 yaml 和 json 来实现接口的文档化，并且可以进行测试等工作。</p><p>通过 Swagger 可以方便地生成接口文档，方便前端进行查看和测试。</p><p>Swagger 主要包含了以下三个部分：</p><ul><li>Swagger Editor</li></ul><p>基于浏览器的编辑器，我们可以使用它编写我们 OpenAPI 规范(yaml 或 json 配置）。</p><ul><li>Swagger UI</li></ul><p>他会将我们编写的 OpenAPI 规范呈现为交互式的 API 文档，后文我将使用浏览器来查看并且操作我们的 RESTfulAPI。</p><ul><li>Swagger Codegen</li></ul><p>它可以通过 OpenAPI 规范定义的任何 API 生成<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>存根和客户端SDK来简化构建过程。</p><p>使用 Swagger 就是把接口相关信息存储在它定义的描述文件里面（yaml 或 json 格式），再通过维护这个描述文件可以去更新接口文档，以及生成各端代码。</p><h2 id="3-准备工作"><a href="#3-准备工作" class="headerlink" title="3.准备工作"></a>3.准备工作</h2><h3 id="安装-swag-命令"><a href="#安装-swag-命令" class="headerlink" title="安装 swag 命令"></a>安装 swag 命令</h3><p>首先本地需要先安装 swag <a href="https://cloud.tencent.com/product/cli?from_column=20065&from=20065">命令行工具</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">go install github.<span class="property">com</span>/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure><p>swag 命令的作用是扫描程序文件，根据接口规范注释，生成接口描述文件（yaml或json格式）。</p><h3 id="添加声明式注释"><a href="#添加声明式注释" class="headerlink" title="添加声明式注释"></a>添加声明式注释</h3><p>在源码中添加<a href="/developer/tools/blog-entry?target=https://github.com/swaggo/swag#declarative-comments-format&source=article&objectId=2221656">声明式注释</a>，用于生成接口描述文件。</p><ul><li>General API Info</li></ul><p>此类注释用于描述接口的一般信息，在 main() 函数处添加。如 title，version，description 等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @title XX管理系统后台接口。</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @description XX管理系统后台接口，供 APP 及 Web 端调用。</span></span><br><span class="line"><span class="comment">// @host https://xxx.xxx.com</span></span><br><span class="line"><span class="comment">// @basePath /api/v1</span></span><br><span class="line"><span class="comment">// @schemes https</span></span><br><span class="line"><span class="comment">// @accept json</span></span><br><span class="line"><span class="comment">// @produce json</span></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>API Operation</li></ul><p>此类注释用于描述接口的具体信息，在每一个接口函数处添加。如 Summary, Description, Tags 等。</p><p>Summary 是简短描述，Description 是详细描述，Tags 是逗号分隔的标签，用于分组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 检查 APP 包是否需要升级。</span></span><br><span class="line"><span class="comment">// @Description  检查 APP 包是否需要升级。</span></span><br><span class="line"><span class="comment">// @Tags APP 接口。</span></span><br><span class="line"><span class="comment">// @Accept json</span></span><br><span class="line"><span class="comment">// @Produce json</span></span><br><span class="line"><span class="comment">// @Param Body body ReqCheckAppUpgrade true &quot;请求体&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;object&#125; RspCheckAppUpgrade</span></span><br><span class="line"><span class="comment">// @Router /app/check_app_upgrade [post]</span></span><br><span class="line">func <span class="title class_">HandlerCheckAppUpgrade</span>(c *gin.<span class="property">Context</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Param 表示请求参数，格式为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">param_name,param_type,data_type,is_mandatory,comment</span><br></pre></td></tr></table></figure><p>其中 ReqCheckAppUpgrade 表示 body 使用的 struct。</p><p>Success 表示成功回包内容，其中 RspCheckAppUpgrade 表示回包 body 使用的 struct。</p><p>其他注释说明，详见 <a href="/developer/tools/blog-entry?target=https://github.com/swaggo/swag#declarative-comments-format&source=article&objectId=2221656">Declarative Comments Format</a>。</p><h3 id="执行-swag-init-生成接口描述文件"><a href="#执行-swag-init-生成接口描述文件" class="headerlink" title="执行 swag init 生成接口描述文件"></a>执行 swag init 生成接口描述文件</h3><p>在 main.go 所在目录，执行如下命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">swag init</span><br></pre></td></tr></table></figure><p>生成的接口描述文件将存入当前目录下的 docs 目录。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docs.<span class="property">go</span></span><br><span class="line">swagger.<span class="property">json</span></span><br><span class="line">swagger.<span class="property">yaml</span></span><br></pre></td></tr></table></figure><p>或者指定相关选项。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">swag init -g main.<span class="property">go</span> -d apidir --parseDependency -o docs</span><br></pre></td></tr></table></figure><p>swag init 具体用法参见：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">swag init -h</span><br></pre></td></tr></table></figure><h2 id="4-Gin-集成-Swagger"><a href="#4-Gin-集成-Swagger" class="headerlink" title="4.Gin 集成 Swagger"></a>4.Gin 集成 Swagger</h2><p>生成 API 描述文件后，便可通过 Swagger 为我们提供的库，将 API 描述文件集成到服务中，通过接口的形式提供在线文档。</p><h3 id="import-依赖包"><a href="#import-依赖包" class="headerlink" title="import 依赖包"></a>import 依赖包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">swaggerFiles <span class="string">&quot;github.com/swaggo/files&quot;</span></span><br><span class="line">ginSwagger <span class="string">&quot;github.com/swaggo/gin-swagger&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="import-生成的-docs-包"><a href="#import-生成的-docs-包" class="headerlink" title="import 生成的 docs 包"></a>import 生成的 docs 包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;&lt;your docs path&gt;&quot;</span> <span class="comment">// docs is generated by Swag CLI, you have to import it.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="注册-Gin-router"><a href="#注册-Gin-router" class="headerlink" title="注册 Gin router"></a>注册 Gin router</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">New</span>()</span><br><span class="line">router.<span class="title function_">GET</span>(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.<span class="title class_">WrapHandler</span>(swaggerfiles.<span class="property">Handler</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>完成以上所有操作后，运行服务，浏览器访问：<a href="http://localhost:8080/swagger/index.html%E3%80%82">http://localhost:8080/swagger/index.html。</a></p><p>关于最终的文档效果，可参见官方示例 <a href="/developer/tools/blog-entry?target=https://petstore.swagger.io/&source=article&objectId=2221656">Swagger Petstore</a>。</p><p>![在这里插入图片描述](img&#x2F;note&#x2F;gin 生成 Swagger 接口文档&#x2F;d920f202906a43dafe8dc68f570a0e7d.png)</p><p>在这里插入图片描述</p><h2 id="5-FAQ"><a href="#5-FAQ" class="headerlink" title="5.FAQ"></a>5.FAQ</h2><p>（1）访问接口文档发生<code>Failed to load API definition.</code>错误。</p><p>![在这里插入图片描述](img&#x2F;note&#x2F;gin 生成 Swagger 接口文档&#x2F;6271b9cb051d47c1ce84a640dca70a32.png)</p><p>在这里插入图片描述</p><p>原因是未 import 生成的 docs 包。</p><p>（2）执行 swag init会报错。</p><p>假如func方法头标注的swagger注释不正确，在自行根据报错信息去修改。</p><p>（3）访问接口文档报错 <code>404 page not found</code>。</p><p>是因为没有添加 Swagger 的路由。</p><p>（4）如果请求 Body 是 JSON 则无法添加注释，该如何给字段添加注释呢？</p><p>可以在请求 Body 对应的 struct 中添加注释，在接口的请求参数中添加说明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Param Body body ReqCheckAppUpgrade true &quot;字段描述参见 apis.ReqCheckAppUpgrade&quot;</span></span><br></pre></td></tr></table></figure><p>然后在接口文档中可找到 apis.ReqCheckAppUpgrade 的定义与字段描述。</p><p>![在这里插入图片描述](img&#x2F;note&#x2F;gin 生成 Swagger 接口文档&#x2F;c4d537bed80705c9bdebbb6e3484095e.png)</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析</title>
      <link href="/hexo-blog/2024/06/10/go%E4%B8%ADUnicode%E3%80%81UTF-8%E3%80%81UTF-16%E3%80%81UTF-32%E4%B8%8EByte%E5%88%87%E7%89%87%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/hexo-blog/2024/06/10/go%E4%B8%ADUnicode%E3%80%81UTF-8%E3%80%81UTF-16%E3%80%81UTF-32%E4%B8%8EByte%E5%88%87%E7%89%87%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析"><a href="#Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析" class="headerlink" title="Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析"></a>Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析</h1><h2 id="一、Unicode与UTF编码简介"><a href="#一、Unicode与UTF编码简介" class="headerlink" title="一、Unicode与UTF编码简介"></a>一、Unicode与UTF编码简介</h2><h3 id="1-1-Unicode角色"><a href="#1-1-Unicode角色" class="headerlink" title="1.1 Unicode角色"></a>1.1 Unicode角色</h3><p>Unicode是一个字符集，为每个字符分配了一个唯一的数字（码点），确保了跨语言的字符统一表示。它覆盖了世界上几乎所有的字符，包括字母、数字、标点符号、表情符号等。</p><h3 id="1-2-UTF编码家族"><a href="#1-2-UTF编码家族" class="headerlink" title="1.2 UTF编码家族"></a>1.2 UTF编码家族</h3><p>UTF（Unicode Transformation Format）是一系列将Unicode码点转换为字节序列的规则，主要有UTF-8、UTF-16、UTF-32三种形式，它们在存储效率、内存使用和处理速度上各有特点。</p><h2 id="二、UTF-8、UTF-16、UTF-32的区别"><a href="#二、UTF-8、UTF-16、UTF-32的区别" class="headerlink" title="二、UTF-8、UTF-16、UTF-32的区别"></a>二、UTF-8、UTF-16、UTF-32的区别</h2><h3 id="2-1-UTF-8"><a href="#2-1-UTF-8" class="headerlink" title="2.1 UTF-8"></a>2.1 UTF-8</h3><ul><li><strong>变长编码</strong>：使用1到4个字节表示一个字符，ASCII字符仅需1字节，兼容ASCII。</li><li><strong>高效存储</strong>：对英文文本特别高效，节省空间。</li><li><strong>网络友好</strong>：广泛应用于网页、电子邮件等，是互联网事实上的标准编码。</li><li><strong>无字节序问题</strong>：字节序列不依赖于处理器的字节序。</li></ul><h3 id="2-2-UTF-16"><a href="#2-2-UTF-16" class="headerlink" title="2.2 UTF-16"></a>2.2 UTF-16</h3><ul><li><strong>变长编码</strong>：大多数常用字符使用2字节，辅以代理对（特殊编码序列）处理超出基本多文种平面（BMP）的字符。</li><li><strong>内存消耗</strong>：相比UTF-8，处理非BMP字符时内存使用较高。</li><li><strong>字节序问题</strong>：存在大端序（UTF-16BE）和小端序（UTF-16LE）两种存储方式，需要字节顺序标记（BOM）标识。</li></ul><h3 id="2-3-UTF-32"><a href="#2-3-UTF-32" class="headerlink" title="2.3 UTF-32"></a>2.3 UTF-32</h3><ul><li><strong>定长编码</strong>：每个字符固定使用4字节，简化了字符处理逻辑。</li><li><strong>内存消耗高</strong>：不论字符是否属于ASCII，均使用相同大小的存储空间，效率较低。</li><li><strong>简单直接</strong>：不需要复杂的编码规则，直接映射Unicode码点。</li></ul><h2 id="三、为何UTF-8使用最为广泛"><a href="#三、为何UTF-8使用最为广泛" class="headerlink" title="三、为何UTF-8使用最为广泛"></a>三、为何UTF-8使用最为广泛</h2><ul><li><strong>兼容性</strong>：与ASCII完全兼容，确保了大量现有系统的无缝过渡。</li><li><strong>效率</strong>：对英文和大部分西欧语言极为高效，节约存储和带宽。</li><li><strong>通用性</strong>：互联网标准广泛采用，几乎所有的现代系统和浏览器都默认支持UTF-8。</li><li><strong>易处理</strong>：编码规则相对简单，错误容错性较好。</li></ul><h2 id="四、Unicode与UTF-8的关系"><a href="#四、Unicode与UTF-8的关系" class="headerlink" title="四、Unicode与UTF-8的关系"></a>四、Unicode与UTF-8的关系</h2><ul><li><strong>Unicode是字符集</strong>：定义了字符到数字的映射关系。</li><li><strong>UTF-8是编码规则</strong>：将Unicode字符映射到字节序列的具体方法，是Unicode字符集的一种实现方式。</li><li><strong>存储与处理</strong>：Unicode码点经过UTF-8编码后，可以在计算机内存或文件中存储和处理。</li></ul><h2 id="五、Go语言中的Byte切片与字符串操作"><a href="#五、Go语言中的Byte切片与字符串操作" class="headerlink" title="五、Go语言中的Byte切片与字符串操作"></a>五、Go语言中的Byte切片与字符串操作</h2><p>在Go中，字符串是不可变的，内部使用UTF-8编码。将字符串转换为<code>[]byte</code>时，实际上是创建了一个包含字符串内容拷贝的可变字节序列，这对于需要修改字符内容或进行高效I&#x2F;O操作非常有用。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;Hello, 世界!&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;原始字符串:&quot;</span>, str)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为字节切片</span></span><br><span class="line">    byteSlice := []<span class="type">byte</span>(str)</span><br><span class="line">    fmt.Println(<span class="string">&quot;转换成字节切片:&quot;</span>, byteSlice)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：直接修改字节切片不会影响原字符串</span></span><br><span class="line">    modifiedByteSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(byteSlice))</span><br><span class="line">    <span class="built_in">copy</span>(modifiedByteSlice, byteSlice)</span><br><span class="line">    modifiedByteSlice[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;修改字节切片后:&quot;</span>, <span class="type">string</span>(modifiedByteSlice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Go语言在处理文本时充分利用了UTF-8编码的高效性和兼容性。理解Unicode字符集与UTF-8编码的原理，以及如何在Go中操作字符串和字节切片，对于编写高性能、国际化友好的应用至关重要。UTF-8因其实现的高效性、兼容性和广泛支持，成为了最广泛采用的Unicode编码方式。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go中的深浅拷贝</title>
      <link href="/hexo-blog/2024/06/10/go%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/hexo-blog/2024/06/10/go%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>在Go语言中，浅拷贝相对直观，通常是通过简单的赋值操作来实现，尤其对于基本数据类型和复合类型的顶层结构。以下是几种常见情况下的浅拷贝示例：</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型（如 <code>int</code>, <code>float64</code>, <code>string</code> 等）的赋值总是<strong>深拷贝</strong>，因为它们是值类型，会在栈上分配独立的内存。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">b := a <span class="comment">// 这里是深拷贝，因为基本类型是值类型</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">fmt.Println(a) <span class="comment">// 输出 10，a 不受 b 变化的影响</span></span><br></pre></td></tr></table></figure><h3 id="复合类型（如结构体、数组）"><a href="#复合类型（如结构体、数组）" class="headerlink" title="复合类型（如结构体、数组）"></a>复合类型（如结构体、数组）</h3><p>对于复合类型，直接赋值会执行<strong>浅拷贝</strong>，即复制引用或值，但不包括内部的引用类型字段。</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>如果结构体内的字段是值类型，直接赋值会进行浅拷贝，但如果是引用类型（如切片、map、指针），则复制的是引用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Friends []<span class="type">string</span> <span class="comment">// 引用类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1 := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Friends: []<span class="type">string</span>&#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;&#125;</span><br><span class="line">p2 := p1 <span class="comment">// 浅拷贝，p1 和 p2 的 Friends 字段共享同一片内存</span></span><br><span class="line">p2.Friends[<span class="number">0</span>] = <span class="string">&quot;Robert&quot;</span></span><br><span class="line">fmt.Println(p1.Friends) <span class="comment">// 输出 [&quot;Robert&quot;, &quot;Charlie&quot;]，p1 的数据也被改变了</span></span><br></pre></td></tr></table></figure><h4 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h4><p>数组的直接赋值会进行深拷贝，因为数组是值类型。而切片的赋值则是浅拷贝，因为切片是引用类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">arrCopy := arr <span class="comment">// 对于数组，这是深拷贝</span></span><br><span class="line">sliceCopy := slice <span class="comment">// 对于切片，这是浅拷贝</span></span><br><span class="line"></span><br><span class="line">sliceCopy[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 修改sliceCopy不会影响arrCopy，但会影响原始slice</span></span><br><span class="line">fmt.Println(arr)      <span class="comment">// 输出 [1, 2, 3]</span></span><br><span class="line">fmt.Println(slice)    <span class="comment">// 输出 [100, 2, 3]</span></span><br></pre></td></tr></table></figure><p>总之，浅拷贝在Go中通过基本的赋值操作就可以实现，但对于包含引用类型字段的复合类型，这种拷贝方式需要特别注意，因为它可能导致意外的数据共享。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理复习正则表达式(二)</title>
      <link href="/hexo-blog/2024/06/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/"/>
      <url>/hexo-blog/2024/06/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理复习正则表达式-二"><a href="#编译原理复习正则表达式-二" class="headerlink" title="编译原理复习正则表达式(二)"></a>编译原理复习正则表达式(二)</h1><blockquote><p>闭包 *</p><p>或运算 |</p><p>连接运算 ab</p><p>括号 ()  – 里面的优先级更高</p></blockquote><h3 id="编译原理当中的闭包"><a href="#编译原理当中的闭包" class="headerlink" title="编译原理当中的闭包"></a>编译原理当中的闭包</h3><blockquote><p>在编译原理中，”闭包”（Closure）这个术语通常关联于词法分析或词法分析器（Lexer）的设计与实现，尤其是在讨论正则表达式到有限自动机（ Finite Automata, FA）转换的过程中。不过，这里的“闭包”概念与函数式编程中的闭包（也称为词法闭包）是不同的概念。</p><p>在词法分析的上下文中，<strong>闭包</strong>是指为了识别正则表达式中的重复或递归结构，通过应用正则运算（如Kleene星号 *，表示零次或多次重复）而构建的NFA（非确定性有限自动机）的状态集合。简而言之，给定一个正则表达式的一部分，其闭包就是能够识别该部分重复任意次（包括零次）的所有可能状态的集合。</p><p>例如，如果有一个正则表达式成分 <code>a*</code>，代表字母’a’出现0次或多次，那么它的闭包在NFA中的体现就是从初始状态（代表没有看到任何’a’的情况）到看到一个或多个’a’后的所有可能状态，以及一个可以接受空串的终止状态的集合。这个过程帮助构建了一个能够识别像”a”、”aa”、”aaa”直至无限个”a”序列的自动机。</p><p>因此，编译原理中的“闭包”是一个技术性较强的概念，主要用于描述如何通过数学上的操作构造出能够有效识别复杂语言结构的自动机模型。</p></blockquote><h3 id="正则表达式使用L-a-a-，来表示匹配a这个字符，L指的是正则表达式标识符，括号里面可以存放正则表达式"><a href="#正则表达式使用L-a-a-，来表示匹配a这个字符，L指的是正则表达式标识符，括号里面可以存放正则表达式" class="headerlink" title="正则表达式使用L(a)&#x3D;{a}，来表示匹配a这个字符，L指的是正则表达式标识符，括号里面可以存放正则表达式"></a>正则表达式使用L(a)&#x3D;{a}，来表示匹配a这个字符，L指的是正则表达式标识符，括号里面可以存放正则表达式</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606173335536.png" alt="image-20240606173335536"></p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606173958856.png" alt="image-20240606173958856"></p><h3 id="无法用正则表达式产生"><a href="#无法用正则表达式产生" class="headerlink" title="无法用正则表达式产生"></a>无法用正则表达式产生</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606180241175.png" alt="image-20240606180241175"></p><h3 id="正闭包"><a href="#正闭包" class="headerlink" title="正闭包"></a>正闭包</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606200322379.png" alt="image-20240606200322379"></p><h3 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606200350286.png" alt="image-20240606200350286"></p><h3 id="任意符号"><a href="#任意符号" class="headerlink" title="任意符号"></a>任意符号</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606201023506.png" alt="image-20240606201023506"></p><h3 id="非号"><a href="#非号" class="headerlink" title="非号"></a>非号</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606201108203.png" alt="image-20240606201108203"></p><h3 id="十进制数的正则表达式"><a href="#十进制数的正则表达式" class="headerlink" title="十进制数的正则表达式"></a>十进制数的正则表达式</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606201943738.png" alt="image-20240606201943738"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux chmod命令教程</title>
      <link href="/hexo-blog/2024/06/06/Linux%20chmod%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"/>
      <url>/hexo-blog/2024/06/06/Linux%20chmod%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-chmod命令教程：如何更改文件和目录的权限（附实例详解和注意事项）"><a href="#Linux-chmod命令教程：如何更改文件和目录的权限（附实例详解和注意事项）" class="headerlink" title="Linux chmod命令教程：如何更改文件和目录的权限（附实例详解和注意事项）"></a>Linux chmod命令教程：如何更改文件和目录的权限（附实例详解和注意事项）</h1><h3 id="Linux-chmod命令介绍"><a href="#Linux-chmod命令介绍" class="headerlink" title="Linux chmod命令介绍"></a>Linux chmod命令介绍</h3><p><code>chmod</code>（全称：change mode）命令是用来更改文件或目录的权限。在Linux&#x2F;Unix中，文件的权限分为三级：文件所有者（Owner）、用户组（Group）、其他用户（Other Users）。只有文件所有者和超级用户可以修改文件或目录的权限。</p><h3 id="Linux-chmod命令适用的Linux版本"><a href="#Linux-chmod命令适用的Linux版本" class="headerlink" title="Linux chmod命令适用的Linux版本"></a>Linux chmod命令适用的Linux版本</h3><p><code>chmod</code>命令在所有主流的Linux发行版中都是可用的，包括但不限于Debian、Ubuntu、Alpine、Arch Linux、Kali Linux、RedHat&#x2F;CentOS、Fedora、Raspbian等。如果某个Linux发行版中没有预装<code>chmod</code>命令，用户可以通过该发行版的包管理器（如apt、yum、dnf、pacman等）来安装。</p><p>例如，在Debian或Ubuntu上，可以使用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo apt-get update</span><br><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo apt-get install coreutils</span><br></pre></td></tr></table></figure><p>在CentOS 7上，可以使用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo yum update</span><br><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo yum install coreutils</span><br></pre></td></tr></table></figure><p>在CentOS 8上，可以使用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo dnf update</span><br><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo dnf install coreutils</span><br></pre></td></tr></table></figure><h3 id="Linux-chmod命令的基本语法"><a href="#Linux-chmod命令的基本语法" class="headerlink" title="Linux chmod命令的基本语法"></a>Linux chmod命令的基本语法</h3><p><code>chmod</code>命令的基本语法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [options] mode file...</span><br></pre></td></tr></table></figure><p>其中，<code>mode</code>是权限设定字符串，<code>file</code>是要更改权限的文件或目录。</p><h3 id="Linux-chmod命令的常用选项或参数说明"><a href="#Linux-chmod命令的常用选项或参数说明" class="headerlink" title="Linux chmod命令的常用选项或参数说明"></a>Linux chmod命令的常用选项或参数说明</h3><p><strong>以下是<code>chmod</code>命令的一些常用选项：</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-R</td><td>对当前目录及其子目录进行递归更改</td></tr><tr><td>-c</td><td>只有在文件权限确实更改时才显示其更改动作</td></tr><tr><td>-f</td><td>如果文件权限无法更改，不显示错误信息</td></tr><tr><td>-v</td><td>显示权限变更的详细信息</td></tr></tbody></table><h3 id="Linux-chmod命令实例详解"><a href="#Linux-chmod命令实例详解" class="headerlink" title="Linux chmod命令实例详解"></a>Linux chmod命令实例详解</h3><h4 id="实例1：更改文件权限"><a href="#实例1：更改文件权限" class="headerlink" title="实例1：更改文件权限"></a>实例1：更改文件权限</h4><p>假设我们有一个名为<code>file1.txt</code>的文件，我们想要给所有用户增加读取权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod a+r file1.txt</span><br></pre></td></tr></table></figure><p>这个命令将给<code>file1.txt</code>的所有用户增加读取权限。</p><h4 id="实例2：删除执行权限"><a href="#实例2：删除执行权限" class="headerlink" title="实例2：删除执行权限"></a>实例2：删除执行权限</h4><p>如果我们想要删除所有用户对<code>file1.txt</code>的执行权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod a-x file1.txt</span><br></pre></td></tr></table></figure><p>这个命令将删除所有用户对<code>file1.txt</code>的执行权限。</p><h4 id="实例3：递归更改目录权限"><a href="#实例3：递归更改目录权限" class="headerlink" title="实例3：递归更改目录权限"></a>实例3：递归更改目录权限</h4><p>如果我们想要递归地给一个目录及其所有子目录和文件增加读取权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod -R a+r directory</span><br></pre></td></tr></table></figure><p>这个命令将给<code>directory</code>及其所有子目录和文件的所有用户增加读取权限。</p><h4 id="实例4：设置特定权限"><a href="#实例4：设置特定权限" class="headerlink" title="实例4：设置特定权限"></a>实例4：设置特定权限</h4><p>假如我们希望设置文件所有者具有读取、写入和执行权限（rwx），其他用户则仅有读取权限（r），可以用数值方式表示，并使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod 744 file1.txt</span><br></pre></td></tr></table></figure><p>这个命令设置<code>file1.txt</code>的权限，使得文件所有者具有读取、写入和执行权限，其他用户则仅有读取权限。</p><h4 id="实例5：用符号表示法设置权位"><a href="#实例5：用符号表示法设置权位" class="headerlink" title="实例5：用符号表示法设置权位"></a>实例5：用符号表示法设置权位</h4><p>我们同时还可以以user，group，others的形式使用符号来赋予文件权限。例如，我们希望给文件所有者增加执行权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod u+x file1.txt</span><br></pre></td></tr></table></figure><p>这个命令将给<code>file1.txt</code>的文件所有者增加执行权限。</p><h4 id="实例6：以符号表示法删除权限"><a href="#实例6：以符号表示法删除权限" class="headerlink" title="实例6：以符号表示法删除权限"></a>实例6：以符号表示法删除权限</h4><p>假如我们想移除文件组的写入权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod g-w file1.txt</span><br></pre></td></tr></table></figure><p>这个命令将移除<code>file1.txt</code>的文件组写入权限。</p><h4 id="实例7-同时设置用户组和其他用户权限"><a href="#实例7-同时设置用户组和其他用户权限" class="headerlink" title="实例7: 同时设置用户组和其他用户权限"></a>实例7: 同时设置用户组和其他用户权限</h4><p>如果想要同时设置用户组（g）和其他用户（o）的权限，可以使用逗号将它们分开。例如，如果希望给用户组增加写权限，并给其他用户增加读权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod g+w,o+r file1.txt</span><br></pre></td></tr></table></figure><p>此命令将给<code>file1.txt</code>的用户组增加写权限，并给其他用户增加读权限。</p><h4 id="实例8：赋予所有权限"><a href="#实例8：赋予所有权限" class="headerlink" title="实例8：赋予所有权限"></a>实例8：赋予所有权限</h4><p>如果我们希望赋予文件所有用户所有权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod 777 file1.txt</span><br></pre></td></tr></table></figure><p>此命令将赋予<code>file1.txt</code>所有用户（用户组和其他用户）所有的读取、写入和执行权限。</p><h4 id="实例9：移除所有权限"><a href="#实例9：移除所有权限" class="headerlink" title="实例9：移除所有权限"></a>实例9：移除所有权限</h4><p>反之，如果我们希望移除文件的所有权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod 000 file1.txt</span><br></pre></td></tr></table></figure><p>此命令将移除<code>file1.txt</code>所有用户（用户组和其他用户）的所有权限，即无法进行读取、写入或执行该文件。</p><h3 id="Linux-chmod命令的注意事项"><a href="#Linux-chmod命令的注意事项" class="headerlink" title="Linux chmod命令的注意事项"></a>Linux chmod命令的注意事项</h3><ul><li>使用<code>chmod</code>命令时，需要注意文件的所有者和当前用户的关系。只有文件的所有者和超级用户可以更改文件的权限。</li><li>在使用<code>chmod</code>命令时，如果遇到<code>bash: chmod: command not found</code>的错误，可以按照上面的方法安装<code>chmod</code>命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理复习词法分析(一)</title>
      <link href="/hexo-blog/2024/06/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
      <url>/hexo-blog/2024/06/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理复习词法分析-一"><a href="#编译原理复习词法分析-一" class="headerlink" title="编译原理复习词法分析(一)"></a>编译原理复习词法分析(一)</h1><h3 id="扫描程序"><a href="#扫描程序" class="headerlink" title="扫描程序"></a>扫描程序</h3><p>每扫一个字符拿去做判断，标识符(变量)存在字符数组里，记号(token)存在字符里</p><h3 id="不同语言的跨平台性"><a href="#不同语言的跨平台性" class="headerlink" title="不同语言的跨平台性"></a>不同语言的跨平台性</h3><p>比如说：</p><ul><li>C++ 需要编译成目标代码，与CPU指令组成，可以直接运行，缺点是跨平台性差，需要相应环境，优点的运行效率快</li><li>Python，直接使用解释器，读一行源程序，翻译成结果，缺点是效率低下，优点是跨平台性较好</li><li>Java，使用JVM虚拟机，虚拟机内将java代码编译成目标代码(不是CPU指令)，再通过解释器形成结果，结合了以上两种方式，跨平台性非常好</li></ul><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90(%E4%B8%80)/image-20240606163557134.png" alt="image-20240606163557134"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统的覆盖与交换</title>
      <link href="/hexo-blog/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/"/>
      <url>/hexo-blog/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的覆盖与交换"><a href="#操作系统的覆盖与交换" class="headerlink" title="操作系统的覆盖与交换"></a>操作系统的覆盖与交换</h1><p><img src="/hexo-blog/./img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/image-20240605170027339.png"></p><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p>覆盖技术是指一个程序的若干程序段和几个程序的某些部分共享一个存储空间。覆盖技术的实现是把程序分为若干个功能上相对独立的程序，按照其自身的逻辑结构使那些不会同时执行的程序段共享同一块内存区域。未执行的程序段先保存在磁盘上，当有关程序段的前一部分执行结束后，把后续程序段调入内存，覆盖前面的程序段。</p><p>覆盖技术是用户程序自己附加的控制。要把一个程序划分成不同的程序段，并规定好他们的执行和覆盖顺序。操作系统则根据程序员提供的覆盖结构，完成程序段之间的覆盖。</p><p>该程序正文段所需要的内存空间是A（8KB）+B（8KB）+C（10KB）+D（12KB）+E（4KB）+F（10KB）&#x3D;52KB，但是在采用了覆盖技术后只需要A（8KB）+C（10KB）+D（12KB）&#x3D;30KB占用空间。</p><p><img src="/hexo-blog/./img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/2070dd8b6a6127f2e072d2b09c37cf77.png" alt="img"></p><p>覆盖技术主要用于系统程序的内存管理上，MS-DOS系统分为两个部分。</p><ul><li>操作系统中经常要用到的基本部分，它们常驻在内存且占用固定区域。</li><li>不太经常使用的部分，它们存放在磁盘上，当调用它们时才被调入内存覆盖区。</li></ul><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>交换技术：在分时系统中，用户的进程比内存能容纳的数量要多，这就需要在磁盘上保存那些内存放不下的进程。在需要运行这些进程时，再将它们装入内存。</p><p>进程从内存移到磁盘并再移动回内存称为交换。交换技术是进程在内存与外存之间的动态调度，是由操作系统控制的。</p><p>后备存储区（又称盘交换区）。</p><p>目的：尽可能达到”足够快的交换进程，以使当CPU调度程序想重新调度CPU时，总有进程在内存中处于就绪（准备执行）状态“的理想状态，从而提高内存利用率。</p><p><strong>交换技术的原理：</strong></p><p>（1）换出进程的选择：系统需要将内存中的进程换出时，应该选择那个进程？</p><p>根据时间片轮转法或基于优先数的调度算法来选择要换出的进程。</p><p>（2）交换时间的确定</p><p>在内存空间不够或有不够的危险时，还出内存中的部分进程到外存，以释放所需要的内存。</p><p>（3）交换空间的分配</p><p>在一些系统中，当进程在内存中时，不再外塔分配磁盘空间。当它被换出时，必须为它分配磁盘交换空间。</p><p>在另一些系统中，进程一但创建，就分配给它磁盘上的交换空间。无论何时程序被换出，他都被换到已经为它分配的空间，而不是每次换到不同的空间。</p><p>（4）换入进程换回内存时位置的确定</p><p>绝对地址：在原来的位置上；</p><p>相对地址：可再进行地址重定位。</p><p>交换技术的缺点：</p><p>由于交换时需要花费大量的CPU时间，这将影响对用户的响应时间，因此，减少交换的信息量是交换技术的关键问题。</p><p>合理的做法：</p><p>在外存中保留每个程序的交换副本，换出时仅将执行时修改过的部分复制到外存。</p><p><strong>覆盖技术和交换技术的发展导致了虚拟存储技术的出现。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理的概念</title>
      <link href="/hexo-blog/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/hexo-blog/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h1><p><img src="/hexo-blog/./img/note/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20240605150316382.png" alt="image-20240605150316382"></p><h3 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h3><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><ul><li><strong>连续分配管理</strong>：早期的内存管理方法，如单一连续分配、固定分区、可变分区等，通过系统保留表跟踪哪些内存块已被分配或空闲，然后为进程分配连续的内存区域。</li><li><strong>非连续分配管理</strong>：如分页（Page）和分段（Segmentation）机制，以及两者的结合（段页式），操作系统将物理内存分割成固定大小的页或可变大小的段，为每个进程建立虚拟地址到物理地址的映射，从而实现了灵活的内存分配和保护。</li></ul><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><ul><li>当进程结束或不再需要某些内存时，操作系统负责回收这些内存空间，更新内存分配表，使其标记为可用状态，并可能合并相邻的空闲块以减少碎片。</li></ul><h3 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h3><h4 id="计算机物理内存（RAM）扩充"><a href="#计算机物理内存（RAM）扩充" class="headerlink" title="计算机物理内存（RAM）扩充"></a>计算机物理内存（RAM）扩充</h4><ol><li><strong>增加内存条</strong>：这是最直接的方式，购买与主板兼容的内存条并安装到空闲的内存插槽中。需要确保新内存条的规格（如DDR代数、频率、电压等）与现有内存相匹配。</li><li><strong>使用内存扩展技术</strong>：某些现代笔记本或主板支持特殊的内存扩展技术，如Intel的Optane Memory，虽不是直接增加RAM，但可以加速访问常用的数据和提升系统响应速度。</li></ol><h4 id="虚拟内存扩充"><a href="#虚拟内存扩充" class="headerlink" title="虚拟内存扩充"></a>虚拟内存扩充</h4><ol><li><strong>调整虚拟内存设置</strong>：在操作系统中，可以通过设置增大虚拟内存（页面文件）的大小，将一部分硬盘空间作为额外的内存使用。虽然这能暂时缓解物理内存不足的问题，但因硬盘速度远慢于RAM，可能会导致系统运行变慢。</li><li><strong>使用Swap分区</strong>：在Linux系统中，可以通过创建或调整Swap分区大小来扩充虚拟内存。Swap分区充当物理内存的补充，当物理内存耗尽时，操作系统会将部分内存数据暂时移到Swap分区。</li></ol><h4 id="移动设备（如手机）存储空间扩充"><a href="#移动设备（如手机）存储空间扩充" class="headerlink" title="移动设备（如手机）存储空间扩充"></a>移动设备（如手机）存储空间扩充</h4><ol><li><p><strong>外部存储卡</strong>：如果设备支持，可以插入microSD卡或nanoSD卡等外部存储卡来增加存储空间。注意，这一般只增加存储空间，而非运行内存（RAM）。</p></li><li><p><strong>云存储服务</strong>：使用云存储服务（如Google云端硬盘、iCloud、百度网盘等）备份照片、视频和文档，释放本地存储空间。</p></li><li><p><strong>内存清理与优化</strong>：通过清理缓存、卸载不常用应用、转移文件到云存储等方式，有效管理现有存储空间，间接“扩充”可用空间。</p></li></ol><blockquote><p>假如说我现在电脑下了22.04的ubuntu系统，我分配给他的是4GB物理内存，30GB固态内存。</p><p>我在虚拟机上下载了过多软件，导致物理内存超过了4GB，然后需要在虚拟机上借用部分虚拟内存，来自磁盘(30GB)来保证虚拟机的正常运行</p></blockquote><h3 id="内存的地址转换"><a href="#内存的地址转换" class="headerlink" title="内存的地址转换"></a>内存的地址转换</h3><p>在操作系统中，程序的装入方式是内存管理的一个重要方面，不同的装入方式对应着不同的程序执行环境和内存管理策略。以下是三种经典的程序装入方式：</p><h4 id="1-绝对装入（Absolute-Loading）"><a href="#1-绝对装入（Absolute-Loading）" class="headerlink" title="1. 绝对装入（Absolute Loading）"></a>1. 绝对装入（Absolute Loading）</h4><p><strong>定义</strong>：绝对装入方式是指在编译时就确定了程序将要驻留在内存中的物理地址。程序的目标代码中所使用的地址都是物理内存的绝对地址，没有相对地址或虚拟地址的概念。</p><p><strong>特点</strong>：</p><ul><li>简单直接，不需要在程序执行时进行地址转换。</li><li>编译时就必须知道确切的内存位置，限制了程序的灵活性和系统的并发能力。</li><li>仅适用于单任务、无虚拟内存的操作系统环境。</li></ul><h4 id="2-可重定位装入（Relocatable-Loading）"><a href="#2-可重定位装入（Relocatable-Loading）" class="headerlink" title="2. 可重定位装入（Relocatable Loading）"></a>2. 可重定位装入（Relocatable Loading）</h4><p><strong>定义</strong>：可重定位装入方式允许程序在编译时使用相对地址（或基址加上偏移量的形式），而不是绝对地址。在程序装入内存时，操作系统会根据实际分配给程序的内存起始地址对程序的所有地址引用进行统一调整（重定位），使得程序可以在不同的内存位置正确执行。</p><p><strong>特点</strong>：</p><ul><li>提高了程序的灵活性和可移植性，支持程序在不同内存配置的环境中运行。</li><li>需要在程序首次装入内存或在内存中移动时进行地址重定位操作。</li><li>支持多道程序设计，但程序运行前必须全部装入内存。</li></ul><h4 id="3-动态运行时装入（Dynamic-Run-Time-Loading）"><a href="#3-动态运行时装入（Dynamic-Run-Time-Loading）" class="headerlink" title="3. 动态运行时装入（Dynamic Run-Time Loading）"></a>3. 动态运行时装入（Dynamic Run-Time Loading）</h4><p><strong>定义</strong>：动态运行时装入方式是指程序在开始执行之前不必全部装入内存，而是在程序运行过程中，根据需要将代码和数据段逐步调入内存。这种机制允许程序的某些部分（如很少使用的模块）保留在外存上，直到真正需要时才加载到内存。</p><p><strong>特点</strong>：</p><ul><li>大幅节省了内存空间，提高了内存利用率，支持更大规模的程序执行。</li><li>支持按需加载和动态链接库（DLLs或SOs），增强了程序的灵活性和扩展性。</li><li>需要复杂的内存管理和虚拟内存支持，操作系统需维护内存分配表，跟踪已装入和未装入的部分。</li><li>增加了程序执行的开销，因为频繁的页面置换可能导致额外的磁盘I&#x2F;O和处理时间。</li></ul><p>总结来说，绝对装入是最简单但最不灵活的方式；可重定位装入提升了程序的灵活性；而动态运行时装入则进一步提高了内存效率和程序的动态扩展能力，是现代操作系统中普遍采用的内存管理技术。</p><h3 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h3><p>界地址寄存器（Bound Register）是计算机系统中用于实现存储保护的一种硬件机制，特别是在较早的计算机体系结构中较为常见。界地址寄存器主要用于限制进程访问内存的范围，防止进程越界访问其他进程或系统内存区域。以下是设置界地址寄存器的基本概念和步骤：</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ol><li><strong>下限寄存器（Lower Bound Register）</strong>：存储进程地址空间的最低地址。</li><li><strong>上限寄存器（Upper Bound Register）</strong>：存储进程地址空间的最高地址。</li><li><strong>访问检查</strong>：每当CPU发出一个内存访问请求时，硬件会自动将请求的地址与这两个寄存器的值进行比较。</li><li><strong>越界处理</strong>：如果请求的地址低于下限寄存器的值或者高于上限寄存器的值，说明访问越界，硬件将产生一个越界中断（存储保护中断），操作系统接收到这个中断后会采取相应的错误处理措施，比如终止该进程。</li></ol><h4 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h4><ol><li><p><strong>初始化</strong>：在进程切换时，操作系统会根据进程的内存分配情况，将该进程在内存中的起始地址加载到下限寄存器，结束地址加载到上限寄存器。这通常发生在进程调度时，确保每个新运行的进程都有正确的界限设置。</p></li><li><p><strong>硬件集成</strong>：界地址检查功能通常集成在CPU的内存管理硬件中，因此设置界限寄存器的操作对程序员来说是透明的，由操作系统内核完成。</p></li><li><p><strong>动态调整</strong>：在某些系统中，如果进程的地址空间在运行时动态变化（比如通过分配或释放内存），操作系统需要更新这些寄存器的值以反映新的地址边界。</p></li><li><p><strong>中断处理</strong>：操作系统还需要编写中断处理程序来响应越界中断，处理程序会决定如何响应这一错误，比如记录日志、通知用户、或者终止进程。</p></li></ol><p>随着技术的发展，现代处理器和操作系统更多采用分页和分段机制来实现更灵活的内存管理和保护，界地址寄存器的使用相对减少，但其基本思想仍体现在现代存储保护机制中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go中string转int</title>
      <link href="/hexo-blog/2024/06/04/go%E4%B8%ADstring%E8%BD%ACint/"/>
      <url>/hexo-blog/2024/06/04/go%E4%B8%ADstring%E8%BD%ACint/</url>
      
        <content type="html"><![CDATA[<h3 id="strconv-包"><a href="#strconv-包" class="headerlink" title="strconv 包"></a>strconv 包</h3><p><code>strconv.Atoi</code> 的读法是 “strconv Atoi”。</p><p>这里稍微解释一下每个部分：</p><ul><li><code>strconv</code> 是一个包名，在 Go 语言中，<code>strconv</code> 包提供了用于字符串和基本数值类型之间转换的函数，它的全称是 “String to Integer Conversion Package”。</li><li><code>Atoi</code> 是函数名，其中 <code>Atoi</code> 是从英文 “ASCII to Integer” 缩写而来，表示将 ASCII 字符串转换成整数（integer）。在 Go 语言中，<code>Atoi</code> 函数用于将一个表示十进制整数的字符串转换为 <code>int</code> 类型的整数。</li></ul><p>因此，当你在读这段代码时，你可以这样说：“使用 strconv 包的 Atoi 函数”。在口语中，你可能会简化为：“使用 strconv 的 Atoi 函数”。</p><p>在 Go 语言中，你可以使用<code>strconv</code>包里的函数来实现<code>string</code>类型到<code>int</code>类型或者更具体的整数类型的转换。以下是几种常见的转换方式：</p><ol><li><p><strong>转换为<code>int</code>类型</strong>:<br>使用<code>Atoi</code>函数可以将字符串转换为<code>int</code>类型，但是它只能处理没有超出<code>int</code>范围的数字，并且不支持负数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;123&quot;</span></span><br><span class="line">    i, err := strconv.Atoi(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>转换为<code>int64</code>类型</strong>:<br>使用<code>ParseInt</code>函数可以将字符串转换为<code>int64</code>类型，并且可以指定基数和位宽。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;123456&quot;</span></span><br><span class="line">    i, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>转换为<code>int32</code>类型</strong>:<br>类似地，你也可以使用<code>ParseInt</code>函数，只是在位宽参数处指定<code>32</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure></li></ol><p>这些函数都会返回一个错误值<code>err</code>，如果转换失败（例如，字符串不是有效的数字），你需要检查这个错误并处理它。通常的做法是使用<code>if err != nil</code>来判断是否有错误发生。如果字符串包含非数字字符或无法解析的格式，<code>err</code>将被设置，因此必须检查<code>err</code>以避免程序崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go中解决类型别名与原始类型不匹配的问题</title>
      <link href="/hexo-blog/2024/06/04/go%E4%B8%AD%E8%A7%A3%E5%86%B3%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/hexo-blog/2024/06/04/go%E4%B8%AD%E8%A7%A3%E5%86%B3%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="GoLang中解决类型别名与原始类型不匹配的问题"><a href="#GoLang中解决类型别名与原始类型不匹配的问题" class="headerlink" title="GoLang中解决类型别名与原始类型不匹配的问题"></a>GoLang中解决类型别名与原始类型不匹配的问题</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在Go项目中，我们可能会遇到使用类型别名来封装或简化某些类型定义的情况。例如，在DAO层为了代码组织或接口清晰，可能会对原始类型进行别名定义。然而，当在Service层或其他层级试图使用原始类型时，由于Go的强类型系统，即使类型别名和原始类型具有相同的结构，也会遇到类型不匹配的错误。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>假设在DAO层定义了一个类型别名<code>Content</code>，它是<code>models.ContentModel</code>的别名。但在Service层，我们尝试返回或使用<code>models.ContentModel</code>类型时，会遇到编译错误，提示类型不匹配。</p><h4 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h4><p><strong>ArticleDao.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Content models.ContentModel</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao *ArticleDaoImpl)</span></span> GetContent(id <span class="type">int</span>) Content &#123;</span><br><span class="line"><span class="keyword">var</span> content Content</span><br><span class="line"><span class="keyword">var</span> article = models.ArticleModel&#123;ID: id&#125;</span><br></pre></td></tr></table></figure><p><strong>ArticleService.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(service *ArticleServiceImpl)</span></span> GetContent(id <span class="type">int</span>) models.ContentModel &#123;</span><br><span class="line">    <span class="keyword">return</span> service.dao.GetContent(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：类型转换"><a href="#方案一：类型转换" class="headerlink" title="方案一：类型转换"></a>方案一：类型转换</h5><p>在Service层，可以通过类型转换的方式，将从DAO层获取的<code>Content</code>类型转换为<code>models.ContentModel</code>类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(service *ArticleServiceImpl)</span></span> GetContent(id <span class="type">int</span>) models.ContentModel &#123;</span><br><span class="line">    content := service.dao.GetContent(id) <span class="comment">// 此处content类型为Content</span></span><br><span class="line">    <span class="keyword">return</span> models.ContentModel(content)  <span class="comment">// 将Content转换为models.ContentModel</span></span><br><span class="line">&#125; </span><br><span class="line">OR</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(service *ArticleServiceImpl)</span></span> GetContent(id <span class="type">int</span>) dao.Content &#123;</span><br><span class="line"><span class="keyword">return</span> service.dao.GetContent(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方案二：统一类型使用"><a href="#方案二：统一类型使用" class="headerlink" title="方案二：统一类型使用"></a>方案二：统一类型使用</h5><p>更好的实践是在整个项目中统一使用一种类型。这意味着，如果在DAO层使用了<code>Content</code>作为类型别名，那么在Service层也应该使用<code>Content</code>类型。或者，如果决定使用<code>models.ContentModel</code>，则DAO层的<code>GetContent</code>方法应该返回<code>models.ContentModel</code>类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao *ArticleDaoImpl)</span></span> GetContent(id <span class="type">int</span>) models.ContentModel &#123;</span><br><span class="line">    <span class="keyword">var</span> content models.ContentModel</span><br><span class="line">    <span class="keyword">var</span> article = models.ArticleModel&#123;ID: id&#125;</span><br><span class="line">    dao.DB.Model(&amp;article).Association(<span class="string">&quot;ContentModel&quot;</span>).Find(&amp;content)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，Service层可以直接接收<code>models.ContentModel</code>类型，无需进行额外的类型转换。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在Go项目中，虽然类型别名可以提供代码的清晰度和可读性，但在跨层使用时需要特别注意类型匹配问题。通过类型转换或统一类型使用，我们可以有效地解决类型不匹配的问题，确保项目的顺利运行和代码的高质量。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过以上修改，可以有效解决由类型别名引起的类型不匹配问题，确保代码的正确性和一致性。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法</title>
      <link href="/hexo-blog/2024/06/03/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
      <url>/hexo-blog/2024/06/03/%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h3 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h3><p><img src="/hexo-blog/./img/note/%E5%88%86%E6%B2%BB%E6%B3%95/2024-06-03-20-37-08-image.png" alt="2024-06-03-20-37-08-image"></p><h3 id="分治算法的基本思想"><a href="#分治算法的基本思想" class="headerlink" title="分治算法的基本思想"></a>分治算法的基本思想</h3><p><img src="/hexo-blog/./img/note/%E5%88%86%E6%B2%BB%E6%B3%95/2024-06-03-20-49-05-image.png" alt="2024-06-03-20-49-05-image"></p><h3 id="Karatsuba算法：大整数乘法的优化算法"><a href="#Karatsuba算法：大整数乘法的优化算法" class="headerlink" title="Karatsuba算法：大整数乘法的优化算法"></a>Karatsuba算法：大整数乘法的优化算法</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>Karatsuba算法是一种高效的大数乘法技术，它通过递归地分割输入数并使用较少的基本乘法步骤来计算结果，从而显著减少了计算时间。</p><h4 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h4><h5 id="分割输入数"><a href="#分割输入数" class="headerlink" title="分割输入数"></a>分割输入数</h5><p>当计算两个大数<code>A</code>和<code>B</code>的乘积时，首先将每个数分为两部分：</p><ul><li><code>A</code>分为<code>A高位</code>和<code>A低位</code></li><li><code>B</code>分为<code>B高位</code>和<code>B低位</code></li></ul><p>假设<code>A</code>和<code>B</code>都是偶数位数，可以表示为：</p><p>A &#x3D; A高位 * 10^(n&#x2F;2) + A低位<br>B &#x3D; B高位 * 10^(n&#x2F;2) + B低位</p><p>其中<code>n</code>是数的总位数。</p><h5 id="减少乘法次数"><a href="#减少乘法次数" class="headerlink" title="减少乘法次数"></a>减少乘法次数</h5><p>常规乘法需要计算四个乘积：</p><ol><li><code>A高位 * B高位</code></li><li><code>A高位 * B低位</code></li><li><code>A低位 * B高位</code></li><li><code>A低位 * B低位</code></li></ol><p>然而，Karatsuba算法巧妙地利用代数恒等式，只需计算三个乘积：</p><ul><li><code>P1 = A高位 * B高位</code></li><li><code>P2 = A低位 * B低位</code></li><li><code>P3 = (A高位 + A低位) * (B高位 + B低位)</code></li></ul><p>然后，原式中的中间项可以表示为<code>P3 - P1 - P2</code>，因此我们有：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AB = P1 * 10^n + (P3 - P1 - P2) * 10^(n/2) + P2</span><br></pre></td></tr></table></figure><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>通过这种方法，Karatsuba算法成功地将所需的乘法次数从五项减少到了三项，大大提高了大数乘法的效率。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取大整数的前后半部分并返回</span></span><br><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">get</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = num / <span class="built_in">pow</span>(<span class="number">10</span>, length / <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> num2 = num - num1 * <span class="built_in">pow</span>(<span class="number">10</span>, length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_tuple</span>(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大整数乘法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Karatsuba</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [a1, a2] = <span class="built_in">get</span>(A, length);</span><br><span class="line">    <span class="keyword">auto</span> [b1, b2] = <span class="built_in">get</span>(B, length);</span><br><span class="line">    <span class="keyword">auto</span> [P1, P2, P3] = <span class="built_in">make_tuple</span>(a1 * b1, (a1 + a2) * (b1 + b2), a2 * b2);</span><br><span class="line">    cout &lt;&lt; <span class="function">P1 * <span class="title">pow</span><span class="params">(<span class="number">10</span>, length)</span> + <span class="params">(P2 - P1 - P3)</span> * <span class="title">pow</span><span class="params">(<span class="number">10</span>, length / <span class="number">2</span>)</span> + P3 &lt;&lt; endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的基本概念</title>
      <link href="/hexo-blog/2024/06/03/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/hexo-blog/2024/06/03/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="算法的基本的概念"><a href="#算法的基本的概念" class="headerlink" title="算法的基本的概念"></a>算法的基本的概念</h1><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote><p>0个及以上输入</p><p>1个及以上输出</p><p>有穷性(不存在死循环)</p><p>确定性(每次执行的结果一样)</p><p>可行性(不会爆出警告)</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="渐进复杂性"><a href="#渐进复杂性" class="headerlink" title="渐进复杂性"></a>渐进复杂性</h3><p><img src="/hexo-blog/./img/note/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2024-06-03-20-17-45-image.png" alt="2024-06-03-20-17-45-image"></p><h3 id="渐进记号"><a href="#渐进记号" class="headerlink" title="渐进记号"></a>渐进记号</h3><p><img src="/hexo-blog/./img/note/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2024-06-03-20-15-54-image.png" alt="2024-06-03-20-15-54-image"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出去吃牛肉自助</title>
      <link href="/hexo-blog/2024/06/03/%E5%87%BA%E5%8E%BB%E5%90%83%E7%89%9B%E8%82%89%E8%87%AA%E5%8A%A9/"/>
      <url>/hexo-blog/2024/06/03/%E5%87%BA%E5%8E%BB%E5%90%83%E7%89%9B%E8%82%89%E8%87%AA%E5%8A%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="出去吃牛肉自助"><a href="#出去吃牛肉自助" class="headerlink" title="出去吃牛肉自助"></a>出去吃牛肉自助</h1><p><img src="/hexo-blog/./img/note/%E5%87%BA%E5%8E%BB%E5%90%83%E7%89%9B%E8%82%89%E8%87%AA%E5%8A%A9/2024-06-03-12-20-54-image.png" alt="2024-06-03-12-20-54-image"></p><p><strong>张哞哞·鲜切牛肉自助火锅(广州高德置地广场店)</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对hexo博客的一些理解</title>
      <link href="/hexo-blog/2024/06/03/%E5%AF%B9hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
      <url>/hexo-blog/2024/06/03/%E5%AF%B9hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="对hexo博客的一些理解"><a href="#对hexo博客的一些理解" class="headerlink" title="对hexo博客的一些理解"></a>对hexo博客的一些理解</h1><h3 id="记录：2024-6-3"><a href="#记录：2024-6-3" class="headerlink" title="记录：2024&#x2F;6&#x2F;3"></a>记录：2024&#x2F;6&#x2F;3</h3><ul><li><p>首先我在接触<strong>hexo</strong>前接触过vuepress，其实两者非常类似</p></li><li><p>相比于vuepress，hexo功能更加全面，不过配置起来更加繁琐</p></li></ul><blockquote><p>  感觉总体还行，只不过都是写静态文件，直接书写简单的markdown，你就能弄一个很好看的网页出来，而且他的背后帮你做了很多事情，比如说路由处理，打包部署，SEO搜索引擎优化等等。但是虽然花里胡哨的样式很多，但也带来了很多缺点，比如引入过多样式会造成页面异常卡顿，数据存在db.json当中，不太好，当数据量一大，数据就加载不过来了。</p><p>  所以还是要理性对待，把他当成日常笔记本来写写就行，部署到GitHub Pages上，非常方便。</p></blockquote><h3 id="vuepress和hexo的对比"><a href="#vuepress和hexo的对比" class="headerlink" title="vuepress和hexo的对比"></a>vuepress和hexo的对比</h3><h6 id="vuepress-文件夹docs下就是网页的根目录，vuepress会根据你的文件路径给你定义路由"><a href="#vuepress-文件夹docs下就是网页的根目录，vuepress会根据你的文件路径给你定义路由" class="headerlink" title="vuepress:文件夹docs下就是网页的根目录，vuepress会根据你的文件路径给你定义路由"></a>vuepress:文件夹docs下就是网页的根目录，vuepress会根据你的文件路径给你定义路由</h6><p>路由在<mark>.vuepress&#x2F;config.js</mark>配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; viteBundler &#125; <span class="keyword">from</span> <span class="string">&#x27;@vuepress/bundler-vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defaultTheme &#125; <span class="keyword">from</span> <span class="string">&#x27;@vuepress/theme-default&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineUserConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vuepress&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineUserConfig</span>(&#123;</span><br><span class="line">  <span class="attr">bundler</span>: <span class="title function_">viteBundler</span>(&#123;</span><br><span class="line">    <span class="attr">viteOptions</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">vuePluginOptions</span>: &#123;&#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">theme</span>: <span class="title function_">defaultTheme</span>(&#123;</span><br><span class="line">    <span class="string">&quot;/note/&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;操作系统&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/操作系统/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Django&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Django/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Docker&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Docker/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Git&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Git/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;OpenGuass&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/openguass/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;uni-app&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/uni-app/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Go&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Go/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Vue&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Vue/&quot;</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    options...</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">lang</span>: <span class="string">&#x27;zh-CN&#x27;</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;学习文档&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;欢迎来到浩瀚星河的小站&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="hexo-统一在-config-butterfly-yml中配置，包含所有的配置信息"><a href="#hexo-统一在-config-butterfly-yml中配置，包含所有的配置信息" class="headerlink" title="hexo:统一在_config.butterfly.yml中配置，包含所有的配置信息"></a>hexo:统一在<mark>_config.butterfly.yml</mark>中配置，包含所有的配置信息</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"><span class="comment"># 背景和图标</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/favicon.png</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/avatar.png</span> <span class="comment">#图片路径</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span> <span class="comment">#头像会一直转圈</span></span><br><span class="line"><span class="comment"># The banner image of home page</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/img/background.jpg</span></span><br><span class="line"><span class="comment"># 文章详情页</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">/img/default_top_img.png</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span> <span class="comment">#  是否展示文章封面</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span> <span class="comment"># 封面展示的位置 left/right/both</span></span><br><span class="line"><span class="attr">error_img:</span></span><br><span class="line">  <span class="attr">flink:</span> <span class="string">/img/friend_404.gif</span></span><br><span class="line">  <span class="attr">post_page:</span> <span class="string">/img/404.jpg</span></span><br><span class="line"><span class="attr">medium_zoom:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># copy settings</span></span><br><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启网站复制权限</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="comment"># 复制的内容后面加上版权信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 是否开启复制版权信息添加</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">50</span> <span class="comment"># 字数限制，当复制文字大于这个字数限制时</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:struggle-upwards/hexo-blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h3 id="两种方式构建"><a href="#两种方式构建" class="headerlink" title="两种方式构建"></a>两种方式构建</h3><p><a href="https://struggle-upwards.github.io/hexo-blog/">我的博客 (hexo)</a><br>        <a href="https://struggle-upwards.github.io/">我的文档 (vuepress)</a></p>]]></content>
      
      
      <categories>
          
          <category> 理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqloj数据库作业</title>
      <link href="/hexo-blog/2024/06/01/sqloj%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A/"/>
      <url>/hexo-blog/2024/06/01/sqloj%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="sqloj数据库作业"><a href="#sqloj数据库作业" class="headerlink" title="sqloj数据库作业"></a>sqloj数据库作业</h1><h2 id="以下是100-正确率"><a href="#以下是100-正确率" class="headerlink" title="以下是100%正确率"></a>以下是100%正确率</h2><h2 id="一-单表查询"><a href="#一-单表查询" class="headerlink" title="一.单表查询"></a>一.单表查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 课程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 学号 <span class="keyword">from</span> 成绩;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> 成绩 <span class="keyword">set</span> 成绩 <span class="operator">=</span> 成绩<span class="operator">+</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> 学号,成绩 <span class="keyword">from</span> 成绩;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 学号 <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 课程号<span class="operator">=</span>&quot;1026&quot; <span class="keyword">and</span> 成绩<span class="operator">&lt;</span><span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 成绩 <span class="keyword">between</span> <span class="number">60</span> <span class="keyword">and</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 成绩 <span class="keyword">in</span> (<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 学生 <span class="keyword">where</span> 姓名 <span class="operator">=</span> &quot;马*&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 成绩 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 学号,姓名,性别 <span class="keyword">from</span> 学生 <span class="keyword">order</span> <span class="keyword">by</span> 学号 <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 学生 <span class="keyword">order</span> <span class="keyword">by</span> 性别 <span class="keyword">asc</span>,学号 <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 学号 <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 课程号 <span class="operator">=</span> &quot;1026&quot; <span class="keyword">order</span> <span class="keyword">by</span> 成绩 limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="二-连接查询"><a href="#二-连接查询" class="headerlink" title="二.连接查询"></a>二.连接查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 学生.学号,学生.姓名 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 成绩.课程号<span class="operator">=</span>&quot;1025&quot; <span class="keyword">order</span> <span class="keyword">by</span> 学号 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 姓名 <span class="keyword">from</span> 课程 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 课程.课程号<span class="operator">=</span>成绩.课程号 <span class="keyword">inner</span> <span class="keyword">join</span> 学生 <span class="keyword">on</span> 成绩.学号<span class="operator">=</span>学生.学号 <span class="keyword">where</span> 课程名<span class="operator">=</span>&quot;数据库&quot; <span class="keyword">order</span> <span class="keyword">by</span> 姓名 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 学生.学号 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 成绩.课程号 <span class="keyword">in</span> (<span class="keyword">select</span> 课程号 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 学生.学号<span class="operator">=</span>&quot;202101231234&quot;) <span class="keyword">order</span> <span class="keyword">by</span> 学生.学号;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 学生.学号,姓名,班级,身份证号,课程号,成绩 <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 成绩.学号<span class="operator">=</span>学生.学号 <span class="keyword">order</span> <span class="keyword">by</span> 学号 <span class="keyword">asc</span>,课程号 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 姓名 <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 姓名 <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> 姓名 <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 课程号<span class="operator">=</span>&quot;1025&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 姓名 <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 成绩 <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(成绩) <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 课程号<span class="operator">=</span>&quot;1025&quot;) <span class="keyword">and</span> 课程号<span class="operator">=</span>&quot;1025&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 成绩 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 姓名<span class="operator">=</span>&quot;贺易&quot; <span class="keyword">and</span> 课程号<span class="operator">=</span>&quot;1025&quot;;</span><br></pre></td></tr></table></figure><h2 id="三-聚合与分组查询"><a href="#三-聚合与分组查询" class="headerlink" title="三.聚合与分组查询"></a>三.聚合与分组查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(身份证号) <span class="keyword">from</span> 学生;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(课程号) <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 姓名<span class="operator">=</span>&quot;张怡&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(成绩) <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 学生.学号<span class="operator">=</span>&quot;202101231234&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(课程号) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> 课程号 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号) <span class="keyword">as</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 课程号,<span class="built_in">avg</span>(成绩) <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">group</span> <span class="keyword">by</span> 课程号 <span class="keyword">order</span> <span class="keyword">by</span> 课程号 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 课程号,<span class="built_in">count</span>(学生.学号) <span class="keyword">as</span> count_num <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">group</span> <span class="keyword">by</span> 课程号 <span class="keyword">having</span> count_num<span class="operator">&gt;=</span><span class="number">5</span> <span class="keyword">order</span> <span class="keyword">by</span> count_num <span class="keyword">desc</span>,课程号 <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><h2 id="四-数据更新"><a href="#四-数据更新" class="headerlink" title="四.数据更新"></a>四.数据更新</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 学号  <span class="operator">=</span>  (<span class="keyword">select</span> 学号 <span class="keyword">from</span> 学生 <span class="keyword">where</span> 姓名 <span class="operator">=</span> &quot;刘玉&quot;);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 学生 <span class="keyword">where</span> 姓名 <span class="operator">=</span> &quot;刘玉&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 成绩  <span class="keyword">where</span> 学号 <span class="keyword">in</span> (<span class="keyword">select</span>  学号 <span class="keyword">from</span> 学生 <span class="keyword">where</span> 班级 <span class="operator">=</span> &quot;21医学院&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 课程 <span class="keyword">values</span>(&quot;1032&quot;,&quot;大学物理&quot;,<span class="number">64</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 学生 <span class="keyword">values</span>(&quot;650307200209225678&quot;,&quot;202101231255&quot;,&quot;陈静&quot;,&quot;女&quot;,<span class="keyword">null</span>,&quot;2001-12-29&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `学生平均分` (</span><br><span class="line">  `学号` <span class="type">varchar</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `平均分` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`学号`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `学生平均分`(`学号`, `平均分`) <span class="keyword">SELECT</span> `学号`,<span class="built_in">AVG</span>(`成绩`) <span class="keyword">AS</span> `平均分` <span class="keyword">FROM</span> `成绩` <span class="keyword">GROUP</span> <span class="keyword">BY</span> `学号`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> 成绩 <span class="keyword">set</span> 成绩<span class="operator">=</span>成绩<span class="operator">+</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> 课程 <span class="keyword">set</span> 课程名<span class="operator">=</span>&quot;大学计算机基础&quot; <span class="keyword">where</span> 课程名<span class="operator">=</span>&quot;计算机基础&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> 成绩 <span class="keyword">set</span> 成绩 <span class="operator">=</span> <span class="number">0</span> <span class="keyword">where</span> 学号 <span class="keyword">in</span> (<span class="keyword">select</span> 学号 <span class="keyword">from</span> 学生 <span class="keyword">where</span> 班级<span class="operator">=</span>&quot;21计算机学院&quot;);</span><br></pre></td></tr></table></figure><h2 id="五-视图管理"><a href="#五-视图管理" class="headerlink" title="五.视图管理"></a>五.视图管理</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CS21_S <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 学生 <span class="keyword">where</span> 班级 <span class="operator">=</span> &quot;21计算机学院&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> S_C_G  <span class="keyword">as</span> <span class="keyword">select</span> 学生.学号,姓名,课程名,成绩 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">inner</span> <span class="keyword">join</span> 课程 <span class="keyword">on</span> 成绩.课程号<span class="operator">=</span>课程.课程号;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> S_C_G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> CS21_S <span class="keyword">where</span> 性别<span class="operator">=</span>&quot;女&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql画er图</title>
      <link href="/hexo-blog/2024/06/01/mysql%E7%94%BBer%E5%9B%BE/"/>
      <url>/hexo-blog/2024/06/01/mysql%E7%94%BBer%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库画er图"><a href="#数据库画er图" class="headerlink" title="数据库画er图"></a>数据库画er图</h1><blockquote><p>根据描述直接在navicat画ER图,生成factory,product,department,employee,telephone,manager一共6张表</p></blockquote><p><strong>ER图</strong></p><p><img src="/hexo-blog/./img/note/mysql%E7%94%BBer%E5%9B%BE/image-20240601213847759.png" alt="image-20240601213847759"></p><p><strong>迁移数据库</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`department`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `depart_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`, `depart_id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`employee`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `job` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `depart_foreign_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`, `depart_foreign_id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`factory`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`manager`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `job` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `depart_foreign_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`, `depart_foreign_id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`product`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`table_1`  ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`telephone`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone_num` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `factory_id` <span class="type">int</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/mysql%E7%94%BBer%E5%9B%BE/1-1717251498794-1.jpg" alt="1-1717251498794-1"></p><blockquote><h3 id="出版社表-publishers"><a href="#出版社表-publishers" class="headerlink" title="出版社表 (publishers)"></a>出版社表 (<code>publishers</code>)</h3><ul><li><code>PublisherID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个出版社。</li><li><code>Name</code>: VARCHAR(255), 出版社名称，不允许为空。</li><li><code>Address</code>: VARCHAR(255), 出版社地址。</li><li><code>Level</code>: ENUM(‘一级’, ‘二级’, ‘三级’), 出版社级别，预定义的几个选项。</li></ul><h3 id="图书表-books"><a href="#图书表-books" class="headerlink" title="图书表 (books)"></a>图书表 (<code>books</code>)</h3><ul><li><code>BookID</code>: INT, 主键, 自增, 不允许为空，唯一标识每本书。</li><li><code>Title</code>: VARCHAR(255), 书名，不允许为空。</li><li><code>ISBN</code>: VARCHAR(13), 国际标准书号，唯一，不允许为空。</li><li><code>Author</code>: VARCHAR(255), 作者名，不允许为空。</li><li><code>PublisherID</code>: INT, 外键，参考<code>publishers</code>表的<code>PublisherID</code>，表示该书的出版社。</li></ul><h3 id="学生表-students"><a href="#学生表-students" class="headerlink" title="学生表 (students)"></a>学生表 (<code>students</code>)</h3><ul><li><code>StudentID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个学生。</li><li><code>Name</code>: VARCHAR(255), 学生姓名，不允许为空。</li><li><code>Birthday</code>: DATE, 学生出生日期，不允许为空。</li></ul><h3 id="图书馆表-libraries"><a href="#图书馆表-libraries" class="headerlink" title="图书馆表 (libraries)"></a>图书馆表 (<code>libraries</code>)</h3><ul><li><code>LibraryID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个图书馆。</li><li><code>Name</code>: VARCHAR(255), 图书馆名称，不允许为空。</li><li><code>Director</code>: VARCHAR(255), 图书馆馆长名称。</li><li><code>UniversityID</code>: INT, 外键，参考<code>universities</code>表的<code>UniversityID</code>，表示图书馆所属的大学。</li></ul><h3 id="大学表-universities"><a href="#大学表-universities" class="headerlink" title="大学表 (universities)"></a>大学表 (<code>universities</code>)</h3><ul><li><code>UniversityID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个大学。</li><li><code>Name</code>: VARCHAR(255), 大学名称，不允许为空。</li><li><code>President</code>: VARCHAR(255), 大学校长名称。</li><li><code>EstablishmentDate</code>: DATE, 大学成立日期，不允许为空。</li></ul><h3 id="系部表-departments"><a href="#系部表-departments" class="headerlink" title="系部表 (departments)"></a>系部表 (<code>departments</code>)</h3><ul><li><code>DepartmentID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个系。</li><li><code>Name</code>: VARCHAR(255), 系部名称，不允许为空。</li><li><code>Dean</code>: VARCHAR(255), 系主任名称。</li><li><code>UniversityID</code>: INT, 外键，参考<code>universities</code>表的<code>UniversityID</code>，表示系部所属的大学。</li></ul><h3 id="班级表-classes"><a href="#班级表-classes" class="headerlink" title="班级表 (classes)"></a>班级表 (<code>classes</code>)</h3><ul><li><code>ClassID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个班级。</li><li><code>ClassName</code>: VARCHAR(255), 班级名称，不允许为空。</li><li><code>HeadTeacher</code>: VARCHAR(255), 班主任名称。</li><li><code>DepartmentID</code>: INT, 外键，参考<code>departments</code>表的<code>DepartmentID</code>，表示班级所属的系部。</li></ul><h3 id="借阅记录表-borrow-records"><a href="#借阅记录表-borrow-records" class="headerlink" title="借阅记录表 (borrow_records)"></a>借阅记录表 (<code>borrow_records</code>)</h3><ul><li><code>RecordID</code>: INT, 主键, 自增, 不允许为空，唯一标识每次借阅记录。</li><li><code>StudentID</code>: INT, 外键，参考<code>students</code>表的<code>StudentID</code>，表示借书的学生。</li><li><code>BookID</code>: INT, 外键，参考<code>books</code>表的<code>BookID</code>，表示被借阅的书籍。</li><li><code>BorrowDate</code>: DATE, 借书日期，不允许为空。</li><li><code>DueDate</code>: DATE, 应还日期，不允许为空。</li><li><code>ReturnDate</code>: DATE, 实际归还日期，允许为空。</li></ul><h3 id="图书馆藏表-library-collections"><a href="#图书馆藏表-library-collections" class="headerlink" title="图书馆藏表 (library_collections)"></a>图书馆藏表 (<code>library_collections</code>)</h3><ul><li><code>CollectionID</code>: INT, 主键, 自增, 不允许为空，唯一标识图书馆的藏书记录。</li><li><code>LibraryID</code>: INT, 外键，参考<code>libraries</code>表的<code>LibraryID</code>，表示藏书所在的图书馆。</li><li><code>BookID</code>: INT, 外键，参考<code>books</code>表的<code>BookID</code>，表示图书馆收藏的书籍。</li><li><code>Quantity</code>: INT, 藏书数量，不允许为空。</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Publishers (</span><br><span class="line">    PublisherID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Address <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    Level ENUM(<span class="string">&#x27;一级&#x27;</span>, <span class="string">&#x27;二级&#x27;</span>, <span class="string">&#x27;三级&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Books (</span><br><span class="line">    BookID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Title <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    ISBN <span class="type">VARCHAR</span>(<span class="number">13</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Author <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    PublisherID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (PublisherID) <span class="keyword">REFERENCES</span> Publishers(PublisherID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Students (</span><br><span class="line">    StudentID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Libraries (</span><br><span class="line">    LibraryID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Director <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    UniversityID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (UniversityID) <span class="keyword">REFERENCES</span> Universities(UniversityID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Universities (</span><br><span class="line">    UniversityID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    President <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    EstablishmentDate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Departments (</span><br><span class="line">    DepartmentID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Dean <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    UniversityID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (UniversityID) <span class="keyword">REFERENCES</span> Universities(UniversityID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Classes (</span><br><span class="line">    ClassID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    ClassName <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    HeadTeacher <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    DepartmentID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (DepartmentID) <span class="keyword">REFERENCES</span> Departments(DepartmentID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> BorrowRecords (</span><br><span class="line">    RecordID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    StudentID <span class="type">INT</span>,</span><br><span class="line">    BookID <span class="type">INT</span>,</span><br><span class="line">    BorrowDate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    DueDate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    ReturnDate <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (StudentID) <span class="keyword">REFERENCES</span> Students(StudentID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (BookID) <span class="keyword">REFERENCES</span> Books(BookID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> LibraryCollections (</span><br><span class="line">    CollectionID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    LibraryID <span class="type">INT</span>,</span><br><span class="line">    BookID <span class="type">INT</span>,</span><br><span class="line">    Quantity <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (LibraryID) <span class="keyword">REFERENCES</span> Libraries(LibraryID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (BookID) <span class="keyword">REFERENCES</span> Books(BookID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Universities <span class="keyword">ADD</span> INDEX idx_UnivName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Publishers <span class="keyword">ADD</span> INDEX idx_PubName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Books <span class="keyword">ADD</span> INDEX idx_ISBN (ISBN);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students <span class="keyword">ADD</span> INDEX idx_StudentName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Libraries <span class="keyword">ADD</span> INDEX idx_LibName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Departments <span class="keyword">ADD</span> INDEX idx_DepName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Classes <span class="keyword">ADD</span> INDEX idx_ClassName (ClassName);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql第三章作业</title>
      <link href="/hexo-blog/2024/06/01/mysql%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
      <url>/hexo-blog/2024/06/01/mysql%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章PPT作业"><a href="#第三章PPT作业" class="headerlink" title="第三章PPT作业"></a>第三章PPT作业</h1><p><img src="/hexo-blog/./img/note/mysql%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BD%9C%E4%B8%9A/20240601mysql.png" alt="20240601mysql"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 学号 <span class="keyword">FROM</span> `成绩` <span class="keyword">WHERE</span> 课程号<span class="operator">=</span>&quot;1025&quot; <span class="keyword">AND</span> 成绩<span class="operator">&lt;</span><span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `学生` <span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> &quot;马%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 学号 <span class="keyword">FROM</span> `成绩` <span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号 <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(课程号)<span class="operator">&gt;=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 出生日期,年龄 <span class="keyword">FROM</span> `学生`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 学号,<span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> 生日) <span class="keyword">as</span> <span class="keyword">year</span>,<span class="number">2024</span><span class="operator">-</span><span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> 生日) <span class="keyword">as</span> age <span class="keyword">FROM</span> `学生`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 学号 <span class="keyword">FROM</span> 成绩 <span class="keyword">WHERE</span> 成绩<span class="operator">&gt;</span>(<span class="keyword">SELECT</span> 学号 <span class="keyword">from</span> 学生 <span class="keyword">WHERE</span> 姓名<span class="operator">=</span>&quot;刘玉&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm一对一</title>
      <link href="/hexo-blog/2024/06/01/gorm%E4%B8%80%E5%AF%B9%E4%B8%80/"/>
      <url>/hexo-blog/2024/06/01/gorm%E4%B8%80%E5%AF%B9%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="gorm一对一"><a href="#gorm一对一" class="headerlink" title="gorm一对一"></a>gorm一对一</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cuser <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    CompanyID <span class="type">int</span></span><br><span class="line">    Company   Company</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BelongTo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//_ = DB.AutoMigrate(&amp;Cuser&#123;&#125;, &amp;Company&#123;&#125;)</span></span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    user := Cuser&#123;</span><br><span class="line">        Name: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        Company: Company&#123;</span><br><span class="line">            Name: <span class="string">&quot;Company&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    DB.Create(&amp;user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找实例</span></span><br><span class="line">    <span class="keyword">var</span> user1 = Cuser&#123;&#125;</span><br><span class="line">    DB.Preload(<span class="string">&quot;Company&quot;</span>).First(&amp;user1)</span><br><span class="line">    formatPrint(user1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空一对一的关联关系</span></span><br><span class="line">    err := DB.Model(&amp;Cuser&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: user1.ID,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).Association(<span class="string">&quot;Company&quot;</span>).Clear()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;清空关联成功&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一对一的关联关系(需要&amp;)</span></span><br><span class="line">    err = DB.Model(&amp;Cuser&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: user1.ID,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).Association(<span class="string">&quot;Company&quot;</span>).Append(&amp;Company&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;绑定关联成功&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换一对一的关联关系(需要&amp;)</span></span><br><span class="line">    err = DB.Model(&amp;Cuser&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: user1.ID,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).Association(<span class="string">&quot;Company&quot;</span>).Replace(&amp;Company&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;, &amp;Company&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">666</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;替换关联成功&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一对一的关联关系(不需要&amp;)</span></span><br><span class="line">    err = DB.Model(&amp;Cuser&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: user1.ID,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).Association(<span class="string">&quot;Company&quot;</span>).Delete(Company&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">666</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;删除关联成功&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GirlGod <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    DogID <span class="type">int</span></span><br><span class="line">    Dog   Dog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = DB.AutoMigrate(&amp;Dog&#123;&#125;, &amp;GirlGod&#123;&#125;)</span><br><span class="line">    <span class="comment">// 新建数据</span></span><br><span class="line">    d := Dog&#123;</span><br><span class="line">        Name: <span class="string">&quot;舔狗1号&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    g := GirlGod&#123;</span><br><span class="line">        Name: <span class="string">&quot;girl&quot;</span>,</span><br><span class="line">        Dog:  d,</span><br><span class="line">    &#125;</span><br><span class="line">    DB.Create(&amp;g)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空一对一关联</span></span><br><span class="line">    d1 := Dog&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    g1 := GirlGod&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _ = DB.Model(&amp;g1).Association(<span class="string">&quot;Dog&quot;</span>).Clear()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增关联</span></span><br><span class="line">    _ = DB.Model(&amp;g1).Association(<span class="string">&quot;Dog&quot;</span>).Append(&amp;d1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openguass中postgresql的增删改查</title>
      <link href="/hexo-blog/2024/06/01/openguass%E4%B8%ADpostgresql%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
      <url>/hexo-blog/2024/06/01/openguass%E4%B8%ADpostgresql%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="进入数据库"><a href="#进入数据库" class="headerlink" title="进入数据库"></a>进入数据库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gsql postgres</span><br></pre></td></tr></table></figure><h3 id="（1）创建用户："><a href="#（1）创建用户：" class="headerlink" title="（1）创建用户："></a>（1）创建用户：</h3><p><code>create user 用户名 with password &quot;用户密码&quot;;</code></p><h3 id="（2）创建数据库："><a href="#（2）创建数据库：" class="headerlink" title="（2）创建数据库："></a>（2）创建数据库：</h3><p><code>create database 数据库名 owner 用户名;</code></p><h3 id="（3）进入数据库："><a href="#（3）进入数据库：" class="headerlink" title="（3）进入数据库："></a>（3）进入数据库：</h3><p><code>gsql -d 数据库名 -p 15400 -r</code></p><h3 id="（4）创建表："><a href="#（4）创建表：" class="headerlink" title="（4）创建表："></a>（4）创建表：</h3><p><code>create table 表名 (字段名 字段类型,字段名 字段类型);</code><br>例：create table mytable (number int,year int);</p><h3 id="（5）向表中添加数据："><a href="#（5）向表中添加数据：" class="headerlink" title="（5）向表中添加数据："></a>（5）向表中添加数据：</h3><p><code>insert into 表名 values (字段值,字段值);</code><br>例：insert into mytable values (1,100),(2,200);</p><h3 id="（6）查看数据表："><a href="#（6）查看数据表：" class="headerlink" title="（6）查看数据表："></a>（6）查看数据表：</h3><p><code>select * from 表名;</code></p><p>查询pg_tables表获取当前数据库中所有表的信息（pg_tables是系统视图）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from pg_tables</span><br></pre></td></tr></table></figure><p>通常我们只关注public中的表，只需要加上以下查询条件即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select tablename from pg_tables where schemaname=&#x27;public&#x27;</span><br></pre></td></tr></table></figure><h3 id="（7）修改表中数据："><a href="#（7）修改表中数据：" class="headerlink" title="（7）修改表中数据："></a>（7）修改表中数据：</h3><p><code>update 表名 set 字段=修改后的字段值 where 字段=字段值;</code><br>例：update mytable set year&#x3D;300 where number&#x3D;2;</p><h3 id="（8）删除数据表中的数据："><a href="#（8）删除数据表中的数据：" class="headerlink" title="（8）删除数据表中的数据："></a>（8）删除数据表中的数据：</h3><p><code>delete 表名 where 字段=字段值;</code><br>例：delete mytable where number&#x3D;1;</p><h3 id="（9）增加表中的字段："><a href="#（9）增加表中的字段：" class="headerlink" title="（9）增加表中的字段："></a>（9）增加表中的字段：</h3><p><code>alter table 表名 add 字段 字段名;</code><br>例1：alter table mytable add country char;<br>例2：alter table mytable add mail char(20);</p><h3 id="（10）退出数据库："><a href="#（10）退出数据库：" class="headerlink" title="（10）退出数据库："></a>（10）退出数据库：</h3><p><code>\q</code></p><h3 id="（11）查看所有用户："><a href="#（11）查看所有用户：" class="headerlink" title="（11）查看所有用户："></a>（11）查看所有用户：</h3><p><code>\du</code></p><h3 id="（12）查看所有数据库："><a href="#（12）查看所有数据库：" class="headerlink" title="（12）查看所有数据库："></a>（12）查看所有数据库：</h3><p><code>\l</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker命令大全</title>
      <link href="/hexo-blog/2024/06/01/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/hexo-blog/2024/06/01/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#info|version</span></span><br><span class="line">docker info       <span class="comment">#显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker version    <span class="comment">#显示docker的版本信息。</span></span><br><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span> <span class="comment">#帮助命令</span></span><br><span class="line"><span class="comment">#镜像命令</span></span><br><span class="line">docker images <span class="comment">#查看所有本地主机上的镜像 可以使用docker image ls代替</span></span><br><span class="line">docker search <span class="comment">#搜索镜像</span></span><br><span class="line">docker pull <span class="comment">#下载镜像 docker image pull</span></span><br><span class="line">docker rmi <span class="comment">#删除镜像 docker image rm</span></span><br><span class="line"><span class="comment">#容器命令</span></span><br><span class="line">docker run 镜像<span class="built_in">id</span> <span class="comment">#新建容器并启动</span></span><br><span class="line">docker ps 列出所有运行的容器 docker container list</span><br><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span> <span class="comment">#删除指定容器</span></span><br><span class="line"><span class="comment">#删除所有容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -aq)       <span class="comment">#删除所有的容器</span></span><br><span class="line">docker ps -a -q|xargs docker <span class="built_in">rm</span>  <span class="comment">#删除所有的容器</span></span><br><span class="line"><span class="comment">#启动和停止容器</span></span><br><span class="line">docker start 容器<span class="built_in">id</span>    <span class="comment">#启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span>    <span class="comment">#重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>    <span class="comment">#停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span>    <span class="comment">#强制停止当前容器</span></span><br><span class="line"><span class="comment">#退出容器</span></span><br><span class="line"><span class="built_in">exit</span>         <span class="comment">#容器直接退出</span></span><br><span class="line">ctrl +P +Q  <span class="comment">#容器不停止退出     ---注意：这个很有用的操作</span></span><br><span class="line"><span class="comment">#其他常用命令</span></span><br><span class="line">docker run -d 镜像名  <span class="comment">#后台启动命令</span></span><br><span class="line">docker logs         <span class="comment">#查看日志</span></span><br><span class="line">docker top 容器<span class="built_in">id</span>     <span class="comment">#查看容器中进程信息ps</span></span><br><span class="line">docker inspect 容器<span class="built_in">id</span>  <span class="comment">#查看镜像的元数据</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 899c718ac4fe(容器<span class="built_in">id</span>) /bin/bash  <span class="comment">#进入当前容器后开启一个新的终端，可以在里面操作。（常用）</span></span><br><span class="line">docker attach         <span class="comment"># 进入容器正在执行的终端</span></span><br><span class="line">docker <span class="built_in">cp</span> 容器<span class="built_in">id</span>:容器内路径  主机目的路径    <span class="comment">#从容器内拷贝到主机上</span></span><br></pre></td></tr></table></figure><h2 id="docker命令大全"><a href="#docker命令大全" class="headerlink" title="docker命令大全"></a>docker命令大全</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker attach    <span class="comment">#连接到正在运行中的容器</span></span><br><span class="line">docker build    <span class="comment">#使用 Dockerfile 创建镜像</span></span><br><span class="line">docker builder    <span class="comment">#管理builds</span></span><br><span class="line">docker builder prune    <span class="comment">#清除build缓存</span></span><br><span class="line">docker checkpoint    <span class="comment">#管理checkpoints</span></span><br><span class="line">docker checkpoint create    <span class="comment">#从正在运行的容器创建检查点</span></span><br><span class="line">docker checkpoint <span class="built_in">ls</span>    <span class="comment">#列出容器的检查点</span></span><br><span class="line">docker checkpoint <span class="built_in">rm</span>    <span class="comment">#删除指定的检查点</span></span><br><span class="line">docker commit    <span class="comment">#从容器创建一个新的镜像</span></span><br><span class="line">docker config    <span class="comment">#管理Docker配置</span></span><br><span class="line">docker config create    <span class="comment">#创建配置文件</span></span><br><span class="line">docker config inspect    <span class="comment">#查看配置文件信息</span></span><br><span class="line">docker config <span class="built_in">ls</span>        <span class="comment">#显示docker里已经保存得配置文件</span></span><br><span class="line">docker config <span class="built_in">rm</span>        <span class="comment">#删除配置文件</span></span><br><span class="line">docker container    <span class="comment">#管理容器</span></span><br><span class="line">docker container prune    <span class="comment">#删除所有已停止的容器</span></span><br><span class="line">docker context    <span class="comment">#管理contexts</span></span><br><span class="line">docker context create    <span class="comment">#创建一个上下文</span></span><br><span class="line">docker context <span class="built_in">export</span>    <span class="comment">#将上下文导出到tar或kubecconfig文件中</span></span><br><span class="line">docker context import    <span class="comment">#从tar或zip文件导入上下文</span></span><br><span class="line">docker context inspect    <span class="comment">#在一个或多个上下文上显示详细信息</span></span><br><span class="line">docker context <span class="built_in">ls</span>        <span class="comment">#列出上下文</span></span><br><span class="line">docker context <span class="built_in">rm</span>        <span class="comment">#删除一个或多个上下文</span></span><br><span class="line">docker context update    <span class="comment">#更新</span></span><br><span class="line">docker context use        <span class="comment">#设置当前docker的上下文</span></span><br><span class="line">docker <span class="built_in">cp</span>        <span class="comment">#用于容器与主机之间的数据拷贝</span></span><br><span class="line">docker create    <span class="comment">#创建一个新的容器但不启动它</span></span><br><span class="line">docker diff        <span class="comment">#检查容器里文件结构的更改</span></span><br><span class="line">docker events    <span class="comment">#从服务器获取实时事件</span></span><br><span class="line">docker <span class="built_in">exec</span>        <span class="comment">#在运行的容器中执行命令</span></span><br><span class="line">docker <span class="built_in">export</span>    <span class="comment">#将文件系统作为一个tar归档文件导出到STDOUT</span></span><br><span class="line">docker <span class="built_in">history</span>    <span class="comment">#查看指定镜像的创建历史</span></span><br><span class="line">docker image    <span class="comment">#管理镜像</span></span><br><span class="line">docker image inspect    <span class="comment">#显示一个或多个镜像的元数据</span></span><br><span class="line">docker image <span class="built_in">ls</span>            <span class="comment">#列出本地镜像</span></span><br><span class="line">docker image prune        <span class="comment">#删除没有使用的镜像</span></span><br><span class="line">docker image <span class="built_in">rm</span>            <span class="comment">#删除一个或多个镜像</span></span><br><span class="line">docker images    <span class="comment">#列出本地镜像</span></span><br><span class="line">docker import    <span class="comment">#从归档文件中创建镜像</span></span><br><span class="line">docker info        <span class="comment">#显示 Docker 系统信息，包括镜像和容器数</span></span><br><span class="line">docker inspect    <span class="comment">#获取容器/镜像的元数据</span></span><br><span class="line">docker <span class="built_in">kill</span>        <span class="comment">#杀掉一个运行中的容器</span></span><br><span class="line">docker load        <span class="comment">#导入使用 docker save 命令导出的镜像</span></span><br><span class="line">docker login    <span class="comment">#登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</span></span><br><span class="line">docker <span class="built_in">logout</span>    <span class="comment">#登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</span></span><br><span class="line">docker logs        <span class="comment">#获取容器的日志</span></span><br><span class="line">docker manifest    <span class="comment">#管理manifest(实验，不应用于生产环境)</span></span><br><span class="line">docker manifest annotate    <span class="comment">#向本地镜像清单添加附加信息</span></span><br><span class="line">docker manifest create        <span class="comment">#创建用于注释和推入注册表的本地清单列表</span></span><br><span class="line">docker manifest inspect        <span class="comment">#显示镜像清单或清单列表</span></span><br><span class="line">docker manifest push        <span class="comment">#将清单列表推入仓库</span></span><br><span class="line">docker manifest <span class="built_in">rm</span>            <span class="comment">#从本地存储中删除一个或多个清单列表</span></span><br><span class="line">docker network    <span class="comment">#管理网络</span></span><br><span class="line">docker network connect        <span class="comment">#将容器连接到网络</span></span><br><span class="line">docker network create        <span class="comment">#创建一个网络</span></span><br><span class="line">docker network disconnect    <span class="comment">#断开容器的网络</span></span><br><span class="line">docker network inspect        <span class="comment">#显示一个或多个网络的元数据</span></span><br><span class="line">docker network <span class="built_in">ls</span>            <span class="comment">#列出网络</span></span><br><span class="line">docker network prune        <span class="comment">#删除所有没有使用的网络</span></span><br><span class="line">docker network <span class="built_in">rm</span>            <span class="comment">#删除一个或多个网络</span></span><br><span class="line">docker node        <span class="comment">#管理集群(swarm)节点</span></span><br><span class="line">docker node demote            <span class="comment">#从群集(swarm)管理器中降级一个或多个节点</span></span><br><span class="line">docker node inspect            <span class="comment">#显示一个或多个节点的元数据</span></span><br><span class="line">docker node <span class="built_in">ls</span>                <span class="comment">#列出群集(swarm)中的节点</span></span><br><span class="line">docker node promote            <span class="comment">#将一个或多个节点推入到群集管理器中</span></span><br><span class="line">docker node ps                <span class="comment">#列出在一个或多个节点上运行的任务，默认为当前节点</span></span><br><span class="line">docker node <span class="built_in">rm</span>                <span class="comment">#从群集(swarm)删除一个或多个节点</span></span><br><span class="line">docker node update            <span class="comment">#更新一个节点</span></span><br><span class="line">docker pause    <span class="comment">#暂停容器中所有的进程</span></span><br><span class="line">docker plugin    <span class="comment">#管理插件</span></span><br><span class="line">docker plugin create        <span class="comment">#从rootfs和配置创建一个插件。插件数据目录必须包含config.json和rootfs目录。</span></span><br><span class="line">docker plugin <span class="built_in">disable</span>        <span class="comment">#禁用插件</span></span><br><span class="line">docker plugin <span class="built_in">enable</span>        <span class="comment">#启用插件</span></span><br><span class="line">docker plugin inspect        <span class="comment">#显示一个或多个插件的元数据</span></span><br><span class="line">docker plugin install        <span class="comment">#安装一个插件</span></span><br><span class="line">docker plugin <span class="built_in">ls</span>            <span class="comment">#列出所有插件</span></span><br><span class="line">docker plugin push            <span class="comment">#将插件推送到注册表</span></span><br><span class="line">docker plugin <span class="built_in">rm</span>            <span class="comment">#删除一个或多个插件</span></span><br><span class="line">docker plugin <span class="built_in">set</span>            <span class="comment">#更改插件的设置</span></span><br><span class="line">docker plugin upgrade        <span class="comment">#升级现有插件</span></span><br><span class="line">docker port        <span class="comment">#列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口</span></span><br><span class="line">docker ps        <span class="comment">#列出容器</span></span><br><span class="line">docker pull        <span class="comment">#从镜像仓库中拉取或者更新指定镜像</span></span><br><span class="line">docker push        <span class="comment">#将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</span></span><br><span class="line">docker rename    <span class="comment">#重命名容器</span></span><br><span class="line">docker restart    <span class="comment">#重启容器</span></span><br><span class="line">docker <span class="built_in">rm</span>        <span class="comment">#删除一个或多个容器</span></span><br><span class="line">docker rmi        <span class="comment">#删除一个或多个镜像</span></span><br><span class="line">docker run        <span class="comment">#创建一个新的容器并运行一个命令</span></span><br><span class="line">docker save        <span class="comment">#将指定镜像保存成 tar 归档文件</span></span><br><span class="line">docker search    <span class="comment">#从Docker Hub查找镜像</span></span><br><span class="line">docker secret    <span class="comment">#管理Docker secrets</span></span><br><span class="line">docker secret create    <span class="comment">#从文件或STDIN创建一个秘密作为内容</span></span><br><span class="line">docker secret inspect    <span class="comment">#显示有关一个或多个秘密的详细信息</span></span><br><span class="line">docker secret <span class="built_in">ls</span>        <span class="comment">#列出秘密</span></span><br><span class="line">docker secret <span class="built_in">rm</span>        <span class="comment">#删除一个或多个秘密</span></span><br><span class="line">docker service    <span class="comment">#管理服务</span></span><br><span class="line">docker service create    <span class="comment">#创建一个服务</span></span><br><span class="line">docker service inspect    <span class="comment">#查看服务的元数据</span></span><br><span class="line">docker service logs        <span class="comment">#获取服务的日志</span></span><br><span class="line">docker service <span class="built_in">ls</span>        <span class="comment">#列出服务</span></span><br><span class="line">docker service ps        <span class="comment">#列出一个或多个服务的任务</span></span><br><span class="line">docker service <span class="built_in">rm</span>        <span class="comment">#删除一个或多个服务</span></span><br><span class="line">docker service rollback    <span class="comment">#将更改恢复到服务的配置</span></span><br><span class="line">docker service scale    <span class="comment">#缩放一个或多个复制服务</span></span><br><span class="line">docker service update    <span class="comment">#更新服务</span></span><br><span class="line">docker stack    <span class="comment">#管理堆栈</span></span><br><span class="line">docker stack deploy        <span class="comment">#部署新的堆栈或更新现有堆栈</span></span><br><span class="line">docker stack <span class="built_in">ls</span>            <span class="comment">#列出现有堆栈</span></span><br><span class="line">docker stack ps            <span class="comment">#列出堆栈中的任务</span></span><br><span class="line">docker stack <span class="built_in">rm</span>            <span class="comment">#删除堆栈    </span></span><br><span class="line">docker stack services    <span class="comment">#列出堆栈中的服务</span></span><br><span class="line">docker start    <span class="comment">#启动一个或多个已经被停止的容器</span></span><br><span class="line">docker stats    <span class="comment">#显示容器的实时流资源使用统计信息</span></span><br><span class="line">docker stop        <span class="comment">#停止一个运行中的容器</span></span><br><span class="line">docker swarm    <span class="comment">#管理集群(Swarm)</span></span><br><span class="line">docker swarm ca            <span class="comment">#查看或旋转当前群集CA证书。此命令必须针对管理器节点</span></span><br><span class="line">docker swarm init        <span class="comment">#初始化一个群集(Swarm)</span></span><br><span class="line">docker swarm <span class="built_in">join</span>        <span class="comment">#加入群集作为节点和/或管理器</span></span><br><span class="line">docker swarm join-token    <span class="comment">#管理加入令牌</span></span><br><span class="line">docker swarm leave        <span class="comment">#离开群集(Swarm)</span></span><br><span class="line">docker swarm unlock        <span class="comment">#解锁群集(Swarm)</span></span><br><span class="line">docker swarm unlock-key    <span class="comment">#管理解锁钥匙</span></span><br><span class="line">docker swarm update        <span class="comment">#更新群集(Swarm)</span></span><br><span class="line">docker system    <span class="comment">#管理Docker</span></span><br><span class="line">docker system <span class="built_in">df</span>        <span class="comment">#显示docker磁盘使用情况</span></span><br><span class="line">docker system events    <span class="comment">#从服务器获取实时事件</span></span><br><span class="line">docker system info        <span class="comment">#显示系统范围的信息</span></span><br><span class="line">docker system prune        <span class="comment">#删除未使用的数据</span></span><br><span class="line">docker tag        <span class="comment">#标记本地镜像，将其归入某一仓库</span></span><br><span class="line">docker top        <span class="comment">#查看容器中运行的进程信息，支持 ps 命令参数</span></span><br><span class="line">docker trust    <span class="comment">#管理Docker镜像的信任</span></span><br><span class="line">docker trust inspect    <span class="comment">#返回有关key和签名的低级信息</span></span><br><span class="line">docker trust key        <span class="comment">#管理登入Docker镜像的keys</span></span><br><span class="line">docker trust key generate    <span class="comment">#生成并加载签名密钥对</span></span><br><span class="line">docker trust key load        <span class="comment">#加载私钥文件以进行签名</span></span><br><span class="line">docker trust revoke        <span class="comment">#删除对镜像的认证</span></span><br><span class="line">docker trust sign        <span class="comment">#镜像签名</span></span><br><span class="line">docker trust signer        <span class="comment">#管理可以登录Docker镜像的实体</span></span><br><span class="line">docker trust signer add        <span class="comment">#新增一个签名者</span></span><br><span class="line">docker trust signer remove    <span class="comment">#删除一个签名者</span></span><br><span class="line">docker unpause    <span class="comment">#恢复容器中所有的进程</span></span><br><span class="line">docker update    <span class="comment">#更新一个或多个容器的配置</span></span><br><span class="line">docker version    <span class="comment">#显示 Docker 版本信息</span></span><br><span class="line">docker volume    <span class="comment">#管理volumes</span></span><br><span class="line">docker volume create    <span class="comment">#创建一个卷</span></span><br><span class="line">docker volume inspect    <span class="comment">#显示一个或多个卷的元数据</span></span><br><span class="line">docker volume <span class="built_in">ls</span>        <span class="comment">#列出卷</span></span><br><span class="line">docker volume prune        <span class="comment">#删除所有未使用的卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span>        <span class="comment">#删除一个或多个卷</span></span><br><span class="line">docker <span class="built_in">wait</span>        <span class="comment">#阻塞运行直到容器停止，然后打印出它的退出代码</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3下pinia的使用</title>
      <link href="/hexo-blog/2024/06/01/vue3%E4%B8%8Bpinia%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/hexo-blog/2024/06/01/vue3%E4%B8%8Bpinia%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-中-pinia-的使用"><a href="#Vue3-中-pinia-的使用" class="headerlink" title="Vue3 中 pinia 的使用"></a>Vue3 中 pinia 的使用</h1><blockquote><p><strong>pinia 是一款 vue 插件,作用是对 vue 中的数据做持久化存储,并且允许你跨组件或页面共享状态</strong></p></blockquote><p><strong>下载 pinia</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -d pinia</span><br></pre></td></tr></table></figure><p><strong>在 mian.js 中添加:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>();</span><br><span class="line">app.<span class="title function_">use</span>(pinia);</span><br></pre></td></tr></table></figure><p><strong>常用 API</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">createPinia defineStore storeToRefs</span><br></pre></td></tr></table></figure><p><strong>stores&#x2F;counter.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; computed, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&quot;countId&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> list = <span class="title function_">ref</span>([]);</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">API_URL</span> = <span class="string">&quot;https://applet-base-api-t.itheima.net/api/cart&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">const</span> doubleCount = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// action</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count.<span class="property">value</span>++;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getList</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="variable constant_">API_URL</span>);</span><br><span class="line">    list.<span class="property">value</span> = res.<span class="property">data</span>.<span class="property">list</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    list,</span><br><span class="line">    doubleCount,</span><br><span class="line">    increment,</span><br><span class="line">    getList,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>App.vue</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; useCounterStore &#125; <span class="keyword">from</span> <span class="string">&quot;@/stores/counter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; onMounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useCounterStore</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; count, doubleCount, list &#125; = <span class="title function_">storeToRefs</span>(store);</span><br><span class="line"><span class="keyword">const</span> &#123; increment, getList &#125; = store;</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">getList</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>count的值为:  &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>count * 2的值为:  &#123;&#123; doubleCount &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>按钮(点击后count++)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;good in list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      goods_id:&#123;&#123; good.goods_id &#125;&#125; goods_name:&#123;&#123; good.goods_name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm 的 Many To Many</title>
      <link href="/hexo-blog/2024/06/01/gorm%20%E7%9A%84%20Many%20To%20Many/"/>
      <url>/hexo-blog/2024/06/01/gorm%20%E7%9A%84%20Many%20To%20Many/</url>
      
        <content type="html"><![CDATA[<h1 id="gorm-的-Many-To-Many"><a href="#gorm-的-Many-To-Many" class="headerlink" title="gorm 的 Many To Many"></a>gorm 的 Many To Many</h1><h2 id="Many-To-Many"><a href="#Many-To-Many" class="headerlink" title="Many To Many"></a>Many To Many</h2><p>Many to Many 会在两个 model 中添加一张连接表。</p><p>例如，您的应用包含了 user 和 language，且一个 user 可以说多种 language，多个 user 也可以说一种 language。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 拥有并属于多种 language，`user_languages` 是连接表</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []Language <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 GORM 的 <code>AutoMigrate</code> 为 <code>User</code> 创建表时，GORM 会自动创建连接表</p><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 拥有并属于多种 language，`user_languages` 是连接表</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []*Language <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Users []*User <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写外键"><a href="#重写外键" class="headerlink" title="重写外键"></a>重写外键</h2><p>对于 <code>many2many</code> 关系，连接表会同时拥有两个模型的外键，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []Language <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Join Table: user_languages</span></span><br><span class="line"><span class="comment">//   foreign key: user_id, reference: users.id</span></span><br><span class="line"><span class="comment">//   foreign key: language_id, reference: languages.id</span></span><br></pre></td></tr></table></figure><p>若要重写它们，可以使用标签 <code>foreignKey</code>、<code>references</code>、<code>joinforeignKey</code>、<code>joinReferences</code>。当然，您不需要使用全部的标签，你可以仅使用其中的一个重写部分的外键、引用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Profiles []Profile <span class="string">`gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;`</span></span><br><span class="line">    Refer    <span class="type">uint</span>      <span class="string">`gorm:&quot;index:,unique&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    UserRefer <span class="type">uint</span> <span class="string">`gorm:&quot;index:,unique&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这会创建连接表：user_profiles</span></span><br><span class="line"><span class="comment">//   外键: user_refer_id, 引用: users.refer</span></span><br><span class="line"><span class="comment">//   外键: profile_refer, 引用: profiles.user_refer</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 某些数据库只允许在唯一索引字段上创建外键，如果您在迁移时会创建外键，则需要指定 <code>unique index</code> 标签。</p></blockquote><h2 id="自引用-Many2Many"><a href="#自引用-Many2Many" class="headerlink" title="自引用 Many2Many"></a>自引用 Many2Many</h2><p>自引用 many2many 关系</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">    Friends []*User <span class="string">`gorm:&quot;many2many:user_friends&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会创建连接表：user_friends</span></span><br><span class="line"><span class="comment">//   foreign key: user_id, reference: users.id</span></span><br><span class="line"><span class="comment">//   foreign key: friend_id, reference: users.id</span></span><br></pre></td></tr></table></figure><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>GORM 可以通过 <code>Preload</code> 预加载 has many 关联的记录，查看 <a href="https://gorm.io/zh_CN/docs/preload.html">预加载</a> 获取详情</p><h2 id="Many2Many-的-CURD"><a href="#Many2Many-的-CURD" class="headerlink" title="Many2Many 的 CURD"></a>Many2Many 的 CURD</h2><p>查看 <a href="https://gorm.io/zh_CN/docs/associations.html#Association-Mode">关联模式</a> 获取 many2many 相关的用法</p><h2 id="自定义连接表"><a href="#自定义连接表" class="headerlink" title="自定义连接表"></a>自定义连接表</h2><p><code>连接表</code> 可以是一个全功能的模型，支持 <code>Soft Delete</code>、<code>钩子</code>、定义更多的字段，就跟其它模型一样。您可以通过 <code>SetupJoinTable</code> 指定它，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">int</span></span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  Addresses []Address <span class="string">`gorm:&quot;many2many:person_addresses;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">uint</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonAddress <span class="keyword">struct</span> &#123;</span><br><span class="line">  PersonID  <span class="type">int</span></span><br><span class="line">  AddressID <span class="type">int</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(PersonAddress)</span></span> BeforeCreate(db *gorm.DB) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 Person 的 Addresses 字段的连接表为 PersonAddress</span></span><br><span class="line"><span class="comment">// PersonAddress 必须定义好所需的外键，否则会报错</span></span><br><span class="line">err := db.SetupJoinTable(&amp;Person&#123;&#125;, <span class="string">&quot;Addresses&quot;</span>, &amp;PersonAddress&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>你可以通过为标签 <code>constraint</code> 配置 <code>OnUpdate</code>、<code>OnDelete</code> 实现外键约束，在使用 GORM 进行迁移时它会被创建，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []Language <span class="string">`gorm:&quot;many2many:user_speaks;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  Code <span class="type">string</span> <span class="string">`gorm:&quot;primarykey&quot;`</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CREATE TABLE `user_speaks` (`user_id` integer,`language_code` text,PRIMARY KEY (`user_id`,`language_code`),CONSTRAINT `fk_user_speaks_user` FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE SET NULL ON UPDATE CASCADE,CONSTRAINT `fk_user_speaks_language` FOREIGN KEY (`language_code`) REFERENCES `languages`(`code`) ON DELETE SET NULL ON UPDATE CASCADE);</span></span><br></pre></td></tr></table></figure><p>你也可以在删除记录时通过 <code>Select</code> 来删除 many2many 关系的记录，查看 <a href="https://gorm.io/zh_CN/docs/associations.html#delete_with_select">Delete with Select</a> 获取详情</p><h2 id="复合外键"><a href="#复合外键" class="headerlink" title="复合外键"></a>复合外键</h2><p>如果您的模型使用了 <a href="https://gorm.io/zh_CN/docs/composite_primary_key.html">复合主键</a>，GORM 会默认启用复合外键。</p><p>您也可以覆盖默认的外键、指定多个外键，只需用逗号分隔那些键名，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tag <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID     <span class="type">uint</span>   <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  Locale <span class="type">string</span> <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  Value  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID         <span class="type">uint</span>   <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  Locale     <span class="type">string</span> <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  Subject    <span class="type">string</span></span><br><span class="line">  Body       <span class="type">string</span></span><br><span class="line">  Tags       []Tag <span class="string">`gorm:&quot;many2many:blog_tags;&quot;`</span></span><br><span class="line">  LocaleTags []Tag <span class="string">`gorm:&quot;many2many:locale_blog_tags;ForeignKey:id,locale;References:id&quot;`</span></span><br><span class="line">  SharedTags []Tag <span class="string">`gorm:&quot;many2many:shared_blog_tags;ForeignKey:id;References:id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接表：blog_tags</span></span><br><span class="line"><span class="comment">//   foreign key: blog_id, reference: blogs.id</span></span><br><span class="line"><span class="comment">//   foreign key: blog_locale, reference: blogs.locale</span></span><br><span class="line"><span class="comment">//   foreign key: tag_id, reference: tags.id</span></span><br><span class="line"><span class="comment">//   foreign key: tag_locale, reference: tags.locale</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接表：locale_blog_tags</span></span><br><span class="line"><span class="comment">//   foreign key: blog_id, reference: blogs.id</span></span><br><span class="line"><span class="comment">//   foreign key: blog_locale, reference: blogs.locale</span></span><br><span class="line"><span class="comment">//   foreign key: tag_id, reference: tags.id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接表：shared_blog_tags</span></span><br><span class="line"><span class="comment">//   foreign key: blog_id, reference: blogs.id</span></span><br><span class="line"><span class="comment">//   foreign key: tag_id, reference: tags.id</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gorm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
