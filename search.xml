<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql数据库错题</title>
      <link href="/hexo-blog/2024/06/12/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/"/>
      <url>/hexo-blog/2024/06/12/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-12-01-21-image-1718194111866-63-1718194398057-104.png"></p><p>关系代数的最基本操作中，除了并、差、笛卡尔积之外，还包括 <strong>选择</strong> 和 <strong>投影</strong>。这些操作是关系代数的基础，用于从关系中提取信息、组合关系或创建新的关系。因此，正确答案是：</p><p>A. 选择、投影</p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-12-01-35-image-1718194111866-62-1718194398057-108.png"></p><p>关系R(A，B，C，D)有4个属性，而关系S(B，C，D)有3个属性。当计算两个关系的笛卡尔积R×S时，结果关系中的每一行都会包含R的所有属性和S的所有属性，且来自R的属性与来自S的属性互不重叠（尽管它们可能有相同的属性名，但这不影响元数的计算）。</p><p>因此，R×S的元数（即属性的数量）是R的元数加上S的元数，因为没有共同的属性需要减去。</p><p>所以，R×S的元数 &#x3D; 4（R的属性数量）+ 3（S的属性数量）&#x3D; 7。</p><p>正确答案是 D. 7。</p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-12-13-11-image-1718194111866-64-1718194398057-112.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-13-02-17-image-1718194111867-66-1718194398057-106.png"></p><p>在SQL中，表达式<code>(3+null) and (4&gt;3)</code>的求值需要根据SQL的三值逻辑来理解。</p><ol><li><code>3+null</code> 的结果是 <code>null</code>，因为在SQL中，任何数值与 <code>null</code> 进行算术运算的结果都是 <code>null</code>。</li><li><code>(4&gt;3)</code> 是一个布尔表达式，它的结果是 <code>true</code>，因为4确实大于3。</li><li>在SQL的三值逻辑中，<code>true</code> 和 <code>null</code> 进行 <code>AND</code> 操作时，结果是 <code>null</code>，而不是 <code>false</code>。这是因为 <code>null</code> 表示未知，与任何确定的布尔值进行逻辑运算时，结果都是未知。</li></ol><p>综上所述，表达式 <code>(3+null) and (4&gt;3)</code> 的最终结果是 <code>null</code>。这意味着该表达式在SQL中不会被评估为 <code>true</code>，即使其中一部分 <code>(4&gt;3)</code> 是 <code>true</code>。在WHERE子句中，这样的表达式不会匹配到任何行，因为 <code>null</code> 不被视为 <code>true</code> 来满足条件。</p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-13-16-44-image-1718194111867-65-1718194398057-116.png"></p><p>（1）求供应工程J1零件的供应商号码SNO；</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> SPJ.SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO <span class="operator">=</span> <span class="string">&#x27;J1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（2）求供应工程J1零件P1的供应商号码SNO；</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> SPJ.SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO <span class="operator">=</span> <span class="string">&#x27;J1&#x27;</span> <span class="keyword">AND</span> SPJ.PNO <span class="operator">=</span> <span class="string">&#x27;P1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（3）求供应工程J1零件为红色的供应商号码SNO；</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> SPJ.SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">JOIN</span> P <span class="keyword">ON</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO <span class="operator">=</span> <span class="string">&#x27;J1&#x27;</span> <span class="keyword">AND</span> P.COLOR <span class="operator">=</span> <span class="string">&#x27;红色&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（4）求没有使用天津供应商生产的红色零件的工程好JNO；</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> J.JNO</span><br><span class="line"><span class="keyword">FROM</span> J</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">FROM</span> SPJ </span><br><span class="line">    <span class="keyword">JOIN</span> S <span class="keyword">ON</span> SPJ.SNO <span class="operator">=</span> S.SNO </span><br><span class="line">    <span class="keyword">JOIN</span> P <span class="keyword">ON</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    <span class="keyword">WHERE</span> J.JNO <span class="operator">=</span> SPJ.JNO <span class="keyword">AND</span> S.CITY <span class="operator">=</span> <span class="string">&#x27;天津&#x27;</span> <span class="keyword">AND</span> P.COLOR <span class="operator">=</span> <span class="string">&#x27;红色&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（5）求至少用了供应商S1所供应的全部零件的工程和JNO； 这个问题比较复杂，需要两层嵌套查询，首先找出S1供应的所有零件，然后查找使用了这些全部零件的工程。这里给出一个可能的解法，但请注意，实际执行可能依赖于特定数据库系统对集合操作的支持程度。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先找出S1供应的所有零件</span></span><br><span class="line"><span class="keyword">WITH</span> S1Parts <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> PNO</span><br><span class="line">    <span class="keyword">FROM</span> SPJ</span><br><span class="line">    <span class="keyword">WHERE</span> SNO <span class="operator">=</span> <span class="string">&#x27;S1&#x27;</span></span><br><span class="line">),</span><br><span class="line"><span class="comment">-- 找出使用了S1供应的所有零件的工程</span></span><br><span class="line">QualifiedProjects <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> JNO</span><br><span class="line">    <span class="keyword">FROM</span> SPJ</span><br><span class="line">    <span class="keyword">WHERE</span> PNO <span class="keyword">IN</span> (<span class="keyword">SELECT</span> PNO <span class="keyword">FROM</span> S1Parts)</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> JNO</span><br><span class="line">    <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> PNO) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> S1Parts)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> QualifiedProjects;</span><br></pre></td></tr></table></figure><p>这段SQL使用了CTE（公共表达式）来分步解决这个问题，先定义了S1供应的零件集合，然后通过比较每个工程使用的零件集合是否与S1的零件集合相等来找出符合条件的工程。注意，实际应用中可能需要根据具体的数据库系统调整查询策略。</p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-14-00-55-image-1718194111867-68-1718194398057-110.png"></p><p>1.在从E-R模型到关系模型的转化中，关系的外部键（foreign key）通常不是由联系集自带的属性直接转化而来的。外部键主要是用来表示实体之间的关联关系。在E-R模型中，联系可以是简单联系（无属性）或复杂联系（有属性）。转化时：</p><ul><li>简单联系（无属性）通常转化为一个表中的外键，引用另一个表的主键，以此来表示两个实体之间的关系。</li><li>复杂联系（有属性）则会转化为一个独立的表，该表的外键同时引用与之关联的两个实体表的主键，而这个联系表中的属性也会转换为该表的列。</li></ul><p>因此，外部键更多地体现了实体之间的关联，而非联系集自带的属性直接转化，尽管在复杂联系转化为关系表时，其自带的属性也会成为新表的一部分，但核心的外键设计是为了体现关联性。</p><p>2.正确答案是：</p><p>B. 概念设计</p><p>在数据库设计的过程中，E-R模型的设计属于概念设计阶段。这个阶段主要是将需求分析得到的信息抽象成概念模型，而E-R模型作为一种常用的概念数据模型，用于描述数据的静态结构、实体之间的关系以及实体的属性等。</p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-14-17-28-image-1718194111867-67-1718194398057-114.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-14-19-53-image-1718194111867-70-1718194398057-118.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-14-20-21-image-1718194111867-69-1718194398057-120.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-15-31-52-image-1718194111867-71-1718194398057-122.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-15-55-59-image-1718194111867-72-1718194398057-124.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-15-56-12-image-1718194111867-73-1718194398057-126.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-17-14-17-image-1718194111867-74-1718194398058-128.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-17-30-29-image-1718194111867-75-1718194398058-130.png"></p><p>在SQL中，创建一个死锁情景通常涉及到两个或更多的事务，它们互相等待对方释放锁的资源。下面是一个简化的例子，演示如何在两个事务中创建死锁情况。假设我们有一个简单的银行账户表<code>bank_account</code>，包含字段<code>account_id</code>和<code>balance</code>。</p><h3 id="事务1-在第一个SQL查询分析器中执行"><a href="#事务1-在第一个SQL查询分析器中执行" class="headerlink" title="事务1 (在第一个SQL查询分析器中执行)"></a>事务1 (在第一个SQL查询分析器中执行)</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务1尝试更新账户A的余额，但需要等待事务2完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> bank_account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这里加入WAITFOR延迟，模拟实际应用中可能存在的处理时间</span></span><br><span class="line"></span><br><span class="line">WAITFOR DELAY <span class="string">&#x27;00:00:05&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 假设接下来事务1想要更新账户B，但这会被事务2锁定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> bank_account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h3 id="事务2-在第二个SQL查询分析器中几乎同时执行"><a href="#事务2-在第二个SQL查询分析器中几乎同时执行" class="headerlink" title="事务2 (在第二个SQL查询分析器中几乎同时执行)"></a>事务2 (在第二个SQL查询分析器中几乎同时执行)</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2尝试更新账户B的余额，但需要等待事务1完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> bank_account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同样加入WAITFOR延迟</span></span><br><span class="line"></span><br><span class="line">WAITFOR DELAY <span class="string">&#x27;00:00:05&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 假设接下来事务2想要更新账户A，但这会被事务1锁定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> bank_account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>在这个场景中，如果两个事务几乎同时启动，它们会各自锁定一个账户并等待对方释放锁。事务1锁定了账户A并等待账户B，而事务2则锁定了账户B并等待账户A，形成经典的死锁情形。在实际的数据库管理系统中，大多数都配备了死锁检测机制，当检测到死锁时，会自动选择一个事务进行回滚以打破死锁状态。</p><p>在数据库中为什么要并发操作？</p><p>在数据库中采用并发操作的原因主要包括以下几点：</p><ol><li><strong>提高系统性能与响应速度</strong>：并发允许数据库同时处理多个用户的请求，提高了系统的吞吐量。这样可以减少用户等待时间，使系统能够更快地响应用户操作，提升用户体验。</li><li><strong>支持多用户访问</strong>：在现实场景中，数据库往往是多用户共享的资源。并发机制确保了多个用户能够同时访问和操作数据库，避免了单一用户独占资源的情况，提高了资源的利用率。</li><li><strong>提高资源利用率</strong>：特别是在多核处理器的系统中，通过并发执行多个线程或进程，可以充分利用多个CPU核心，避免了单线程执行时CPU资源的闲置，提升了处理能力。</li><li><strong>实现数据一致性</strong>：虽然并发操作可能引发数据不一致的问题，但通过有效的并发控制机制（如锁定、多版本并发控制（MVCC）、时间戳等），可以在保证并发性的同时维护数据库的一致性，防止丢失更新、脏读、不可重复读和幻读等并发控制问题的发生。</li><li><strong>满足实时处理需求</strong>：在需要实时数据处理和分析的应用场景中，如在线交易系统、实时监控系统等，并发操作能够即时响应用户需求，处理大量并发事务，保证服务的连续性和可用性。</li></ol><p>综上所述，数据库中的并发操作是现代信息系统高效运作的基础，它不仅关乎系统性能的优化，也直接关系到用户体验和服务质量。通过合理的并发控制策略，可以在保障数据准确性和一致性的前提下，充分发挥系统的处理潜能。</p><p>并发操作会带来哪几种数据库不一致问题，这些问题是如何产生的？</p><p>并发操作在数据库中可能会引发以下几种数据不一致问题：</p><ol><li><strong>丢失修改（Lost Update）</strong>：</li></ol><p>  当两个或多个事务同时读取同一条数据，并基于初始读取的值进行修改，然后提交时，最后一个提交的事务会覆盖之前事务所做的修改。这样，先前事务所做的修改就被丢失了。例如，两个用户试图同时更新同一笔订单的余额，如果没有适当的并发控制，后提交的事务可能会覆盖前一个事务的更新，导致前一个事务的修改丢失。</p><ol><li><strong>不可重复读（Non-Repeatable Read）</strong>：</li></ol><p>  在同一个事务内，如果两次或多次读取同一数据，第二次或之后的读取可能会得到与第一次不同的结果，这是因为其他事务在这两次读取之间修改并提交了数据。这违反了事务的隔离性，使得在同一个事务中无法重复获取相同的数据视图。</p><ol><li><strong>读“脏”数据（Dirty Read）</strong>：</li></ol><p>  当一个事务读取了另一个事务尚未提交的修改数据时，如果后者最终回滚，那么前者读取到的就是无效的、不一致的数据，即所谓的“脏”数据。这种情况同样破坏了事务的隔离性。</p><p>这些问题主要是由于并发控制不当，导致事务的隔离性被破坏而产生的。在数据库系统中，为了解决这些问题，通常会采用不同的并发控制技术，比如锁机制（乐观锁、悲观锁）、多版本并发控制（MVCC）、时间戳排序等，以确保在并发环境下数据的一致性和事务的正确执行。</p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-28-42-image-1718194111867-76-1718194398058-132.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-30-41-image-1718194111867-77-1718194398058-134.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-31-38-image-1718194111867-78-1718194398058-136.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-33-14-image-1718194111867-79-1718194398058-138.png"></p><p><img src="/hexo-blog/./mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98/2024-06-12-19-49-55-image-1718194111867-80-1718194398058-140.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从E-R模型到关系模型</title>
      <link href="/hexo-blog/2024/06/12/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"/>
      <url>/hexo-blog/2024/06/12/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="从E-R模型到关系模型"><a href="#从E-R模型到关系模型" class="headerlink" title="从E-R模型到关系模型"></a>从E-R模型到关系模型</h1><p>E-R模型和关系模型都是现实世界抽象的逻辑表示</p><ul><li>E-R模型并不被 DBMS直接支持，更适合对现实世界建模</li><li>关系模型是 DBMS直接支持的数据模型</li></ul><p>基本 E-R图中的元素包括实体集、联系集、属性</p><p>椭圆框表示属性，矩形框表示实体集，菱形框表示联系</p><p><img src="/hexo-blog/./img/note/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqdXd4eA==,size_16,color_FFFFFF,t_70.png"></p><h2 id="属性处理"><a href="#属性处理" class="headerlink" title="属性处理"></a>属性处理</h2><p>关系模型要求关系的所有属性都是原子的。然而 E-R模型中的复合属性和多值属性不是原子的，E-R模型还允许出现派生属性，这三种属性需要特殊处理</p><p>（1）派生属性</p><p>派生属性的值可以通过计算得到，它的值不在数据库中存储，转换时直接忽略</p><p>（2）复合属性</p><p>采用”展平”技术：忽略复合属性本身，直接考虑它的成分属性。如果某个成分属性仍然是复合的，用相同方法处理</p><p><em>例如，考虑实体集职工复合属性”家庭住址”，它包含成分属性省、城市、街道、邮政编码。在将该实体集转换成关系模式时，忽略复合属性”家庭住址”，而直接使用成分属性省、城市、街道、邮政编码作为关系模式的属性</em></p><p>（3）多值属性</p><p>需要为每个多值属性 M创建一个关系 RMRMR_{M}</p><ol><li>如果多值属性 M是实体集 E的属性，K是 E的主码，则关系 RMRMR_{M}的属性由 M和 K组成</li><li>如果多值属性 M是联系集 R的属性，并且 R涉及实体集 E1，…，En，它们的主码分别是 K1，…，Kn，则关系 RMRMR_{M}的属性由 M和 K1，…，Kn组成</li></ol><p>注意：如果 M还是复合属性，则需要按复合属性的处理方法对 M做”展平”处理。关系 RMRMR_{M}的码需要根据实际问题的语义确定。此外一旦为多值属性创建了关系，后续处理就不再考虑多值属性</p><hr><p><strong>例1、多值属性转换</strong></p><p>如总图，Phones 是实体集 Departments 的多值属性，为其创建一个关系。由于 Phones还是复合属性，需要对它做”展平”处理：直接使用其成分属性 Office 和 Phone#。实体集 Departments 的码是 Dno。由此得到多值属性 Phones 的关系模式为：<strong>Phones(Phone#, Dno, Office)</strong></p><p>假定每部电话都在一个院系的办公室，因此 Phone# 可以作为 Phones 的码</p><p>注意：这里把为多值属性 Phones 创建的关系用 Phones 命名。原则上如何命名没有规定，但是采用容易记忆的名字有助于理解，并且当多值属性是复合属性时，直接使用多值属性名作为关系名是方便的</p><h2 id="实体集处理"><a href="#实体集处理" class="headerlink" title="实体集处理"></a>实体集处理</h2><blockquote><p><strong>强 &#x2F; 弱实体集</strong></p><p>一般地，如果一个实体集的<strong>任何属性集都不足以形成该实体集的码</strong>，则称该实体集为<strong>弱实体集</strong>。与此相对，存在码的实体集称为强实体集</p><p>弱实体集中的任何实体（简称弱实体）都不能独立地存在于系统中，即每个弱实体必须依赖于一个强实体。<em>例如每个家属必须存在依赖于一个特定的职工（只有这样他才被公司视为家属），当一位职工离开公司，他的配偶和子女都不再被公司视为家属</em></p><ul><li>弱实体集必须与另一个称为<strong>标识实体集</strong>或属主实体集的强实体集相关联才有意义</li><li>称标识实体集拥有它所标识的弱实体集，将弱实体集与其标识实体集相关联的的联系称为<strong>标识性联系</strong></li><li><strong>标识性联系是</strong>从弱实体集到标识实体集的<strong>多对一联系</strong>，并且弱实体集对该联系的参与是全部参与</li></ul><p>在弱实体集中，如果它的一个属性集可以唯一确定 存在依赖于同一个强实体的弱实体，则称该属性集为弱实体集的<strong>分辨符</strong>。弱实体集的标识实体集的码和该弱实体集的分辨符共同形成弱实体集的码，弱实体集的分辨符又称弱实体集的部分码</p></blockquote><p>每个强实体集用一个关系表示。实体集名可以作为关系名，实体集的全部属性构成关系的属性（复合属性按照前面的方法”展平”），实体集的码作为关系的码</p><p>每个弱实体集用一个关系表示。弱实体集名可以作为关系名，弱实体集存在依赖的标识实体集的主码和弱实体集的全部属性构成关系的属性（复合属性按照前面的方法”展平”），标识实体集的码和弱实体集的分辨符组合成关系的码。下图给出了强实体集职工和弱实体集家属转换后的关系模式</p><p><img src="/hexo-blog/./img/note/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqdXd4eA==,size_16,color_FFFFFF,t_70.png"></p><h2 id="联系集处理"><a href="#联系集处理" class="headerlink" title="联系集处理"></a>联系集处理</h2><p>每个联系集用一个关系表示，但弱实体集与其标识实体集之间的存在依赖关系忽略</p><p>联系集名可以作为关系名，参与联系的诸实体集的主码和联系集的属性（复合属性按照前面的方法”展平”）形成关系的属性</p><p>关系的码根据联系的类型按如下方法确定</p><p><img src="/hexo-blog/./img/note/%E4%BB%8EE-R%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqdXd4eA==,size_16,color_FFFFFF,t_70.png"></p><p>联系集转关系时，先找到一个联系集，然后顺着连线找到关联的多个实体集。观察实体集间的连线：</p><ol><li>连线的两端都有箭头，说明是<strong>一对一的联系</strong>，<strong>新的主码是两关系的候选码中的一个</strong>（两个候选码都画有下划线，但下划线不相连，具体哪个是主码，自定）</li><li>连线的一端有箭头，说明是<strong>一对多的联系</strong>，箭头一端是”单端”，新<strong>的主码由”多端”实体集的码组成</strong></li><li>连线两端都没箭头，说明是<strong>多对多的联系</strong>，<strong>新的主码由所有实体集的码组成</strong></li></ol><h2 id="将基本-E-R图转换成关系模式"><a href="#将基本-E-R图转换成关系模式" class="headerlink" title="将基本 E-R图转换成关系模式"></a>将基本 E-R图转换成关系模式</h2><p>为了将联系转换成关系模式，要求参与同一联系的任何两个不同的实体集的主码都不包含相同的属性（这一点容易做到，属性是局部于实体集的，必要时可以对某些属性重命名）</p><p>假定复合属性已经”展平”，多值属性创建了对应的关系。将 E-R模型转换成关系模式的方法如下</p><ol><li>每个强实体集用一个关系表示</li><li>每个弱实体集用一个关系表示</li><li>将联系集用相应的方法转换成关系表示</li><li>如果两个关系具有相同的码，可以合并它们（这一步并非必须，但可以减少码重复存放空间开销，使查询可以更有效的求值）</li></ol><hr><p><strong>例2、将总图转换成关系模式</strong></p><p>总图的多值复合属性 Phones 得到关系模式：<strong>Phones(Phone#, Dno, Office)</strong></p><p>总图没有弱实体集，由强实体集得到如下关系模式：</p><p><strong>Departments(Dno, Dname)</strong></p><p><strong>Teachers(Tno, Tname, Sex, Birthday, Title)</strong></p><p><strong>Students(Sno, Sname, Sex, Birthday, Enrollyear, Speciality)</strong></p><p><strong>Courses(Cno, Cname, Perid, Credit)</strong></p><p>其中每个关系模式都源于同名实体集，码用下划线标记。多值属性 Phones 不包含在关系模式 Departments 中，已经将它转换成关系模式</p><p>由联系集得到如下关系模式：</p><p><strong>Manades(Dno,  Tno)</strong></p><p><strong>Works_in(Tno, Dno)</strong></p><p><strong>Studies_in(Sno, Dno)</strong></p><p><strong>Teaches(Tno, Cno)</strong></p><p><strong>SC(Sno, Cno, Grade)</strong></p><p><strong>Evalues(Sno, Tno, Cno, Escore)</strong></p><p>其中每个关系模式都源于同名联系集，码用下划线标记。Manages 和 Works_in 包含相同的属性，但它们含义不同，前者 Tno 表示作为系主任的教师对特定的”系”（用 Tno 表示）的管理，后者表示每位教师在一个特定的系工作</p><p>最后一步，合并具有相同码的关系模式（合并时可根据实际情况，也可根据题设要求）</p><p>Manages 可以和 Departments 合并，也可以与 Teachers 合并，前者有利于回答 <em>“某系的主任是谁”</em> 之类的问题，后者有利于回答 <em>“某教师的系主任是谁”</em> 之类的问题。前一类问题更常出现，采用前一种方法，得到关系模式 **Departments(Dno, Dname, Dheadno)**（把表示系主任的职工号的属性名 Tno 改为 Dheadno，使得属性的语义更清楚）</p><p>还有两对关系具有相同的码，<strong>Teachers</strong> 和 <strong>Works_in</strong>，<strong>Students</strong> 和 <strong>Studies_in</strong>，都可以直接合并。最终得到关系模式：</p><p><strong>Departments(Dno, Dname, Dheadno)</strong></p><p><strong>Teachers(Tno, Tname, Sex, Birthday, Title, Tno)</strong></p><p><strong>Students(Sno, Sname, Sex, Birthday, Enrollyear, Speciality, Dno)</strong></p><p><strong>Courses(Cno, Cname, Perid, Credit)</strong></p><p><strong>Teaches(Tno, Cno)</strong></p><p><strong>SC(Sno, Cno, Grade)</strong></p><p><strong>Evalues(Sno, Tno, Cno, Escore)</strong></p><p><strong>Phones(Phone#, Dno, Office)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin 生成 Swagger 接口文档</title>
      <link href="/hexo-blog/2024/06/12/gin%20%E7%94%9F%E6%88%90%20Swagger%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
      <url>/hexo-blog/2024/06/12/gin%20%E7%94%9F%E6%88%90%20Swagger%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Gin-生成-Swagger-接口文档"><a href="#Gin-生成-Swagger-接口文档" class="headerlink" title="Gin 生成 Swagger 接口文档"></a>Gin 生成 Swagger 接口文档</h1><h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">1.背景</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">2.Swagger</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">3.准备工作</a></li><li><ul><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">安装 swag 命令</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">添加声明式注释</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">执行 swag init 生成接口描述文件</a></li></ul></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">4.Gin 集成 Swagger</a></li><li><ul><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">import 依赖包</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">import 生成的 docs 包</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">注册 Gin router</a></li></ul></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">5.FAQ</a></li><li><a href="https://cloud.tencent.com/developer?from_column=20421&from=20421">参考文献</a></li></ul><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>后台服务通过接口（如 <a href="https://cloud.tencent.com/product/slshttp?from_column=20065&from=20065">RESTful API</a>）对外提供服务时，需要有明确的接口文档。</p><p>书写接口文档，我们可以手动书写，也可以采用工具自动生成。手动书写的问题在于接口协议变更后需要维护接口文档，效率低下。采用工具生成，不同的工具生成的接口文档风格不一，增加阅读者的理解成本。</p><p>因此，我们可以采用业界常用的 Swagger 为 RESTful API 生成可交互的接口文档。</p><p>本文以 Gin 框架为例，描述 Gin 中如何为接口生成 Swagger 文档。</p><h2 id="2-Swagger"><a href="#2-Swagger" class="headerlink" title="2.Swagger"></a>2.Swagger</h2><p>Swagger 是一套基于 OpenAPI 规范实现的用于编写 RESTful API 文档的开源工具。可通过编写 yaml 和 json 来实现接口的文档化，并且可以进行测试等工作。</p><p>通过 Swagger 可以方便地生成接口文档，方便前端进行查看和测试。</p><p>Swagger 主要包含了以下三个部分：</p><ul><li>Swagger Editor</li></ul><p>基于浏览器的编辑器，我们可以使用它编写我们 OpenAPI 规范(yaml 或 json 配置）。</p><ul><li>Swagger UI</li></ul><p>他会将我们编写的 OpenAPI 规范呈现为交互式的 API 文档，后文我将使用浏览器来查看并且操作我们的 RESTfulAPI。</p><ul><li>Swagger Codegen</li></ul><p>它可以通过 OpenAPI 规范定义的任何 API 生成<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>存根和客户端SDK来简化构建过程。</p><p>使用 Swagger 就是把接口相关信息存储在它定义的描述文件里面（yaml 或 json 格式），再通过维护这个描述文件可以去更新接口文档，以及生成各端代码。</p><h2 id="3-准备工作"><a href="#3-准备工作" class="headerlink" title="3.准备工作"></a>3.准备工作</h2><h3 id="安装-swag-命令"><a href="#安装-swag-命令" class="headerlink" title="安装 swag 命令"></a>安装 swag 命令</h3><p>首先本地需要先安装 swag <a href="https://cloud.tencent.com/product/cli?from_column=20065&from=20065">命令行工具</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">go install github.<span class="property">com</span>/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure><p>swag 命令的作用是扫描程序文件，根据接口规范注释，生成接口描述文件（yaml或json格式）。</p><h3 id="添加声明式注释"><a href="#添加声明式注释" class="headerlink" title="添加声明式注释"></a>添加声明式注释</h3><p>在源码中添加<a href="/developer/tools/blog-entry?target=https://github.com/swaggo/swag#declarative-comments-format&source=article&objectId=2221656">声明式注释</a>，用于生成接口描述文件。</p><ul><li>General API Info</li></ul><p>此类注释用于描述接口的一般信息，在 main() 函数处添加。如 title，version，description 等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @title XX管理系统后台接口。</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @description XX管理系统后台接口，供 APP 及 Web 端调用。</span></span><br><span class="line"><span class="comment">// @host https://xxx.xxx.com</span></span><br><span class="line"><span class="comment">// @basePath /api/v1</span></span><br><span class="line"><span class="comment">// @schemes https</span></span><br><span class="line"><span class="comment">// @accept json</span></span><br><span class="line"><span class="comment">// @produce json</span></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>API Operation</li></ul><p>此类注释用于描述接口的具体信息，在每一个接口函数处添加。如 Summary, Description, Tags 等。</p><p>Summary 是简短描述，Description 是详细描述，Tags 是逗号分隔的标签，用于分组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 检查 APP 包是否需要升级。</span></span><br><span class="line"><span class="comment">// @Description  检查 APP 包是否需要升级。</span></span><br><span class="line"><span class="comment">// @Tags APP 接口。</span></span><br><span class="line"><span class="comment">// @Accept json</span></span><br><span class="line"><span class="comment">// @Produce json</span></span><br><span class="line"><span class="comment">// @Param Body body ReqCheckAppUpgrade true &quot;请求体&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;object&#125; RspCheckAppUpgrade</span></span><br><span class="line"><span class="comment">// @Router /app/check_app_upgrade [post]</span></span><br><span class="line">func <span class="title class_">HandlerCheckAppUpgrade</span>(c *gin.<span class="property">Context</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Param 表示请求参数，格式为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">param_name,param_type,data_type,is_mandatory,comment</span><br></pre></td></tr></table></figure><p>其中 ReqCheckAppUpgrade 表示 body 使用的 struct。</p><p>Success 表示成功回包内容，其中 RspCheckAppUpgrade 表示回包 body 使用的 struct。</p><p>其他注释说明，详见 <a href="/developer/tools/blog-entry?target=https://github.com/swaggo/swag#declarative-comments-format&source=article&objectId=2221656">Declarative Comments Format</a>。</p><h3 id="执行-swag-init-生成接口描述文件"><a href="#执行-swag-init-生成接口描述文件" class="headerlink" title="执行 swag init 生成接口描述文件"></a>执行 swag init 生成接口描述文件</h3><p>在 main.go 所在目录，执行如下命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">swag init</span><br></pre></td></tr></table></figure><p>生成的接口描述文件将存入当前目录下的 docs 目录。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docs.<span class="property">go</span></span><br><span class="line">swagger.<span class="property">json</span></span><br><span class="line">swagger.<span class="property">yaml</span></span><br></pre></td></tr></table></figure><p>或者指定相关选项。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">swag init -g main.<span class="property">go</span> -d apidir --parseDependency -o docs</span><br></pre></td></tr></table></figure><p>swag init 具体用法参见：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">swag init -h</span><br></pre></td></tr></table></figure><h2 id="4-Gin-集成-Swagger"><a href="#4-Gin-集成-Swagger" class="headerlink" title="4.Gin 集成 Swagger"></a>4.Gin 集成 Swagger</h2><p>生成 API 描述文件后，便可通过 Swagger 为我们提供的库，将 API 描述文件集成到服务中，通过接口的形式提供在线文档。</p><h3 id="import-依赖包"><a href="#import-依赖包" class="headerlink" title="import 依赖包"></a>import 依赖包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">swaggerFiles <span class="string">&quot;github.com/swaggo/files&quot;</span></span><br><span class="line">ginSwagger <span class="string">&quot;github.com/swaggo/gin-swagger&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="import-生成的-docs-包"><a href="#import-生成的-docs-包" class="headerlink" title="import 生成的 docs 包"></a>import 生成的 docs 包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;&lt;your docs path&gt;&quot;</span> <span class="comment">// docs is generated by Swag CLI, you have to import it.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="注册-Gin-router"><a href="#注册-Gin-router" class="headerlink" title="注册 Gin router"></a>注册 Gin router</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">New</span>()</span><br><span class="line">router.<span class="title function_">GET</span>(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.<span class="title class_">WrapHandler</span>(swaggerfiles.<span class="property">Handler</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>完成以上所有操作后，运行服务，浏览器访问：<a href="http://localhost:8080/swagger/index.html%E3%80%82">http://localhost:8080/swagger/index.html。</a></p><p>关于最终的文档效果，可参见官方示例 <a href="/developer/tools/blog-entry?target=https://petstore.swagger.io/&source=article&objectId=2221656">Swagger Petstore</a>。</p><p>![在这里插入图片描述](.&#x2F;gin 生成 Swagger 接口文档&#x2F;d920f202906a43dafe8dc68f570a0e7d.png)</p><p>在这里插入图片描述</p><h2 id="5-FAQ"><a href="#5-FAQ" class="headerlink" title="5.FAQ"></a>5.FAQ</h2><p>（1）访问接口文档发生<code>Failed to load API definition.</code>错误。</p><p>![在这里插入图片描述](.&#x2F;gin 生成 Swagger 接口文档&#x2F;6271b9cb051d47c1ce84a640dca70a32.png)</p><p>在这里插入图片描述</p><p>原因是未 import 生成的 docs 包。</p><p>（2）执行 swag init会报错。</p><p>假如func方法头标注的swagger注释不正确，在自行根据报错信息去修改。</p><p>（3）访问接口文档报错 <code>404 page not found</code>。</p><p>是因为没有添加 Swagger 的路由。</p><p>（4）如果请求 Body 是 JSON 则无法添加注释，该如何给字段添加注释呢？</p><p>可以在请求 Body 对应的 struct 中添加注释，在接口的请求参数中添加说明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Param Body body ReqCheckAppUpgrade true &quot;字段描述参见 apis.ReqCheckAppUpgrade&quot;</span></span><br></pre></td></tr></table></figure><p>然后在接口文档中可找到 apis.ReqCheckAppUpgrade 的定义与字段描述。</p><p>![在这里插入图片描述](.&#x2F;gin 生成 Swagger 接口文档&#x2F;c4d537bed80705c9bdebbb6e3484095e.png)</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析</title>
      <link href="/hexo-blog/2024/06/10/go%E4%B8%ADUnicode%E3%80%81UTF-8%E3%80%81UTF-16%E3%80%81UTF-32%E4%B8%8EByte%E5%88%87%E7%89%87%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/hexo-blog/2024/06/10/go%E4%B8%ADUnicode%E3%80%81UTF-8%E3%80%81UTF-16%E3%80%81UTF-32%E4%B8%8EByte%E5%88%87%E7%89%87%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析"><a href="#Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析" class="headerlink" title="Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析"></a>Go语言中Unicode、UTF-8、UTF-16、UTF-32与Byte切片深入解析</h1><h2 id="一、Unicode与UTF编码简介"><a href="#一、Unicode与UTF编码简介" class="headerlink" title="一、Unicode与UTF编码简介"></a>一、Unicode与UTF编码简介</h2><h3 id="1-1-Unicode角色"><a href="#1-1-Unicode角色" class="headerlink" title="1.1 Unicode角色"></a>1.1 Unicode角色</h3><p>Unicode是一个字符集，为每个字符分配了一个唯一的数字（码点），确保了跨语言的字符统一表示。它覆盖了世界上几乎所有的字符，包括字母、数字、标点符号、表情符号等。</p><h3 id="1-2-UTF编码家族"><a href="#1-2-UTF编码家族" class="headerlink" title="1.2 UTF编码家族"></a>1.2 UTF编码家族</h3><p>UTF（Unicode Transformation Format）是一系列将Unicode码点转换为字节序列的规则，主要有UTF-8、UTF-16、UTF-32三种形式，它们在存储效率、内存使用和处理速度上各有特点。</p><h2 id="二、UTF-8、UTF-16、UTF-32的区别"><a href="#二、UTF-8、UTF-16、UTF-32的区别" class="headerlink" title="二、UTF-8、UTF-16、UTF-32的区别"></a>二、UTF-8、UTF-16、UTF-32的区别</h2><h3 id="2-1-UTF-8"><a href="#2-1-UTF-8" class="headerlink" title="2.1 UTF-8"></a>2.1 UTF-8</h3><ul><li><strong>变长编码</strong>：使用1到4个字节表示一个字符，ASCII字符仅需1字节，兼容ASCII。</li><li><strong>高效存储</strong>：对英文文本特别高效，节省空间。</li><li><strong>网络友好</strong>：广泛应用于网页、电子邮件等，是互联网事实上的标准编码。</li><li><strong>无字节序问题</strong>：字节序列不依赖于处理器的字节序。</li></ul><h3 id="2-2-UTF-16"><a href="#2-2-UTF-16" class="headerlink" title="2.2 UTF-16"></a>2.2 UTF-16</h3><ul><li><strong>变长编码</strong>：大多数常用字符使用2字节，辅以代理对（特殊编码序列）处理超出基本多文种平面（BMP）的字符。</li><li><strong>内存消耗</strong>：相比UTF-8，处理非BMP字符时内存使用较高。</li><li><strong>字节序问题</strong>：存在大端序（UTF-16BE）和小端序（UTF-16LE）两种存储方式，需要字节顺序标记（BOM）标识。</li></ul><h3 id="2-3-UTF-32"><a href="#2-3-UTF-32" class="headerlink" title="2.3 UTF-32"></a>2.3 UTF-32</h3><ul><li><strong>定长编码</strong>：每个字符固定使用4字节，简化了字符处理逻辑。</li><li><strong>内存消耗高</strong>：不论字符是否属于ASCII，均使用相同大小的存储空间，效率较低。</li><li><strong>简单直接</strong>：不需要复杂的编码规则，直接映射Unicode码点。</li></ul><h2 id="三、为何UTF-8使用最为广泛"><a href="#三、为何UTF-8使用最为广泛" class="headerlink" title="三、为何UTF-8使用最为广泛"></a>三、为何UTF-8使用最为广泛</h2><ul><li><strong>兼容性</strong>：与ASCII完全兼容，确保了大量现有系统的无缝过渡。</li><li><strong>效率</strong>：对英文和大部分西欧语言极为高效，节约存储和带宽。</li><li><strong>通用性</strong>：互联网标准广泛采用，几乎所有的现代系统和浏览器都默认支持UTF-8。</li><li><strong>易处理</strong>：编码规则相对简单，错误容错性较好。</li></ul><h2 id="四、Unicode与UTF-8的关系"><a href="#四、Unicode与UTF-8的关系" class="headerlink" title="四、Unicode与UTF-8的关系"></a>四、Unicode与UTF-8的关系</h2><ul><li><strong>Unicode是字符集</strong>：定义了字符到数字的映射关系。</li><li><strong>UTF-8是编码规则</strong>：将Unicode字符映射到字节序列的具体方法，是Unicode字符集的一种实现方式。</li><li><strong>存储与处理</strong>：Unicode码点经过UTF-8编码后，可以在计算机内存或文件中存储和处理。</li></ul><h2 id="五、Go语言中的Byte切片与字符串操作"><a href="#五、Go语言中的Byte切片与字符串操作" class="headerlink" title="五、Go语言中的Byte切片与字符串操作"></a>五、Go语言中的Byte切片与字符串操作</h2><p>在Go中，字符串是不可变的，内部使用UTF-8编码。将字符串转换为<code>[]byte</code>时，实际上是创建了一个包含字符串内容拷贝的可变字节序列，这对于需要修改字符内容或进行高效I&#x2F;O操作非常有用。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;Hello, 世界!&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;原始字符串:&quot;</span>, str)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为字节切片</span></span><br><span class="line">    byteSlice := []<span class="type">byte</span>(str)</span><br><span class="line">    fmt.Println(<span class="string">&quot;转换成字节切片:&quot;</span>, byteSlice)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：直接修改字节切片不会影响原字符串</span></span><br><span class="line">    modifiedByteSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(byteSlice))</span><br><span class="line">    <span class="built_in">copy</span>(modifiedByteSlice, byteSlice)</span><br><span class="line">    modifiedByteSlice[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;修改字节切片后:&quot;</span>, <span class="type">string</span>(modifiedByteSlice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Go语言在处理文本时充分利用了UTF-8编码的高效性和兼容性。理解Unicode字符集与UTF-8编码的原理，以及如何在Go中操作字符串和字节切片，对于编写高性能、国际化友好的应用至关重要。UTF-8因其实现的高效性、兼容性和广泛支持，成为了最广泛采用的Unicode编码方式。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go中的深浅拷贝</title>
      <link href="/hexo-blog/2024/06/10/go%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/hexo-blog/2024/06/10/go%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>在Go语言中，浅拷贝相对直观，通常是通过简单的赋值操作来实现，尤其对于基本数据类型和复合类型的顶层结构。以下是几种常见情况下的浅拷贝示例：</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型（如 <code>int</code>, <code>float64</code>, <code>string</code> 等）的赋值总是<strong>深拷贝</strong>，因为它们是值类型，会在栈上分配独立的内存。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">b := a <span class="comment">// 这里是深拷贝，因为基本类型是值类型</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">fmt.Println(a) <span class="comment">// 输出 10，a 不受 b 变化的影响</span></span><br></pre></td></tr></table></figure><h3 id="复合类型（如结构体、数组）"><a href="#复合类型（如结构体、数组）" class="headerlink" title="复合类型（如结构体、数组）"></a>复合类型（如结构体、数组）</h3><p>对于复合类型，直接赋值会执行<strong>浅拷贝</strong>，即复制引用或值，但不包括内部的引用类型字段。</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>如果结构体内的字段是值类型，直接赋值会进行浅拷贝，但如果是引用类型（如切片、map、指针），则复制的是引用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Friends []<span class="type">string</span> <span class="comment">// 引用类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1 := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Friends: []<span class="type">string</span>&#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;&#125;</span><br><span class="line">p2 := p1 <span class="comment">// 浅拷贝，p1 和 p2 的 Friends 字段共享同一片内存</span></span><br><span class="line">p2.Friends[<span class="number">0</span>] = <span class="string">&quot;Robert&quot;</span></span><br><span class="line">fmt.Println(p1.Friends) <span class="comment">// 输出 [&quot;Robert&quot;, &quot;Charlie&quot;]，p1 的数据也被改变了</span></span><br></pre></td></tr></table></figure><h4 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h4><p>数组的直接赋值会进行深拷贝，因为数组是值类型。而切片的赋值则是浅拷贝，因为切片是引用类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">arrCopy := arr <span class="comment">// 对于数组，这是深拷贝</span></span><br><span class="line">sliceCopy := slice <span class="comment">// 对于切片，这是浅拷贝</span></span><br><span class="line"></span><br><span class="line">sliceCopy[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 修改sliceCopy不会影响arrCopy，但会影响原始slice</span></span><br><span class="line">fmt.Println(arr)      <span class="comment">// 输出 [1, 2, 3]</span></span><br><span class="line">fmt.Println(slice)    <span class="comment">// 输出 [100, 2, 3]</span></span><br></pre></td></tr></table></figure><p>总之，浅拷贝在Go中通过基本的赋值操作就可以实现，但对于包含引用类型字段的复合类型，这种拷贝方式需要特别注意，因为它可能导致意外的数据共享。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理复习正则表达式(二)</title>
      <link href="/hexo-blog/2024/06/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/"/>
      <url>/hexo-blog/2024/06/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理复习正则表达式-二"><a href="#编译原理复习正则表达式-二" class="headerlink" title="编译原理复习正则表达式(二)"></a>编译原理复习正则表达式(二)</h1><blockquote><p>闭包 *</p><p>或运算 |</p><p>连接运算 ab</p><p>括号 ()  – 里面的优先级更高</p></blockquote><h3 id="编译原理当中的闭包"><a href="#编译原理当中的闭包" class="headerlink" title="编译原理当中的闭包"></a>编译原理当中的闭包</h3><blockquote><p>在编译原理中，”闭包”（Closure）这个术语通常关联于词法分析或词法分析器（Lexer）的设计与实现，尤其是在讨论正则表达式到有限自动机（ Finite Automata, FA）转换的过程中。不过，这里的“闭包”概念与函数式编程中的闭包（也称为词法闭包）是不同的概念。</p><p>在词法分析的上下文中，<strong>闭包</strong>是指为了识别正则表达式中的重复或递归结构，通过应用正则运算（如Kleene星号 *，表示零次或多次重复）而构建的NFA（非确定性有限自动机）的状态集合。简而言之，给定一个正则表达式的一部分，其闭包就是能够识别该部分重复任意次（包括零次）的所有可能状态的集合。</p><p>例如，如果有一个正则表达式成分 <code>a*</code>，代表字母’a’出现0次或多次，那么它的闭包在NFA中的体现就是从初始状态（代表没有看到任何’a’的情况）到看到一个或多个’a’后的所有可能状态，以及一个可以接受空串的终止状态的集合。这个过程帮助构建了一个能够识别像”a”、”aa”、”aaa”直至无限个”a”序列的自动机。</p><p>因此，编译原理中的“闭包”是一个技术性较强的概念，主要用于描述如何通过数学上的操作构造出能够有效识别复杂语言结构的自动机模型。</p></blockquote><h3 id="正则表达式使用L-a-a-，来表示匹配a这个字符，L指的是正则表达式标识符，括号里面可以存放正则表达式"><a href="#正则表达式使用L-a-a-，来表示匹配a这个字符，L指的是正则表达式标识符，括号里面可以存放正则表达式" class="headerlink" title="正则表达式使用L(a)&#x3D;{a}，来表示匹配a这个字符，L指的是正则表达式标识符，括号里面可以存放正则表达式"></a>正则表达式使用L(a)&#x3D;{a}，来表示匹配a这个字符，L指的是正则表达式标识符，括号里面可以存放正则表达式</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606173335536.png" alt="image-20240606173335536"></p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606173958856.png" alt="image-20240606173958856"></p><h3 id="无法用正则表达式产生"><a href="#无法用正则表达式产生" class="headerlink" title="无法用正则表达式产生"></a>无法用正则表达式产生</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606180241175.png" alt="image-20240606180241175"></p><h3 id="正闭包"><a href="#正闭包" class="headerlink" title="正闭包"></a>正闭包</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606200322379.png" alt="image-20240606200322379"></p><h3 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606200350286.png" alt="image-20240606200350286"></p><h3 id="任意符号"><a href="#任意符号" class="headerlink" title="任意符号"></a>任意符号</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606201023506.png" alt="image-20240606201023506"></p><h3 id="非号"><a href="#非号" class="headerlink" title="非号"></a>非号</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606201108203.png" alt="image-20240606201108203"></p><h3 id="十进制数的正则表达式"><a href="#十进制数的正则表达式" class="headerlink" title="十进制数的正则表达式"></a>十进制数的正则表达式</h3><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BA%8C)/image-20240606201943738.png" alt="image-20240606201943738"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux chmod命令教程</title>
      <link href="/hexo-blog/2024/06/06/Linux%20chmod%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"/>
      <url>/hexo-blog/2024/06/06/Linux%20chmod%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-chmod命令教程：如何更改文件和目录的权限（附实例详解和注意事项）"><a href="#Linux-chmod命令教程：如何更改文件和目录的权限（附实例详解和注意事项）" class="headerlink" title="Linux chmod命令教程：如何更改文件和目录的权限（附实例详解和注意事项）"></a>Linux chmod命令教程：如何更改文件和目录的权限（附实例详解和注意事项）</h1><h3 id="Linux-chmod命令介绍"><a href="#Linux-chmod命令介绍" class="headerlink" title="Linux chmod命令介绍"></a>Linux chmod命令介绍</h3><p><code>chmod</code>（全称：change mode）命令是用来更改文件或目录的权限。在Linux&#x2F;Unix中，文件的权限分为三级：文件所有者（Owner）、用户组（Group）、其他用户（Other Users）。只有文件所有者和超级用户可以修改文件或目录的权限。</p><h3 id="Linux-chmod命令适用的Linux版本"><a href="#Linux-chmod命令适用的Linux版本" class="headerlink" title="Linux chmod命令适用的Linux版本"></a>Linux chmod命令适用的Linux版本</h3><p><code>chmod</code>命令在所有主流的Linux发行版中都是可用的，包括但不限于Debian、Ubuntu、Alpine、Arch Linux、Kali Linux、RedHat&#x2F;CentOS、Fedora、Raspbian等。如果某个Linux发行版中没有预装<code>chmod</code>命令，用户可以通过该发行版的包管理器（如apt、yum、dnf、pacman等）来安装。</p><p>例如，在Debian或Ubuntu上，可以使用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo apt-get update</span><br><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo apt-get install coreutils</span><br></pre></td></tr></table></figure><p>在CentOS 7上，可以使用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo yum update</span><br><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo yum install coreutils</span><br></pre></td></tr></table></figure><p>在CentOS 8上，可以使用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo dnf update</span><br><span class="line">[linux@bashcommandnotfound.cn ~]$ sudo dnf install coreutils</span><br></pre></td></tr></table></figure><h3 id="Linux-chmod命令的基本语法"><a href="#Linux-chmod命令的基本语法" class="headerlink" title="Linux chmod命令的基本语法"></a>Linux chmod命令的基本语法</h3><p><code>chmod</code>命令的基本语法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [options] mode file...</span><br></pre></td></tr></table></figure><p>其中，<code>mode</code>是权限设定字符串，<code>file</code>是要更改权限的文件或目录。</p><h3 id="Linux-chmod命令的常用选项或参数说明"><a href="#Linux-chmod命令的常用选项或参数说明" class="headerlink" title="Linux chmod命令的常用选项或参数说明"></a>Linux chmod命令的常用选项或参数说明</h3><p><strong>以下是<code>chmod</code>命令的一些常用选项：</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-R</td><td>对当前目录及其子目录进行递归更改</td></tr><tr><td>-c</td><td>只有在文件权限确实更改时才显示其更改动作</td></tr><tr><td>-f</td><td>如果文件权限无法更改，不显示错误信息</td></tr><tr><td>-v</td><td>显示权限变更的详细信息</td></tr></tbody></table><h3 id="Linux-chmod命令实例详解"><a href="#Linux-chmod命令实例详解" class="headerlink" title="Linux chmod命令实例详解"></a>Linux chmod命令实例详解</h3><h4 id="实例1：更改文件权限"><a href="#实例1：更改文件权限" class="headerlink" title="实例1：更改文件权限"></a>实例1：更改文件权限</h4><p>假设我们有一个名为<code>file1.txt</code>的文件，我们想要给所有用户增加读取权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod a+r file1.txt</span><br></pre></td></tr></table></figure><p>这个命令将给<code>file1.txt</code>的所有用户增加读取权限。</p><h4 id="实例2：删除执行权限"><a href="#实例2：删除执行权限" class="headerlink" title="实例2：删除执行权限"></a>实例2：删除执行权限</h4><p>如果我们想要删除所有用户对<code>file1.txt</code>的执行权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod a-x file1.txt</span><br></pre></td></tr></table></figure><p>这个命令将删除所有用户对<code>file1.txt</code>的执行权限。</p><h4 id="实例3：递归更改目录权限"><a href="#实例3：递归更改目录权限" class="headerlink" title="实例3：递归更改目录权限"></a>实例3：递归更改目录权限</h4><p>如果我们想要递归地给一个目录及其所有子目录和文件增加读取权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod -R a+r directory</span><br></pre></td></tr></table></figure><p>这个命令将给<code>directory</code>及其所有子目录和文件的所有用户增加读取权限。</p><h4 id="实例4：设置特定权限"><a href="#实例4：设置特定权限" class="headerlink" title="实例4：设置特定权限"></a>实例4：设置特定权限</h4><p>假如我们希望设置文件所有者具有读取、写入和执行权限（rwx），其他用户则仅有读取权限（r），可以用数值方式表示，并使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod 744 file1.txt</span><br></pre></td></tr></table></figure><p>这个命令设置<code>file1.txt</code>的权限，使得文件所有者具有读取、写入和执行权限，其他用户则仅有读取权限。</p><h4 id="实例5：用符号表示法设置权位"><a href="#实例5：用符号表示法设置权位" class="headerlink" title="实例5：用符号表示法设置权位"></a>实例5：用符号表示法设置权位</h4><p>我们同时还可以以user，group，others的形式使用符号来赋予文件权限。例如，我们希望给文件所有者增加执行权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod u+x file1.txt</span><br></pre></td></tr></table></figure><p>这个命令将给<code>file1.txt</code>的文件所有者增加执行权限。</p><h4 id="实例6：以符号表示法删除权限"><a href="#实例6：以符号表示法删除权限" class="headerlink" title="实例6：以符号表示法删除权限"></a>实例6：以符号表示法删除权限</h4><p>假如我们想移除文件组的写入权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod g-w file1.txt</span><br></pre></td></tr></table></figure><p>这个命令将移除<code>file1.txt</code>的文件组写入权限。</p><h4 id="实例7-同时设置用户组和其他用户权限"><a href="#实例7-同时设置用户组和其他用户权限" class="headerlink" title="实例7: 同时设置用户组和其他用户权限"></a>实例7: 同时设置用户组和其他用户权限</h4><p>如果想要同时设置用户组（g）和其他用户（o）的权限，可以使用逗号将它们分开。例如，如果希望给用户组增加写权限，并给其他用户增加读权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod g+w,o+r file1.txt</span><br></pre></td></tr></table></figure><p>此命令将给<code>file1.txt</code>的用户组增加写权限，并给其他用户增加读权限。</p><h4 id="实例8：赋予所有权限"><a href="#实例8：赋予所有权限" class="headerlink" title="实例8：赋予所有权限"></a>实例8：赋予所有权限</h4><p>如果我们希望赋予文件所有用户所有权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod 777 file1.txt</span><br></pre></td></tr></table></figure><p>此命令将赋予<code>file1.txt</code>所有用户（用户组和其他用户）所有的读取、写入和执行权限。</p><h4 id="实例9：移除所有权限"><a href="#实例9：移除所有权限" class="headerlink" title="实例9：移除所有权限"></a>实例9：移除所有权限</h4><p>反之，如果我们希望移除文件的所有权限，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[linux@bashcommandnotfound.cn ~]$ chmod 000 file1.txt</span><br></pre></td></tr></table></figure><p>此命令将移除<code>file1.txt</code>所有用户（用户组和其他用户）的所有权限，即无法进行读取、写入或执行该文件。</p><h3 id="Linux-chmod命令的注意事项"><a href="#Linux-chmod命令的注意事项" class="headerlink" title="Linux chmod命令的注意事项"></a>Linux chmod命令的注意事项</h3><ul><li>使用<code>chmod</code>命令时，需要注意文件的所有者和当前用户的关系。只有文件的所有者和超级用户可以更改文件的权限。</li><li>在使用<code>chmod</code>命令时，如果遇到<code>bash: chmod: command not found</code>的错误，可以按照上面的方法安装<code>chmod</code>命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理复习词法分析(一)</title>
      <link href="/hexo-blog/2024/06/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
      <url>/hexo-blog/2024/06/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理复习词法分析-一"><a href="#编译原理复习词法分析-一" class="headerlink" title="编译原理复习词法分析(一)"></a>编译原理复习词法分析(一)</h1><h3 id="扫描程序"><a href="#扫描程序" class="headerlink" title="扫描程序"></a>扫描程序</h3><p>每扫一个字符拿去做判断，标识符(变量)存在字符数组里，记号(token)存在字符里</p><p><img src="/hexo-blog/./img/note/test-1/image-20240606114623650.png" alt="image-20240606114623650"></p><h3 id="不同语言的跨平台性"><a href="#不同语言的跨平台性" class="headerlink" title="不同语言的跨平台性"></a>不同语言的跨平台性</h3><p>比如说：</p><ul><li>C++ 需要编译成目标代码，与CPU指令组成，可以直接运行，缺点是跨平台性差，需要相应环境，优点的运行效率快</li><li>Python，直接使用解释器，读一行源程序，翻译成结果，缺点是效率低下，优点是跨平台性较好</li><li>Java，使用JVM虚拟机，虚拟机内将java代码编译成目标代码(不是CPU指令)，再通过解释器形成结果，结合了以上两种方式，跨平台性非常好</li></ul><p><img src="/hexo-blog/./img/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90(%E4%B8%80)/image-20240606163557134.png" alt="image-20240606163557134"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统的覆盖与交换</title>
      <link href="/hexo-blog/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/"/>
      <url>/hexo-blog/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的覆盖与交换"><a href="#操作系统的覆盖与交换" class="headerlink" title="操作系统的覆盖与交换"></a>操作系统的覆盖与交换</h1><p><img src="/hexo-blog/./img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/image-20240605170027339.png"></p><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p>覆盖技术是指一个程序的若干程序段和几个程序的某些部分共享一个存储空间。覆盖技术的实现是把程序分为若干个功能上相对独立的程序，按照其自身的逻辑结构使那些不会同时执行的程序段共享同一块内存区域。未执行的程序段先保存在磁盘上，当有关程序段的前一部分执行结束后，把后续程序段调入内存，覆盖前面的程序段。</p><p>覆盖技术是用户程序自己附加的控制。要把一个程序划分成不同的程序段，并规定好他们的执行和覆盖顺序。操作系统则根据程序员提供的覆盖结构，完成程序段之间的覆盖。</p><p>该程序正文段所需要的内存空间是A（8KB）+B（8KB）+C（10KB）+D（12KB）+E（4KB）+F（10KB）&#x3D;52KB，但是在采用了覆盖技术后只需要A（8KB）+C（10KB）+D（12KB）&#x3D;30KB占用空间。</p><p><img src="/hexo-blog/./img/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/2070dd8b6a6127f2e072d2b09c37cf77.png" alt="img"></p><p>覆盖技术主要用于系统程序的内存管理上，MS-DOS系统分为两个部分。</p><ul><li>操作系统中经常要用到的基本部分，它们常驻在内存且占用固定区域。</li><li>不太经常使用的部分，它们存放在磁盘上，当调用它们时才被调入内存覆盖区。</li></ul><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>交换技术：在分时系统中，用户的进程比内存能容纳的数量要多，这就需要在磁盘上保存那些内存放不下的进程。在需要运行这些进程时，再将它们装入内存。</p><p>进程从内存移到磁盘并再移动回内存称为交换。交换技术是进程在内存与外存之间的动态调度，是由操作系统控制的。</p><p>后备存储区（又称盘交换区）。</p><p>目的：尽可能达到”足够快的交换进程，以使当CPU调度程序想重新调度CPU时，总有进程在内存中处于就绪（准备执行）状态“的理想状态，从而提高内存利用率。</p><p><strong>交换技术的原理：</strong></p><p>（1）换出进程的选择：系统需要将内存中的进程换出时，应该选择那个进程？</p><p>根据时间片轮转法或基于优先数的调度算法来选择要换出的进程。</p><p>（2）交换时间的确定</p><p>在内存空间不够或有不够的危险时，还出内存中的部分进程到外存，以释放所需要的内存。</p><p>（3）交换空间的分配</p><p>在一些系统中，当进程在内存中时，不再外塔分配磁盘空间。当它被换出时，必须为它分配磁盘交换空间。</p><p>在另一些系统中，进程一但创建，就分配给它磁盘上的交换空间。无论何时程序被换出，他都被换到已经为它分配的空间，而不是每次换到不同的空间。</p><p>（4）换入进程换回内存时位置的确定</p><p>绝对地址：在原来的位置上；</p><p>相对地址：可再进行地址重定位。</p><p>交换技术的缺点：</p><p>由于交换时需要花费大量的CPU时间，这将影响对用户的响应时间，因此，减少交换的信息量是交换技术的关键问题。</p><p>合理的做法：</p><p>在外存中保留每个程序的交换副本，换出时仅将执行时修改过的部分复制到外存。</p><p><strong>覆盖技术和交换技术的发展导致了虚拟存储技术的出现。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理的概念</title>
      <link href="/hexo-blog/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/hexo-blog/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h1><p><img src="/hexo-blog/./img/note/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20240605150316382.png" alt="image-20240605150316382"></p><h3 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h3><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><ul><li><strong>连续分配管理</strong>：早期的内存管理方法，如单一连续分配、固定分区、可变分区等，通过系统保留表跟踪哪些内存块已被分配或空闲，然后为进程分配连续的内存区域。</li><li><strong>非连续分配管理</strong>：如分页（Page）和分段（Segmentation）机制，以及两者的结合（段页式），操作系统将物理内存分割成固定大小的页或可变大小的段，为每个进程建立虚拟地址到物理地址的映射，从而实现了灵活的内存分配和保护。</li></ul><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><ul><li>当进程结束或不再需要某些内存时，操作系统负责回收这些内存空间，更新内存分配表，使其标记为可用状态，并可能合并相邻的空闲块以减少碎片。</li></ul><h3 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h3><h4 id="计算机物理内存（RAM）扩充"><a href="#计算机物理内存（RAM）扩充" class="headerlink" title="计算机物理内存（RAM）扩充"></a>计算机物理内存（RAM）扩充</h4><ol><li><strong>增加内存条</strong>：这是最直接的方式，购买与主板兼容的内存条并安装到空闲的内存插槽中。需要确保新内存条的规格（如DDR代数、频率、电压等）与现有内存相匹配。</li><li><strong>使用内存扩展技术</strong>：某些现代笔记本或主板支持特殊的内存扩展技术，如Intel的Optane Memory，虽不是直接增加RAM，但可以加速访问常用的数据和提升系统响应速度。</li></ol><h4 id="虚拟内存扩充"><a href="#虚拟内存扩充" class="headerlink" title="虚拟内存扩充"></a>虚拟内存扩充</h4><ol><li><strong>调整虚拟内存设置</strong>：在操作系统中，可以通过设置增大虚拟内存（页面文件）的大小，将一部分硬盘空间作为额外的内存使用。虽然这能暂时缓解物理内存不足的问题，但因硬盘速度远慢于RAM，可能会导致系统运行变慢。</li><li><strong>使用Swap分区</strong>：在Linux系统中，可以通过创建或调整Swap分区大小来扩充虚拟内存。Swap分区充当物理内存的补充，当物理内存耗尽时，操作系统会将部分内存数据暂时移到Swap分区。</li></ol><h4 id="移动设备（如手机）存储空间扩充"><a href="#移动设备（如手机）存储空间扩充" class="headerlink" title="移动设备（如手机）存储空间扩充"></a>移动设备（如手机）存储空间扩充</h4><ol><li><p><strong>外部存储卡</strong>：如果设备支持，可以插入microSD卡或nanoSD卡等外部存储卡来增加存储空间。注意，这一般只增加存储空间，而非运行内存（RAM）。</p></li><li><p><strong>云存储服务</strong>：使用云存储服务（如Google云端硬盘、iCloud、百度网盘等）备份照片、视频和文档，释放本地存储空间。</p></li><li><p><strong>内存清理与优化</strong>：通过清理缓存、卸载不常用应用、转移文件到云存储等方式，有效管理现有存储空间，间接“扩充”可用空间。</p></li></ol><blockquote><p>假如说我现在电脑下了22.04的ubuntu系统，我分配给他的是4GB物理内存，30GB固态内存。</p><p>我在虚拟机上下载了过多软件，导致物理内存超过了4GB，然后需要在虚拟机上借用部分虚拟内存，来自磁盘(30GB)来保证虚拟机的正常运行</p></blockquote><h3 id="内存的地址转换"><a href="#内存的地址转换" class="headerlink" title="内存的地址转换"></a>内存的地址转换</h3><p>在操作系统中，程序的装入方式是内存管理的一个重要方面，不同的装入方式对应着不同的程序执行环境和内存管理策略。以下是三种经典的程序装入方式：</p><h4 id="1-绝对装入（Absolute-Loading）"><a href="#1-绝对装入（Absolute-Loading）" class="headerlink" title="1. 绝对装入（Absolute Loading）"></a>1. 绝对装入（Absolute Loading）</h4><p><strong>定义</strong>：绝对装入方式是指在编译时就确定了程序将要驻留在内存中的物理地址。程序的目标代码中所使用的地址都是物理内存的绝对地址，没有相对地址或虚拟地址的概念。</p><p><strong>特点</strong>：</p><ul><li>简单直接，不需要在程序执行时进行地址转换。</li><li>编译时就必须知道确切的内存位置，限制了程序的灵活性和系统的并发能力。</li><li>仅适用于单任务、无虚拟内存的操作系统环境。</li></ul><h4 id="2-可重定位装入（Relocatable-Loading）"><a href="#2-可重定位装入（Relocatable-Loading）" class="headerlink" title="2. 可重定位装入（Relocatable Loading）"></a>2. 可重定位装入（Relocatable Loading）</h4><p><strong>定义</strong>：可重定位装入方式允许程序在编译时使用相对地址（或基址加上偏移量的形式），而不是绝对地址。在程序装入内存时，操作系统会根据实际分配给程序的内存起始地址对程序的所有地址引用进行统一调整（重定位），使得程序可以在不同的内存位置正确执行。</p><p><strong>特点</strong>：</p><ul><li>提高了程序的灵活性和可移植性，支持程序在不同内存配置的环境中运行。</li><li>需要在程序首次装入内存或在内存中移动时进行地址重定位操作。</li><li>支持多道程序设计，但程序运行前必须全部装入内存。</li></ul><h4 id="3-动态运行时装入（Dynamic-Run-Time-Loading）"><a href="#3-动态运行时装入（Dynamic-Run-Time-Loading）" class="headerlink" title="3. 动态运行时装入（Dynamic Run-Time Loading）"></a>3. 动态运行时装入（Dynamic Run-Time Loading）</h4><p><strong>定义</strong>：动态运行时装入方式是指程序在开始执行之前不必全部装入内存，而是在程序运行过程中，根据需要将代码和数据段逐步调入内存。这种机制允许程序的某些部分（如很少使用的模块）保留在外存上，直到真正需要时才加载到内存。</p><p><strong>特点</strong>：</p><ul><li>大幅节省了内存空间，提高了内存利用率，支持更大规模的程序执行。</li><li>支持按需加载和动态链接库（DLLs或SOs），增强了程序的灵活性和扩展性。</li><li>需要复杂的内存管理和虚拟内存支持，操作系统需维护内存分配表，跟踪已装入和未装入的部分。</li><li>增加了程序执行的开销，因为频繁的页面置换可能导致额外的磁盘I&#x2F;O和处理时间。</li></ul><p>总结来说，绝对装入是最简单但最不灵活的方式；可重定位装入提升了程序的灵活性；而动态运行时装入则进一步提高了内存效率和程序的动态扩展能力，是现代操作系统中普遍采用的内存管理技术。</p><h3 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h3><p>界地址寄存器（Bound Register）是计算机系统中用于实现存储保护的一种硬件机制，特别是在较早的计算机体系结构中较为常见。界地址寄存器主要用于限制进程访问内存的范围，防止进程越界访问其他进程或系统内存区域。以下是设置界地址寄存器的基本概念和步骤：</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ol><li><strong>下限寄存器（Lower Bound Register）</strong>：存储进程地址空间的最低地址。</li><li><strong>上限寄存器（Upper Bound Register）</strong>：存储进程地址空间的最高地址。</li><li><strong>访问检查</strong>：每当CPU发出一个内存访问请求时，硬件会自动将请求的地址与这两个寄存器的值进行比较。</li><li><strong>越界处理</strong>：如果请求的地址低于下限寄存器的值或者高于上限寄存器的值，说明访问越界，硬件将产生一个越界中断（存储保护中断），操作系统接收到这个中断后会采取相应的错误处理措施，比如终止该进程。</li></ol><h4 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h4><ol><li><p><strong>初始化</strong>：在进程切换时，操作系统会根据进程的内存分配情况，将该进程在内存中的起始地址加载到下限寄存器，结束地址加载到上限寄存器。这通常发生在进程调度时，确保每个新运行的进程都有正确的界限设置。</p></li><li><p><strong>硬件集成</strong>：界地址检查功能通常集成在CPU的内存管理硬件中，因此设置界限寄存器的操作对程序员来说是透明的，由操作系统内核完成。</p></li><li><p><strong>动态调整</strong>：在某些系统中，如果进程的地址空间在运行时动态变化（比如通过分配或释放内存），操作系统需要更新这些寄存器的值以反映新的地址边界。</p></li><li><p><strong>中断处理</strong>：操作系统还需要编写中断处理程序来响应越界中断，处理程序会决定如何响应这一错误，比如记录日志、通知用户、或者终止进程。</p></li></ol><p>随着技术的发展，现代处理器和操作系统更多采用分页和分段机制来实现更灵活的内存管理和保护，界地址寄存器的使用相对减少，但其基本思想仍体现在现代存储保护机制中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go中string转int</title>
      <link href="/hexo-blog/2024/06/04/go%E4%B8%ADstring%E8%BD%ACint/"/>
      <url>/hexo-blog/2024/06/04/go%E4%B8%ADstring%E8%BD%ACint/</url>
      
        <content type="html"><![CDATA[<h3 id="strconv-包"><a href="#strconv-包" class="headerlink" title="strconv 包"></a>strconv 包</h3><p><code>strconv.Atoi</code> 的读法是 “strconv Atoi”。</p><p>这里稍微解释一下每个部分：</p><ul><li><code>strconv</code> 是一个包名，在 Go 语言中，<code>strconv</code> 包提供了用于字符串和基本数值类型之间转换的函数，它的全称是 “String to Integer Conversion Package”。</li><li><code>Atoi</code> 是函数名，其中 <code>Atoi</code> 是从英文 “ASCII to Integer” 缩写而来，表示将 ASCII 字符串转换成整数（integer）。在 Go 语言中，<code>Atoi</code> 函数用于将一个表示十进制整数的字符串转换为 <code>int</code> 类型的整数。</li></ul><p>因此，当你在读这段代码时，你可以这样说：“使用 strconv 包的 Atoi 函数”。在口语中，你可能会简化为：“使用 strconv 的 Atoi 函数”。</p><p>在 Go 语言中，你可以使用<code>strconv</code>包里的函数来实现<code>string</code>类型到<code>int</code>类型或者更具体的整数类型的转换。以下是几种常见的转换方式：</p><ol><li><p><strong>转换为<code>int</code>类型</strong>:<br>使用<code>Atoi</code>函数可以将字符串转换为<code>int</code>类型，但是它只能处理没有超出<code>int</code>范围的数字，并且不支持负数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;123&quot;</span></span><br><span class="line">    i, err := strconv.Atoi(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>转换为<code>int64</code>类型</strong>:<br>使用<code>ParseInt</code>函数可以将字符串转换为<code>int64</code>类型，并且可以指定基数和位宽。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;123456&quot;</span></span><br><span class="line">    i, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>转换为<code>int32</code>类型</strong>:<br>类似地，你也可以使用<code>ParseInt</code>函数，只是在位宽参数处指定<code>32</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure></li></ol><p>这些函数都会返回一个错误值<code>err</code>，如果转换失败（例如，字符串不是有效的数字），你需要检查这个错误并处理它。通常的做法是使用<code>if err != nil</code>来判断是否有错误发生。如果字符串包含非数字字符或无法解析的格式，<code>err</code>将被设置，因此必须检查<code>err</code>以避免程序崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go中解决类型别名与原始类型不匹配的问题</title>
      <link href="/hexo-blog/2024/06/04/go%E4%B8%AD%E8%A7%A3%E5%86%B3%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/hexo-blog/2024/06/04/go%E4%B8%AD%E8%A7%A3%E5%86%B3%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="GoLang中解决类型别名与原始类型不匹配的问题"><a href="#GoLang中解决类型别名与原始类型不匹配的问题" class="headerlink" title="GoLang中解决类型别名与原始类型不匹配的问题"></a>GoLang中解决类型别名与原始类型不匹配的问题</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在Go项目中，我们可能会遇到使用类型别名来封装或简化某些类型定义的情况。例如，在DAO层为了代码组织或接口清晰，可能会对原始类型进行别名定义。然而，当在Service层或其他层级试图使用原始类型时，由于Go的强类型系统，即使类型别名和原始类型具有相同的结构，也会遇到类型不匹配的错误。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>假设在DAO层定义了一个类型别名<code>Content</code>，它是<code>models.ContentModel</code>的别名。但在Service层，我们尝试返回或使用<code>models.ContentModel</code>类型时，会遇到编译错误，提示类型不匹配。</p><h4 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h4><p><strong>ArticleDao.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Content models.ContentModel</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao *ArticleDaoImpl)</span></span> GetContent(id <span class="type">int</span>) Content &#123;</span><br><span class="line"><span class="keyword">var</span> content Content</span><br><span class="line"><span class="keyword">var</span> article = models.ArticleModel&#123;ID: id&#125;</span><br></pre></td></tr></table></figure><p><strong>ArticleService.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(service *ArticleServiceImpl)</span></span> GetContent(id <span class="type">int</span>) models.ContentModel &#123;</span><br><span class="line">    <span class="keyword">return</span> service.dao.GetContent(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：类型转换"><a href="#方案一：类型转换" class="headerlink" title="方案一：类型转换"></a>方案一：类型转换</h5><p>在Service层，可以通过类型转换的方式，将从DAO层获取的<code>Content</code>类型转换为<code>models.ContentModel</code>类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(service *ArticleServiceImpl)</span></span> GetContent(id <span class="type">int</span>) models.ContentModel &#123;</span><br><span class="line">    content := service.dao.GetContent(id) <span class="comment">// 此处content类型为Content</span></span><br><span class="line">    <span class="keyword">return</span> models.ContentModel(content)  <span class="comment">// 将Content转换为models.ContentModel</span></span><br><span class="line">&#125; </span><br><span class="line">OR</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(service *ArticleServiceImpl)</span></span> GetContent(id <span class="type">int</span>) dao.Content &#123;</span><br><span class="line"><span class="keyword">return</span> service.dao.GetContent(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方案二：统一类型使用"><a href="#方案二：统一类型使用" class="headerlink" title="方案二：统一类型使用"></a>方案二：统一类型使用</h5><p>更好的实践是在整个项目中统一使用一种类型。这意味着，如果在DAO层使用了<code>Content</code>作为类型别名，那么在Service层也应该使用<code>Content</code>类型。或者，如果决定使用<code>models.ContentModel</code>，则DAO层的<code>GetContent</code>方法应该返回<code>models.ContentModel</code>类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao *ArticleDaoImpl)</span></span> GetContent(id <span class="type">int</span>) models.ContentModel &#123;</span><br><span class="line">    <span class="keyword">var</span> content models.ContentModel</span><br><span class="line">    <span class="keyword">var</span> article = models.ArticleModel&#123;ID: id&#125;</span><br><span class="line">    dao.DB.Model(&amp;article).Association(<span class="string">&quot;ContentModel&quot;</span>).Find(&amp;content)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，Service层可以直接接收<code>models.ContentModel</code>类型，无需进行额外的类型转换。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在Go项目中，虽然类型别名可以提供代码的清晰度和可读性，但在跨层使用时需要特别注意类型匹配问题。通过类型转换或统一类型使用，我们可以有效地解决类型不匹配的问题，确保项目的顺利运行和代码的高质量。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过以上修改，可以有效解决由类型别名引起的类型不匹配问题，确保代码的正确性和一致性。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法</title>
      <link href="/hexo-blog/2024/06/03/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
      <url>/hexo-blog/2024/06/03/%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h3 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h3><p><img src="/hexo-blog/./img/note/%E5%88%86%E6%B2%BB%E6%B3%95/2024-06-03-20-37-08-image.png" alt="2024-06-03-20-37-08-image"></p><h3 id="分治算法的基本思想"><a href="#分治算法的基本思想" class="headerlink" title="分治算法的基本思想"></a>分治算法的基本思想</h3><p><img src="/hexo-blog/./img/note/%E5%88%86%E6%B2%BB%E6%B3%95/2024-06-03-20-49-05-image.png" alt="2024-06-03-20-49-05-image"></p><h3 id="Karatsuba算法：大整数乘法的优化算法"><a href="#Karatsuba算法：大整数乘法的优化算法" class="headerlink" title="Karatsuba算法：大整数乘法的优化算法"></a>Karatsuba算法：大整数乘法的优化算法</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>Karatsuba算法是一种高效的大数乘法技术，它通过递归地分割输入数并使用较少的基本乘法步骤来计算结果，从而显著减少了计算时间。</p><h4 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h4><h5 id="分割输入数"><a href="#分割输入数" class="headerlink" title="分割输入数"></a>分割输入数</h5><p>当计算两个大数<code>A</code>和<code>B</code>的乘积时，首先将每个数分为两部分：</p><ul><li><code>A</code>分为<code>A高位</code>和<code>A低位</code></li><li><code>B</code>分为<code>B高位</code>和<code>B低位</code></li></ul><p>假设<code>A</code>和<code>B</code>都是偶数位数，可以表示为：</p><p>A &#x3D; A高位 * 10^(n&#x2F;2) + A低位<br>B &#x3D; B高位 * 10^(n&#x2F;2) + B低位</p><p>其中<code>n</code>是数的总位数。</p><h5 id="减少乘法次数"><a href="#减少乘法次数" class="headerlink" title="减少乘法次数"></a>减少乘法次数</h5><p>常规乘法需要计算四个乘积：</p><ol><li><code>A高位 * B高位</code></li><li><code>A高位 * B低位</code></li><li><code>A低位 * B高位</code></li><li><code>A低位 * B低位</code></li></ol><p>然而，Karatsuba算法巧妙地利用代数恒等式，只需计算三个乘积：</p><ul><li><code>P1 = A高位 * B高位</code></li><li><code>P2 = A低位 * B低位</code></li><li><code>P3 = (A高位 + A低位) * (B高位 + B低位)</code></li></ul><p>然后，原式中的中间项可以表示为<code>P3 - P1 - P2</code>，因此我们有：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AB = P1 * 10^n + (P3 - P1 - P2) * 10^(n/2) + P2</span><br></pre></td></tr></table></figure><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>通过这种方法，Karatsuba算法成功地将所需的乘法次数从五项减少到了三项，大大提高了大数乘法的效率。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取大整数的前后半部分并返回</span></span><br><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">get</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = num / <span class="built_in">pow</span>(<span class="number">10</span>, length / <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> num2 = num - num1 * <span class="built_in">pow</span>(<span class="number">10</span>, length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_tuple</span>(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大整数乘法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Karatsuba</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [a1, a2] = <span class="built_in">get</span>(A, length);</span><br><span class="line">    <span class="keyword">auto</span> [b1, b2] = <span class="built_in">get</span>(B, length);</span><br><span class="line">    <span class="keyword">auto</span> [P1, P2, P3] = <span class="built_in">make_tuple</span>(a1 * b1, (a1 + a2) * (b1 + b2), a2 * b2);</span><br><span class="line">    cout &lt;&lt; <span class="function">P1 * <span class="title">pow</span><span class="params">(<span class="number">10</span>, length)</span> + <span class="params">(P2 - P1 - P3)</span> * <span class="title">pow</span><span class="params">(<span class="number">10</span>, length / <span class="number">2</span>)</span> + P3 &lt;&lt; endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的基本概念</title>
      <link href="/hexo-blog/2024/06/03/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/hexo-blog/2024/06/03/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="算法的基本的概念"><a href="#算法的基本的概念" class="headerlink" title="算法的基本的概念"></a>算法的基本的概念</h1><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote><p>0个及以上输入</p><p>1个及以上输出</p><p>有穷性(不存在死循环)</p><p>确定性(每次执行的结果一样)</p><p>可行性(不会爆出警告)</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="渐进复杂性"><a href="#渐进复杂性" class="headerlink" title="渐进复杂性"></a>渐进复杂性</h3><p><img src="/hexo-blog/./img/note/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2024-06-03-20-17-45-image.png" alt="2024-06-03-20-17-45-image"></p><h3 id="渐进记号"><a href="#渐进记号" class="headerlink" title="渐进记号"></a>渐进记号</h3><p><img src="/hexo-blog/./img/note/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2024-06-03-20-15-54-image.png" alt="2024-06-03-20-15-54-image"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出去吃牛肉自助</title>
      <link href="/hexo-blog/2024/06/03/%E5%87%BA%E5%8E%BB%E5%90%83%E7%89%9B%E8%82%89%E8%87%AA%E5%8A%A9/"/>
      <url>/hexo-blog/2024/06/03/%E5%87%BA%E5%8E%BB%E5%90%83%E7%89%9B%E8%82%89%E8%87%AA%E5%8A%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="出去吃牛肉自助"><a href="#出去吃牛肉自助" class="headerlink" title="出去吃牛肉自助"></a>出去吃牛肉自助</h1><p><img src="/hexo-blog/./img/note/%E5%87%BA%E5%8E%BB%E5%90%83%E7%89%9B%E8%82%89%E8%87%AA%E5%8A%A9/2024-06-03-12-20-54-image.png" alt="2024-06-03-12-20-54-image"></p><p><strong>张哞哞·鲜切牛肉自助火锅(广州高德置地广场店)</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对hexo博客的一些理解</title>
      <link href="/hexo-blog/2024/06/03/%E5%AF%B9hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
      <url>/hexo-blog/2024/06/03/%E5%AF%B9hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="对hexo博客的一些理解"><a href="#对hexo博客的一些理解" class="headerlink" title="对hexo博客的一些理解"></a>对hexo博客的一些理解</h1><h3 id="记录：2024-6-3"><a href="#记录：2024-6-3" class="headerlink" title="记录：2024&#x2F;6&#x2F;3"></a>记录：2024&#x2F;6&#x2F;3</h3><ul><li><p>首先我在接触<strong>hexo</strong>前接触过vuepress，其实两者非常类似</p></li><li><p>相比于vuepress，hexo功能更加全面，不过配置起来更加繁琐</p></li></ul><blockquote><p>  感觉总体还行，只不过都是写静态文件，直接书写简单的markdown，你就能弄一个很好看的网页出来，而且他的背后帮你做了很多事情，比如说路由处理，打包部署，SEO搜索引擎优化等等。但是虽然花里胡哨的样式很多，但也带来了很多缺点，比如引入过多样式会造成页面异常卡顿，数据存在db.json当中，不太好，当数据量一大，数据就加载不过来了。</p><p>  所以还是要理性对待，把他当成日常笔记本来写写就行，部署到GitHub Pages上，非常方便。</p></blockquote><h3 id="vuepress和hexo的对比"><a href="#vuepress和hexo的对比" class="headerlink" title="vuepress和hexo的对比"></a>vuepress和hexo的对比</h3><h6 id="vuepress-文件夹docs下就是网页的根目录，vuepress会根据你的文件路径给你定义路由"><a href="#vuepress-文件夹docs下就是网页的根目录，vuepress会根据你的文件路径给你定义路由" class="headerlink" title="vuepress:文件夹docs下就是网页的根目录，vuepress会根据你的文件路径给你定义路由"></a>vuepress:文件夹docs下就是网页的根目录，vuepress会根据你的文件路径给你定义路由</h6><p>路由在<mark>.vuepress&#x2F;config.js</mark>配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; viteBundler &#125; <span class="keyword">from</span> <span class="string">&#x27;@vuepress/bundler-vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defaultTheme &#125; <span class="keyword">from</span> <span class="string">&#x27;@vuepress/theme-default&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineUserConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vuepress&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineUserConfig</span>(&#123;</span><br><span class="line">  <span class="attr">bundler</span>: <span class="title function_">viteBundler</span>(&#123;</span><br><span class="line">    <span class="attr">viteOptions</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">vuePluginOptions</span>: &#123;&#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">theme</span>: <span class="title function_">defaultTheme</span>(&#123;</span><br><span class="line">    <span class="string">&quot;/note/&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;操作系统&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/操作系统/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Django&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Django/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Docker&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Docker/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Git&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Git/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;OpenGuass&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/openguass/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;uni-app&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/uni-app/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Go&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Go/&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">&quot;Vue&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/note/Vue/&quot;</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    options...</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">lang</span>: <span class="string">&#x27;zh-CN&#x27;</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;学习文档&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;欢迎来到浩瀚星河的小站&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="hexo-统一在-config-butterfly-yml中配置，包含所有的配置信息"><a href="#hexo-统一在-config-butterfly-yml中配置，包含所有的配置信息" class="headerlink" title="hexo:统一在_config.butterfly.yml中配置，包含所有的配置信息"></a>hexo:统一在<mark>_config.butterfly.yml</mark>中配置，包含所有的配置信息</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"><span class="comment"># 背景和图标</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/favicon.png</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/avatar.png</span> <span class="comment">#图片路径</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span> <span class="comment">#头像会一直转圈</span></span><br><span class="line"><span class="comment"># The banner image of home page</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/img/background.jpg</span></span><br><span class="line"><span class="comment"># 文章详情页</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">/img/default_top_img.png</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span> <span class="comment">#  是否展示文章封面</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span> <span class="comment"># 封面展示的位置 left/right/both</span></span><br><span class="line"><span class="attr">error_img:</span></span><br><span class="line">  <span class="attr">flink:</span> <span class="string">/img/friend_404.gif</span></span><br><span class="line">  <span class="attr">post_page:</span> <span class="string">/img/404.jpg</span></span><br><span class="line"><span class="attr">medium_zoom:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># copy settings</span></span><br><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启网站复制权限</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="comment"># 复制的内容后面加上版权信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 是否开启复制版权信息添加</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">50</span> <span class="comment"># 字数限制，当复制文字大于这个字数限制时</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:struggle-upwards/hexo-blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h3 id="两种方式构建"><a href="#两种方式构建" class="headerlink" title="两种方式构建"></a>两种方式构建</h3><blockquote><p><a href="https://struggle-upwards.github.io/hexo-blog/">我的博客(hexo)</a><br><a href="https://struggle-upwards.github.io/">我的文档(vuepress)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqloj数据库作业</title>
      <link href="/hexo-blog/2024/06/01/sqloj%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A/"/>
      <url>/hexo-blog/2024/06/01/sqloj%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="sqloj数据库作业"><a href="#sqloj数据库作业" class="headerlink" title="sqloj数据库作业"></a>sqloj数据库作业</h1><h2 id="以下是100-正确率"><a href="#以下是100-正确率" class="headerlink" title="以下是100%正确率"></a>以下是100%正确率</h2><h2 id="一-单表查询"><a href="#一-单表查询" class="headerlink" title="一.单表查询"></a>一.单表查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 课程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 学号 <span class="keyword">from</span> 成绩;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> 成绩 <span class="keyword">set</span> 成绩 <span class="operator">=</span> 成绩<span class="operator">+</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> 学号,成绩 <span class="keyword">from</span> 成绩;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 学号 <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 课程号<span class="operator">=</span>&quot;1026&quot; <span class="keyword">and</span> 成绩<span class="operator">&lt;</span><span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 成绩 <span class="keyword">between</span> <span class="number">60</span> <span class="keyword">and</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 成绩 <span class="keyword">in</span> (<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 学生 <span class="keyword">where</span> 姓名 <span class="operator">=</span> &quot;马*&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 成绩 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 学号,姓名,性别 <span class="keyword">from</span> 学生 <span class="keyword">order</span> <span class="keyword">by</span> 学号 <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 学生 <span class="keyword">order</span> <span class="keyword">by</span> 性别 <span class="keyword">asc</span>,学号 <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 学号 <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 课程号 <span class="operator">=</span> &quot;1026&quot; <span class="keyword">order</span> <span class="keyword">by</span> 成绩 limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="二-连接查询"><a href="#二-连接查询" class="headerlink" title="二.连接查询"></a>二.连接查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 学生.学号,学生.姓名 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 成绩.课程号<span class="operator">=</span>&quot;1025&quot; <span class="keyword">order</span> <span class="keyword">by</span> 学号 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 姓名 <span class="keyword">from</span> 课程 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 课程.课程号<span class="operator">=</span>成绩.课程号 <span class="keyword">inner</span> <span class="keyword">join</span> 学生 <span class="keyword">on</span> 成绩.学号<span class="operator">=</span>学生.学号 <span class="keyword">where</span> 课程名<span class="operator">=</span>&quot;数据库&quot; <span class="keyword">order</span> <span class="keyword">by</span> 姓名 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 学生.学号 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 成绩.课程号 <span class="keyword">in</span> (<span class="keyword">select</span> 课程号 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 学生.学号<span class="operator">=</span>&quot;202101231234&quot;) <span class="keyword">order</span> <span class="keyword">by</span> 学生.学号;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 学生.学号,姓名,班级,身份证号,课程号,成绩 <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 成绩.学号<span class="operator">=</span>学生.学号 <span class="keyword">order</span> <span class="keyword">by</span> 学号 <span class="keyword">asc</span>,课程号 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 姓名 <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 姓名 <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> 姓名 <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 课程号<span class="operator">=</span>&quot;1025&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 姓名 <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 成绩 <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(成绩) <span class="keyword">from</span> 学生 <span class="keyword">left</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 课程号<span class="operator">=</span>&quot;1025&quot;) <span class="keyword">and</span> 课程号<span class="operator">=</span>&quot;1025&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 成绩 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 姓名<span class="operator">=</span>&quot;贺易&quot; <span class="keyword">and</span> 课程号<span class="operator">=</span>&quot;1025&quot;;</span><br></pre></td></tr></table></figure><h2 id="三-聚合与分组查询"><a href="#三-聚合与分组查询" class="headerlink" title="三.聚合与分组查询"></a>三.聚合与分组查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(身份证号) <span class="keyword">from</span> 学生;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(课程号) <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 姓名<span class="operator">=</span>&quot;张怡&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(成绩) <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">where</span> 学生.学号<span class="operator">=</span>&quot;202101231234&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(课程号) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> 课程号 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号) <span class="keyword">as</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 课程号,<span class="built_in">avg</span>(成绩) <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">group</span> <span class="keyword">by</span> 课程号 <span class="keyword">order</span> <span class="keyword">by</span> 课程号 <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 课程号,<span class="built_in">count</span>(学生.学号) <span class="keyword">as</span> count_num <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">group</span> <span class="keyword">by</span> 课程号 <span class="keyword">having</span> count_num<span class="operator">&gt;=</span><span class="number">5</span> <span class="keyword">order</span> <span class="keyword">by</span> count_num <span class="keyword">desc</span>,课程号 <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><h2 id="四-数据更新"><a href="#四-数据更新" class="headerlink" title="四.数据更新"></a>四.数据更新</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 成绩 <span class="keyword">where</span> 学号  <span class="operator">=</span>  (<span class="keyword">select</span> 学号 <span class="keyword">from</span> 学生 <span class="keyword">where</span> 姓名 <span class="operator">=</span> &quot;刘玉&quot;);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 学生 <span class="keyword">where</span> 姓名 <span class="operator">=</span> &quot;刘玉&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 成绩  <span class="keyword">where</span> 学号 <span class="keyword">in</span> (<span class="keyword">select</span>  学号 <span class="keyword">from</span> 学生 <span class="keyword">where</span> 班级 <span class="operator">=</span> &quot;21医学院&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 课程 <span class="keyword">values</span>(&quot;1032&quot;,&quot;大学物理&quot;,<span class="number">64</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 学生 <span class="keyword">values</span>(&quot;650307200209225678&quot;,&quot;202101231255&quot;,&quot;陈静&quot;,&quot;女&quot;,<span class="keyword">null</span>,&quot;2001-12-29&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `学生平均分` (</span><br><span class="line">  `学号` <span class="type">varchar</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `平均分` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`学号`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `学生平均分`(`学号`, `平均分`) <span class="keyword">SELECT</span> `学号`,<span class="built_in">AVG</span>(`成绩`) <span class="keyword">AS</span> `平均分` <span class="keyword">FROM</span> `成绩` <span class="keyword">GROUP</span> <span class="keyword">BY</span> `学号`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> 成绩 <span class="keyword">set</span> 成绩<span class="operator">=</span>成绩<span class="operator">+</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> 课程 <span class="keyword">set</span> 课程名<span class="operator">=</span>&quot;大学计算机基础&quot; <span class="keyword">where</span> 课程名<span class="operator">=</span>&quot;计算机基础&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> 成绩 <span class="keyword">set</span> 成绩 <span class="operator">=</span> <span class="number">0</span> <span class="keyword">where</span> 学号 <span class="keyword">in</span> (<span class="keyword">select</span> 学号 <span class="keyword">from</span> 学生 <span class="keyword">where</span> 班级<span class="operator">=</span>&quot;21计算机学院&quot;);</span><br></pre></td></tr></table></figure><h2 id="五-视图管理"><a href="#五-视图管理" class="headerlink" title="五.视图管理"></a>五.视图管理</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CS21_S <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 学生 <span class="keyword">where</span> 班级 <span class="operator">=</span> &quot;21计算机学院&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> S_C_G  <span class="keyword">as</span> <span class="keyword">select</span> 学生.学号,姓名,课程名,成绩 <span class="keyword">from</span> 学生 <span class="keyword">inner</span> <span class="keyword">join</span> 成绩 <span class="keyword">on</span> 学生.学号<span class="operator">=</span>成绩.学号 <span class="keyword">inner</span> <span class="keyword">join</span> 课程 <span class="keyword">on</span> 成绩.课程号<span class="operator">=</span>课程.课程号;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> S_C_G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> CS21_S <span class="keyword">where</span> 性别<span class="operator">=</span>&quot;女&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql画er图</title>
      <link href="/hexo-blog/2024/06/01/mysql%E7%94%BBer%E5%9B%BE/"/>
      <url>/hexo-blog/2024/06/01/mysql%E7%94%BBer%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库画er图"><a href="#数据库画er图" class="headerlink" title="数据库画er图"></a>数据库画er图</h1><blockquote><p>根据描述直接在navicat画ER图,生成factory,product,department,employee,telephone,manager一共6张表</p></blockquote><p><strong>ER图</strong></p><p><img src="/hexo-blog/./img/note/mysql%E7%94%BBer%E5%9B%BE/image-20240601213847759.png" alt="image-20240601213847759"></p><p><strong>迁移数据库</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`department`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `depart_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`, `depart_id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`employee`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `job` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `depart_foreign_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`, `depart_foreign_id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`factory`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`manager`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `job` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `depart_foreign_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`, `depart_foreign_id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`product`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`table_1`  ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test5`.`telephone`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone_num` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `factory_id` <span class="type">int</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/hexo-blog/./img/note/mysql%E7%94%BBer%E5%9B%BE/1-1717251498794-1.jpg" alt="1-1717251498794-1"></p><blockquote><h3 id="出版社表-publishers"><a href="#出版社表-publishers" class="headerlink" title="出版社表 (publishers)"></a>出版社表 (<code>publishers</code>)</h3><ul><li><code>PublisherID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个出版社。</li><li><code>Name</code>: VARCHAR(255), 出版社名称，不允许为空。</li><li><code>Address</code>: VARCHAR(255), 出版社地址。</li><li><code>Level</code>: ENUM(‘一级’, ‘二级’, ‘三级’), 出版社级别，预定义的几个选项。</li></ul><h3 id="图书表-books"><a href="#图书表-books" class="headerlink" title="图书表 (books)"></a>图书表 (<code>books</code>)</h3><ul><li><code>BookID</code>: INT, 主键, 自增, 不允许为空，唯一标识每本书。</li><li><code>Title</code>: VARCHAR(255), 书名，不允许为空。</li><li><code>ISBN</code>: VARCHAR(13), 国际标准书号，唯一，不允许为空。</li><li><code>Author</code>: VARCHAR(255), 作者名，不允许为空。</li><li><code>PublisherID</code>: INT, 外键，参考<code>publishers</code>表的<code>PublisherID</code>，表示该书的出版社。</li></ul><h3 id="学生表-students"><a href="#学生表-students" class="headerlink" title="学生表 (students)"></a>学生表 (<code>students</code>)</h3><ul><li><code>StudentID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个学生。</li><li><code>Name</code>: VARCHAR(255), 学生姓名，不允许为空。</li><li><code>Birthday</code>: DATE, 学生出生日期，不允许为空。</li></ul><h3 id="图书馆表-libraries"><a href="#图书馆表-libraries" class="headerlink" title="图书馆表 (libraries)"></a>图书馆表 (<code>libraries</code>)</h3><ul><li><code>LibraryID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个图书馆。</li><li><code>Name</code>: VARCHAR(255), 图书馆名称，不允许为空。</li><li><code>Director</code>: VARCHAR(255), 图书馆馆长名称。</li><li><code>UniversityID</code>: INT, 外键，参考<code>universities</code>表的<code>UniversityID</code>，表示图书馆所属的大学。</li></ul><h3 id="大学表-universities"><a href="#大学表-universities" class="headerlink" title="大学表 (universities)"></a>大学表 (<code>universities</code>)</h3><ul><li><code>UniversityID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个大学。</li><li><code>Name</code>: VARCHAR(255), 大学名称，不允许为空。</li><li><code>President</code>: VARCHAR(255), 大学校长名称。</li><li><code>EstablishmentDate</code>: DATE, 大学成立日期，不允许为空。</li></ul><h3 id="系部表-departments"><a href="#系部表-departments" class="headerlink" title="系部表 (departments)"></a>系部表 (<code>departments</code>)</h3><ul><li><code>DepartmentID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个系。</li><li><code>Name</code>: VARCHAR(255), 系部名称，不允许为空。</li><li><code>Dean</code>: VARCHAR(255), 系主任名称。</li><li><code>UniversityID</code>: INT, 外键，参考<code>universities</code>表的<code>UniversityID</code>，表示系部所属的大学。</li></ul><h3 id="班级表-classes"><a href="#班级表-classes" class="headerlink" title="班级表 (classes)"></a>班级表 (<code>classes</code>)</h3><ul><li><code>ClassID</code>: INT, 主键, 自增, 不允许为空，唯一标识每个班级。</li><li><code>ClassName</code>: VARCHAR(255), 班级名称，不允许为空。</li><li><code>HeadTeacher</code>: VARCHAR(255), 班主任名称。</li><li><code>DepartmentID</code>: INT, 外键，参考<code>departments</code>表的<code>DepartmentID</code>，表示班级所属的系部。</li></ul><h3 id="借阅记录表-borrow-records"><a href="#借阅记录表-borrow-records" class="headerlink" title="借阅记录表 (borrow_records)"></a>借阅记录表 (<code>borrow_records</code>)</h3><ul><li><code>RecordID</code>: INT, 主键, 自增, 不允许为空，唯一标识每次借阅记录。</li><li><code>StudentID</code>: INT, 外键，参考<code>students</code>表的<code>StudentID</code>，表示借书的学生。</li><li><code>BookID</code>: INT, 外键，参考<code>books</code>表的<code>BookID</code>，表示被借阅的书籍。</li><li><code>BorrowDate</code>: DATE, 借书日期，不允许为空。</li><li><code>DueDate</code>: DATE, 应还日期，不允许为空。</li><li><code>ReturnDate</code>: DATE, 实际归还日期，允许为空。</li></ul><h3 id="图书馆藏表-library-collections"><a href="#图书馆藏表-library-collections" class="headerlink" title="图书馆藏表 (library_collections)"></a>图书馆藏表 (<code>library_collections</code>)</h3><ul><li><code>CollectionID</code>: INT, 主键, 自增, 不允许为空，唯一标识图书馆的藏书记录。</li><li><code>LibraryID</code>: INT, 外键，参考<code>libraries</code>表的<code>LibraryID</code>，表示藏书所在的图书馆。</li><li><code>BookID</code>: INT, 外键，参考<code>books</code>表的<code>BookID</code>，表示图书馆收藏的书籍。</li><li><code>Quantity</code>: INT, 藏书数量，不允许为空。</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Publishers (</span><br><span class="line">    PublisherID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Address <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    Level ENUM(<span class="string">&#x27;一级&#x27;</span>, <span class="string">&#x27;二级&#x27;</span>, <span class="string">&#x27;三级&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Books (</span><br><span class="line">    BookID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Title <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    ISBN <span class="type">VARCHAR</span>(<span class="number">13</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Author <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    PublisherID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (PublisherID) <span class="keyword">REFERENCES</span> Publishers(PublisherID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Students (</span><br><span class="line">    StudentID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Libraries (</span><br><span class="line">    LibraryID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Director <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    UniversityID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (UniversityID) <span class="keyword">REFERENCES</span> Universities(UniversityID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Universities (</span><br><span class="line">    UniversityID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    President <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    EstablishmentDate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Departments (</span><br><span class="line">    DepartmentID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Dean <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    UniversityID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (UniversityID) <span class="keyword">REFERENCES</span> Universities(UniversityID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Classes (</span><br><span class="line">    ClassID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    ClassName <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    HeadTeacher <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    DepartmentID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (DepartmentID) <span class="keyword">REFERENCES</span> Departments(DepartmentID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> BorrowRecords (</span><br><span class="line">    RecordID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    StudentID <span class="type">INT</span>,</span><br><span class="line">    BookID <span class="type">INT</span>,</span><br><span class="line">    BorrowDate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    DueDate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    ReturnDate <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (StudentID) <span class="keyword">REFERENCES</span> Students(StudentID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (BookID) <span class="keyword">REFERENCES</span> Books(BookID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> LibraryCollections (</span><br><span class="line">    CollectionID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    LibraryID <span class="type">INT</span>,</span><br><span class="line">    BookID <span class="type">INT</span>,</span><br><span class="line">    Quantity <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (LibraryID) <span class="keyword">REFERENCES</span> Libraries(LibraryID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (BookID) <span class="keyword">REFERENCES</span> Books(BookID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Universities <span class="keyword">ADD</span> INDEX idx_UnivName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Publishers <span class="keyword">ADD</span> INDEX idx_PubName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Books <span class="keyword">ADD</span> INDEX idx_ISBN (ISBN);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students <span class="keyword">ADD</span> INDEX idx_StudentName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Libraries <span class="keyword">ADD</span> INDEX idx_LibName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Departments <span class="keyword">ADD</span> INDEX idx_DepName (Name);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Classes <span class="keyword">ADD</span> INDEX idx_ClassName (ClassName);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql第三章作业</title>
      <link href="/hexo-blog/2024/06/01/mysql%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
      <url>/hexo-blog/2024/06/01/mysql%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章PPT作业"><a href="#第三章PPT作业" class="headerlink" title="第三章PPT作业"></a>第三章PPT作业</h1><p><img src="/hexo-blog/./img/note/mysql%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BD%9C%E4%B8%9A/20240601mysql.png" alt="20240601mysql"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 学号 <span class="keyword">FROM</span> `成绩` <span class="keyword">WHERE</span> 课程号<span class="operator">=</span>&quot;1025&quot; <span class="keyword">AND</span> 成绩<span class="operator">&lt;</span><span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `学生` <span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> &quot;马%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 学号 <span class="keyword">FROM</span> `成绩` <span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号 <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(课程号)<span class="operator">&gt;=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 出生日期,年龄 <span class="keyword">FROM</span> `学生`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 学号,<span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> 生日) <span class="keyword">as</span> <span class="keyword">year</span>,<span class="number">2024</span><span class="operator">-</span><span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> 生日) <span class="keyword">as</span> age <span class="keyword">FROM</span> `学生`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 学号 <span class="keyword">FROM</span> 成绩 <span class="keyword">WHERE</span> 成绩<span class="operator">&gt;</span>(<span class="keyword">SELECT</span> 学号 <span class="keyword">from</span> 学生 <span class="keyword">WHERE</span> 姓名<span class="operator">=</span>&quot;刘玉&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm一对一</title>
      <link href="/hexo-blog/2024/06/01/gorm%E4%B8%80%E5%AF%B9%E4%B8%80/"/>
      <url>/hexo-blog/2024/06/01/gorm%E4%B8%80%E5%AF%B9%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="gorm一对一"><a href="#gorm一对一" class="headerlink" title="gorm一对一"></a>gorm一对一</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cuser <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    CompanyID <span class="type">int</span></span><br><span class="line">    Company   Company</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BelongTo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//_ = DB.AutoMigrate(&amp;Cuser&#123;&#125;, &amp;Company&#123;&#125;)</span></span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    user := Cuser&#123;</span><br><span class="line">        Name: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        Company: Company&#123;</span><br><span class="line">            Name: <span class="string">&quot;Company&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    DB.Create(&amp;user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找实例</span></span><br><span class="line">    <span class="keyword">var</span> user1 = Cuser&#123;&#125;</span><br><span class="line">    DB.Preload(<span class="string">&quot;Company&quot;</span>).First(&amp;user1)</span><br><span class="line">    formatPrint(user1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空一对一的关联关系</span></span><br><span class="line">    err := DB.Model(&amp;Cuser&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: user1.ID,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).Association(<span class="string">&quot;Company&quot;</span>).Clear()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;清空关联成功&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一对一的关联关系(需要&amp;)</span></span><br><span class="line">    err = DB.Model(&amp;Cuser&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: user1.ID,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).Association(<span class="string">&quot;Company&quot;</span>).Append(&amp;Company&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;绑定关联成功&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换一对一的关联关系(需要&amp;)</span></span><br><span class="line">    err = DB.Model(&amp;Cuser&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: user1.ID,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).Association(<span class="string">&quot;Company&quot;</span>).Replace(&amp;Company&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;, &amp;Company&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">666</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;替换关联成功&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一对一的关联关系(不需要&amp;)</span></span><br><span class="line">    err = DB.Model(&amp;Cuser&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: user1.ID,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).Association(<span class="string">&quot;Company&quot;</span>).Delete(Company&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">666</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;删除关联成功&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GirlGod <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    DogID <span class="type">int</span></span><br><span class="line">    Dog   Dog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = DB.AutoMigrate(&amp;Dog&#123;&#125;, &amp;GirlGod&#123;&#125;)</span><br><span class="line">    <span class="comment">// 新建数据</span></span><br><span class="line">    d := Dog&#123;</span><br><span class="line">        Name: <span class="string">&quot;舔狗1号&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    g := GirlGod&#123;</span><br><span class="line">        Name: <span class="string">&quot;girl&quot;</span>,</span><br><span class="line">        Dog:  d,</span><br><span class="line">    &#125;</span><br><span class="line">    DB.Create(&amp;g)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空一对一关联</span></span><br><span class="line">    d1 := Dog&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    g1 := GirlGod&#123;</span><br><span class="line">        Model: gorm.Model&#123;</span><br><span class="line">            ID: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _ = DB.Model(&amp;g1).Association(<span class="string">&quot;Dog&quot;</span>).Clear()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增关联</span></span><br><span class="line">    _ = DB.Model(&amp;g1).Association(<span class="string">&quot;Dog&quot;</span>).Append(&amp;d1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openguass中postgresql的增删改查</title>
      <link href="/hexo-blog/2024/06/01/openguass%E4%B8%ADpostgresql%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
      <url>/hexo-blog/2024/06/01/openguass%E4%B8%ADpostgresql%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="进入数据库"><a href="#进入数据库" class="headerlink" title="进入数据库"></a>进入数据库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gsql postgres</span><br></pre></td></tr></table></figure><h3 id="（1）创建用户："><a href="#（1）创建用户：" class="headerlink" title="（1）创建用户："></a>（1）创建用户：</h3><p><code>create user 用户名 with password &quot;用户密码&quot;;</code></p><h3 id="（2）创建数据库："><a href="#（2）创建数据库：" class="headerlink" title="（2）创建数据库："></a>（2）创建数据库：</h3><p><code>create database 数据库名 owner 用户名;</code></p><h3 id="（3）进入数据库："><a href="#（3）进入数据库：" class="headerlink" title="（3）进入数据库："></a>（3）进入数据库：</h3><p><code>gsql -d 数据库名 -p 15400 -r</code></p><h3 id="（4）创建表："><a href="#（4）创建表：" class="headerlink" title="（4）创建表："></a>（4）创建表：</h3><p><code>create table 表名 (字段名 字段类型,字段名 字段类型);</code><br>例：create table mytable (number int,year int);</p><h3 id="（5）向表中添加数据："><a href="#（5）向表中添加数据：" class="headerlink" title="（5）向表中添加数据："></a>（5）向表中添加数据：</h3><p><code>insert into 表名 values (字段值,字段值);</code><br>例：insert into mytable values (1,100),(2,200);</p><h3 id="（6）查看数据表："><a href="#（6）查看数据表：" class="headerlink" title="（6）查看数据表："></a>（6）查看数据表：</h3><p><code>select * from 表名;</code></p><p>查询pg_tables表获取当前数据库中所有表的信息（pg_tables是系统视图）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from pg_tables</span><br></pre></td></tr></table></figure><p>通常我们只关注public中的表，只需要加上以下查询条件即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select tablename from pg_tables where schemaname=&#x27;public&#x27;</span><br></pre></td></tr></table></figure><h3 id="（7）修改表中数据："><a href="#（7）修改表中数据：" class="headerlink" title="（7）修改表中数据："></a>（7）修改表中数据：</h3><p><code>update 表名 set 字段=修改后的字段值 where 字段=字段值;</code><br>例：update mytable set year&#x3D;300 where number&#x3D;2;</p><h3 id="（8）删除数据表中的数据："><a href="#（8）删除数据表中的数据：" class="headerlink" title="（8）删除数据表中的数据："></a>（8）删除数据表中的数据：</h3><p><code>delete 表名 where 字段=字段值;</code><br>例：delete mytable where number&#x3D;1;</p><h3 id="（9）增加表中的字段："><a href="#（9）增加表中的字段：" class="headerlink" title="（9）增加表中的字段："></a>（9）增加表中的字段：</h3><p><code>alter table 表名 add 字段 字段名;</code><br>例1：alter table mytable add country char;<br>例2：alter table mytable add mail char(20);</p><h3 id="（10）退出数据库："><a href="#（10）退出数据库：" class="headerlink" title="（10）退出数据库："></a>（10）退出数据库：</h3><p><code>\q</code></p><h3 id="（11）查看所有用户："><a href="#（11）查看所有用户：" class="headerlink" title="（11）查看所有用户："></a>（11）查看所有用户：</h3><p><code>\du</code></p><h3 id="（12）查看所有数据库："><a href="#（12）查看所有数据库：" class="headerlink" title="（12）查看所有数据库："></a>（12）查看所有数据库：</h3><p><code>\l</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker命令大全</title>
      <link href="/hexo-blog/2024/06/01/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/hexo-blog/2024/06/01/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#info|version</span></span><br><span class="line">docker info       <span class="comment">#显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker version    <span class="comment">#显示docker的版本信息。</span></span><br><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span> <span class="comment">#帮助命令</span></span><br><span class="line"><span class="comment">#镜像命令</span></span><br><span class="line">docker images <span class="comment">#查看所有本地主机上的镜像 可以使用docker image ls代替</span></span><br><span class="line">docker search <span class="comment">#搜索镜像</span></span><br><span class="line">docker pull <span class="comment">#下载镜像 docker image pull</span></span><br><span class="line">docker rmi <span class="comment">#删除镜像 docker image rm</span></span><br><span class="line"><span class="comment">#容器命令</span></span><br><span class="line">docker run 镜像<span class="built_in">id</span> <span class="comment">#新建容器并启动</span></span><br><span class="line">docker ps 列出所有运行的容器 docker container list</span><br><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span> <span class="comment">#删除指定容器</span></span><br><span class="line"><span class="comment">#删除所有容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -aq)       <span class="comment">#删除所有的容器</span></span><br><span class="line">docker ps -a -q|xargs docker <span class="built_in">rm</span>  <span class="comment">#删除所有的容器</span></span><br><span class="line"><span class="comment">#启动和停止容器</span></span><br><span class="line">docker start 容器<span class="built_in">id</span>    <span class="comment">#启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span>    <span class="comment">#重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>    <span class="comment">#停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span>    <span class="comment">#强制停止当前容器</span></span><br><span class="line"><span class="comment">#退出容器</span></span><br><span class="line"><span class="built_in">exit</span>         <span class="comment">#容器直接退出</span></span><br><span class="line">ctrl +P +Q  <span class="comment">#容器不停止退出     ---注意：这个很有用的操作</span></span><br><span class="line"><span class="comment">#其他常用命令</span></span><br><span class="line">docker run -d 镜像名  <span class="comment">#后台启动命令</span></span><br><span class="line">docker logs         <span class="comment">#查看日志</span></span><br><span class="line">docker top 容器<span class="built_in">id</span>     <span class="comment">#查看容器中进程信息ps</span></span><br><span class="line">docker inspect 容器<span class="built_in">id</span>  <span class="comment">#查看镜像的元数据</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 899c718ac4fe(容器<span class="built_in">id</span>) /bin/bash  <span class="comment">#进入当前容器后开启一个新的终端，可以在里面操作。（常用）</span></span><br><span class="line">docker attach         <span class="comment"># 进入容器正在执行的终端</span></span><br><span class="line">docker <span class="built_in">cp</span> 容器<span class="built_in">id</span>:容器内路径  主机目的路径    <span class="comment">#从容器内拷贝到主机上</span></span><br></pre></td></tr></table></figure><h2 id="docker命令大全"><a href="#docker命令大全" class="headerlink" title="docker命令大全"></a>docker命令大全</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker attach    <span class="comment">#连接到正在运行中的容器</span></span><br><span class="line">docker build    <span class="comment">#使用 Dockerfile 创建镜像</span></span><br><span class="line">docker builder    <span class="comment">#管理builds</span></span><br><span class="line">docker builder prune    <span class="comment">#清除build缓存</span></span><br><span class="line">docker checkpoint    <span class="comment">#管理checkpoints</span></span><br><span class="line">docker checkpoint create    <span class="comment">#从正在运行的容器创建检查点</span></span><br><span class="line">docker checkpoint <span class="built_in">ls</span>    <span class="comment">#列出容器的检查点</span></span><br><span class="line">docker checkpoint <span class="built_in">rm</span>    <span class="comment">#删除指定的检查点</span></span><br><span class="line">docker commit    <span class="comment">#从容器创建一个新的镜像</span></span><br><span class="line">docker config    <span class="comment">#管理Docker配置</span></span><br><span class="line">docker config create    <span class="comment">#创建配置文件</span></span><br><span class="line">docker config inspect    <span class="comment">#查看配置文件信息</span></span><br><span class="line">docker config <span class="built_in">ls</span>        <span class="comment">#显示docker里已经保存得配置文件</span></span><br><span class="line">docker config <span class="built_in">rm</span>        <span class="comment">#删除配置文件</span></span><br><span class="line">docker container    <span class="comment">#管理容器</span></span><br><span class="line">docker container prune    <span class="comment">#删除所有已停止的容器</span></span><br><span class="line">docker context    <span class="comment">#管理contexts</span></span><br><span class="line">docker context create    <span class="comment">#创建一个上下文</span></span><br><span class="line">docker context <span class="built_in">export</span>    <span class="comment">#将上下文导出到tar或kubecconfig文件中</span></span><br><span class="line">docker context import    <span class="comment">#从tar或zip文件导入上下文</span></span><br><span class="line">docker context inspect    <span class="comment">#在一个或多个上下文上显示详细信息</span></span><br><span class="line">docker context <span class="built_in">ls</span>        <span class="comment">#列出上下文</span></span><br><span class="line">docker context <span class="built_in">rm</span>        <span class="comment">#删除一个或多个上下文</span></span><br><span class="line">docker context update    <span class="comment">#更新</span></span><br><span class="line">docker context use        <span class="comment">#设置当前docker的上下文</span></span><br><span class="line">docker <span class="built_in">cp</span>        <span class="comment">#用于容器与主机之间的数据拷贝</span></span><br><span class="line">docker create    <span class="comment">#创建一个新的容器但不启动它</span></span><br><span class="line">docker diff        <span class="comment">#检查容器里文件结构的更改</span></span><br><span class="line">docker events    <span class="comment">#从服务器获取实时事件</span></span><br><span class="line">docker <span class="built_in">exec</span>        <span class="comment">#在运行的容器中执行命令</span></span><br><span class="line">docker <span class="built_in">export</span>    <span class="comment">#将文件系统作为一个tar归档文件导出到STDOUT</span></span><br><span class="line">docker <span class="built_in">history</span>    <span class="comment">#查看指定镜像的创建历史</span></span><br><span class="line">docker image    <span class="comment">#管理镜像</span></span><br><span class="line">docker image inspect    <span class="comment">#显示一个或多个镜像的元数据</span></span><br><span class="line">docker image <span class="built_in">ls</span>            <span class="comment">#列出本地镜像</span></span><br><span class="line">docker image prune        <span class="comment">#删除没有使用的镜像</span></span><br><span class="line">docker image <span class="built_in">rm</span>            <span class="comment">#删除一个或多个镜像</span></span><br><span class="line">docker images    <span class="comment">#列出本地镜像</span></span><br><span class="line">docker import    <span class="comment">#从归档文件中创建镜像</span></span><br><span class="line">docker info        <span class="comment">#显示 Docker 系统信息，包括镜像和容器数</span></span><br><span class="line">docker inspect    <span class="comment">#获取容器/镜像的元数据</span></span><br><span class="line">docker <span class="built_in">kill</span>        <span class="comment">#杀掉一个运行中的容器</span></span><br><span class="line">docker load        <span class="comment">#导入使用 docker save 命令导出的镜像</span></span><br><span class="line">docker login    <span class="comment">#登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</span></span><br><span class="line">docker <span class="built_in">logout</span>    <span class="comment">#登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</span></span><br><span class="line">docker logs        <span class="comment">#获取容器的日志</span></span><br><span class="line">docker manifest    <span class="comment">#管理manifest(实验，不应用于生产环境)</span></span><br><span class="line">docker manifest annotate    <span class="comment">#向本地镜像清单添加附加信息</span></span><br><span class="line">docker manifest create        <span class="comment">#创建用于注释和推入注册表的本地清单列表</span></span><br><span class="line">docker manifest inspect        <span class="comment">#显示镜像清单或清单列表</span></span><br><span class="line">docker manifest push        <span class="comment">#将清单列表推入仓库</span></span><br><span class="line">docker manifest <span class="built_in">rm</span>            <span class="comment">#从本地存储中删除一个或多个清单列表</span></span><br><span class="line">docker network    <span class="comment">#管理网络</span></span><br><span class="line">docker network connect        <span class="comment">#将容器连接到网络</span></span><br><span class="line">docker network create        <span class="comment">#创建一个网络</span></span><br><span class="line">docker network disconnect    <span class="comment">#断开容器的网络</span></span><br><span class="line">docker network inspect        <span class="comment">#显示一个或多个网络的元数据</span></span><br><span class="line">docker network <span class="built_in">ls</span>            <span class="comment">#列出网络</span></span><br><span class="line">docker network prune        <span class="comment">#删除所有没有使用的网络</span></span><br><span class="line">docker network <span class="built_in">rm</span>            <span class="comment">#删除一个或多个网络</span></span><br><span class="line">docker node        <span class="comment">#管理集群(swarm)节点</span></span><br><span class="line">docker node demote            <span class="comment">#从群集(swarm)管理器中降级一个或多个节点</span></span><br><span class="line">docker node inspect            <span class="comment">#显示一个或多个节点的元数据</span></span><br><span class="line">docker node <span class="built_in">ls</span>                <span class="comment">#列出群集(swarm)中的节点</span></span><br><span class="line">docker node promote            <span class="comment">#将一个或多个节点推入到群集管理器中</span></span><br><span class="line">docker node ps                <span class="comment">#列出在一个或多个节点上运行的任务，默认为当前节点</span></span><br><span class="line">docker node <span class="built_in">rm</span>                <span class="comment">#从群集(swarm)删除一个或多个节点</span></span><br><span class="line">docker node update            <span class="comment">#更新一个节点</span></span><br><span class="line">docker pause    <span class="comment">#暂停容器中所有的进程</span></span><br><span class="line">docker plugin    <span class="comment">#管理插件</span></span><br><span class="line">docker plugin create        <span class="comment">#从rootfs和配置创建一个插件。插件数据目录必须包含config.json和rootfs目录。</span></span><br><span class="line">docker plugin <span class="built_in">disable</span>        <span class="comment">#禁用插件</span></span><br><span class="line">docker plugin <span class="built_in">enable</span>        <span class="comment">#启用插件</span></span><br><span class="line">docker plugin inspect        <span class="comment">#显示一个或多个插件的元数据</span></span><br><span class="line">docker plugin install        <span class="comment">#安装一个插件</span></span><br><span class="line">docker plugin <span class="built_in">ls</span>            <span class="comment">#列出所有插件</span></span><br><span class="line">docker plugin push            <span class="comment">#将插件推送到注册表</span></span><br><span class="line">docker plugin <span class="built_in">rm</span>            <span class="comment">#删除一个或多个插件</span></span><br><span class="line">docker plugin <span class="built_in">set</span>            <span class="comment">#更改插件的设置</span></span><br><span class="line">docker plugin upgrade        <span class="comment">#升级现有插件</span></span><br><span class="line">docker port        <span class="comment">#列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口</span></span><br><span class="line">docker ps        <span class="comment">#列出容器</span></span><br><span class="line">docker pull        <span class="comment">#从镜像仓库中拉取或者更新指定镜像</span></span><br><span class="line">docker push        <span class="comment">#将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</span></span><br><span class="line">docker rename    <span class="comment">#重命名容器</span></span><br><span class="line">docker restart    <span class="comment">#重启容器</span></span><br><span class="line">docker <span class="built_in">rm</span>        <span class="comment">#删除一个或多个容器</span></span><br><span class="line">docker rmi        <span class="comment">#删除一个或多个镜像</span></span><br><span class="line">docker run        <span class="comment">#创建一个新的容器并运行一个命令</span></span><br><span class="line">docker save        <span class="comment">#将指定镜像保存成 tar 归档文件</span></span><br><span class="line">docker search    <span class="comment">#从Docker Hub查找镜像</span></span><br><span class="line">docker secret    <span class="comment">#管理Docker secrets</span></span><br><span class="line">docker secret create    <span class="comment">#从文件或STDIN创建一个秘密作为内容</span></span><br><span class="line">docker secret inspect    <span class="comment">#显示有关一个或多个秘密的详细信息</span></span><br><span class="line">docker secret <span class="built_in">ls</span>        <span class="comment">#列出秘密</span></span><br><span class="line">docker secret <span class="built_in">rm</span>        <span class="comment">#删除一个或多个秘密</span></span><br><span class="line">docker service    <span class="comment">#管理服务</span></span><br><span class="line">docker service create    <span class="comment">#创建一个服务</span></span><br><span class="line">docker service inspect    <span class="comment">#查看服务的元数据</span></span><br><span class="line">docker service logs        <span class="comment">#获取服务的日志</span></span><br><span class="line">docker service <span class="built_in">ls</span>        <span class="comment">#列出服务</span></span><br><span class="line">docker service ps        <span class="comment">#列出一个或多个服务的任务</span></span><br><span class="line">docker service <span class="built_in">rm</span>        <span class="comment">#删除一个或多个服务</span></span><br><span class="line">docker service rollback    <span class="comment">#将更改恢复到服务的配置</span></span><br><span class="line">docker service scale    <span class="comment">#缩放一个或多个复制服务</span></span><br><span class="line">docker service update    <span class="comment">#更新服务</span></span><br><span class="line">docker stack    <span class="comment">#管理堆栈</span></span><br><span class="line">docker stack deploy        <span class="comment">#部署新的堆栈或更新现有堆栈</span></span><br><span class="line">docker stack <span class="built_in">ls</span>            <span class="comment">#列出现有堆栈</span></span><br><span class="line">docker stack ps            <span class="comment">#列出堆栈中的任务</span></span><br><span class="line">docker stack <span class="built_in">rm</span>            <span class="comment">#删除堆栈    </span></span><br><span class="line">docker stack services    <span class="comment">#列出堆栈中的服务</span></span><br><span class="line">docker start    <span class="comment">#启动一个或多个已经被停止的容器</span></span><br><span class="line">docker stats    <span class="comment">#显示容器的实时流资源使用统计信息</span></span><br><span class="line">docker stop        <span class="comment">#停止一个运行中的容器</span></span><br><span class="line">docker swarm    <span class="comment">#管理集群(Swarm)</span></span><br><span class="line">docker swarm ca            <span class="comment">#查看或旋转当前群集CA证书。此命令必须针对管理器节点</span></span><br><span class="line">docker swarm init        <span class="comment">#初始化一个群集(Swarm)</span></span><br><span class="line">docker swarm <span class="built_in">join</span>        <span class="comment">#加入群集作为节点和/或管理器</span></span><br><span class="line">docker swarm join-token    <span class="comment">#管理加入令牌</span></span><br><span class="line">docker swarm leave        <span class="comment">#离开群集(Swarm)</span></span><br><span class="line">docker swarm unlock        <span class="comment">#解锁群集(Swarm)</span></span><br><span class="line">docker swarm unlock-key    <span class="comment">#管理解锁钥匙</span></span><br><span class="line">docker swarm update        <span class="comment">#更新群集(Swarm)</span></span><br><span class="line">docker system    <span class="comment">#管理Docker</span></span><br><span class="line">docker system <span class="built_in">df</span>        <span class="comment">#显示docker磁盘使用情况</span></span><br><span class="line">docker system events    <span class="comment">#从服务器获取实时事件</span></span><br><span class="line">docker system info        <span class="comment">#显示系统范围的信息</span></span><br><span class="line">docker system prune        <span class="comment">#删除未使用的数据</span></span><br><span class="line">docker tag        <span class="comment">#标记本地镜像，将其归入某一仓库</span></span><br><span class="line">docker top        <span class="comment">#查看容器中运行的进程信息，支持 ps 命令参数</span></span><br><span class="line">docker trust    <span class="comment">#管理Docker镜像的信任</span></span><br><span class="line">docker trust inspect    <span class="comment">#返回有关key和签名的低级信息</span></span><br><span class="line">docker trust key        <span class="comment">#管理登入Docker镜像的keys</span></span><br><span class="line">docker trust key generate    <span class="comment">#生成并加载签名密钥对</span></span><br><span class="line">docker trust key load        <span class="comment">#加载私钥文件以进行签名</span></span><br><span class="line">docker trust revoke        <span class="comment">#删除对镜像的认证</span></span><br><span class="line">docker trust sign        <span class="comment">#镜像签名</span></span><br><span class="line">docker trust signer        <span class="comment">#管理可以登录Docker镜像的实体</span></span><br><span class="line">docker trust signer add        <span class="comment">#新增一个签名者</span></span><br><span class="line">docker trust signer remove    <span class="comment">#删除一个签名者</span></span><br><span class="line">docker unpause    <span class="comment">#恢复容器中所有的进程</span></span><br><span class="line">docker update    <span class="comment">#更新一个或多个容器的配置</span></span><br><span class="line">docker version    <span class="comment">#显示 Docker 版本信息</span></span><br><span class="line">docker volume    <span class="comment">#管理volumes</span></span><br><span class="line">docker volume create    <span class="comment">#创建一个卷</span></span><br><span class="line">docker volume inspect    <span class="comment">#显示一个或多个卷的元数据</span></span><br><span class="line">docker volume <span class="built_in">ls</span>        <span class="comment">#列出卷</span></span><br><span class="line">docker volume prune        <span class="comment">#删除所有未使用的卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span>        <span class="comment">#删除一个或多个卷</span></span><br><span class="line">docker <span class="built_in">wait</span>        <span class="comment">#阻塞运行直到容器停止，然后打印出它的退出代码</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3下pinia的使用</title>
      <link href="/hexo-blog/2024/06/01/vue3%E4%B8%8Bpinia%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/hexo-blog/2024/06/01/vue3%E4%B8%8Bpinia%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-中-pinia-的使用"><a href="#Vue3-中-pinia-的使用" class="headerlink" title="Vue3 中 pinia 的使用"></a>Vue3 中 pinia 的使用</h1><blockquote><p><strong>pinia 是一款 vue 插件,作用是对 vue 中的数据做持久化存储,并且允许你跨组件或页面共享状态</strong></p></blockquote><p><strong>下载 pinia</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -d pinia</span><br></pre></td></tr></table></figure><p><strong>在 mian.js 中添加:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>();</span><br><span class="line">app.<span class="title function_">use</span>(pinia);</span><br></pre></td></tr></table></figure><p><strong>常用 API</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">createPinia defineStore storeToRefs</span><br></pre></td></tr></table></figure><p><strong>stores&#x2F;counter.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; computed, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&quot;countId&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> list = <span class="title function_">ref</span>([]);</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">API_URL</span> = <span class="string">&quot;https://applet-base-api-t.itheima.net/api/cart&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">const</span> doubleCount = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// action</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count.<span class="property">value</span>++;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getList</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="variable constant_">API_URL</span>);</span><br><span class="line">    list.<span class="property">value</span> = res.<span class="property">data</span>.<span class="property">list</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    list,</span><br><span class="line">    doubleCount,</span><br><span class="line">    increment,</span><br><span class="line">    getList,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>App.vue</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; useCounterStore &#125; <span class="keyword">from</span> <span class="string">&quot;@/stores/counter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; onMounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useCounterStore</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; count, doubleCount, list &#125; = <span class="title function_">storeToRefs</span>(store);</span><br><span class="line"><span class="keyword">const</span> &#123; increment, getList &#125; = store;</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">getList</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>count的值为:  &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>count * 2的值为:  &#123;&#123; doubleCount &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>按钮(点击后count++)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;good in list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      goods_id:&#123;&#123; good.goods_id &#125;&#125; goods_name:&#123;&#123; good.goods_name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm的关联关系</title>
      <link href="/hexo-blog/2024/06/01/gorm/"/>
      <url>/hexo-blog/2024/06/01/gorm/</url>
      
        <content type="html"><![CDATA[<h1 id="gorm-的-Many-To-Many"><a href="#gorm-的-Many-To-Many" class="headerlink" title="gorm 的 Many To Many"></a>gorm 的 Many To Many</h1><h2 id="Many-To-Many"><a href="#Many-To-Many" class="headerlink" title="Many To Many"></a>Many To Many</h2><p>Many to Many 会在两个 model 中添加一张连接表。</p><p>例如，您的应用包含了 user 和 language，且一个 user 可以说多种 language，多个 user 也可以说一种 language。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 拥有并属于多种 language，`user_languages` 是连接表</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []Language <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 GORM 的 <code>AutoMigrate</code> 为 <code>User</code> 创建表时，GORM 会自动创建连接表</p><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 拥有并属于多种 language，`user_languages` 是连接表</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []*Language <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Users []*User <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写外键"><a href="#重写外键" class="headerlink" title="重写外键"></a>重写外键</h2><p>对于 <code>many2many</code> 关系，连接表会同时拥有两个模型的外键，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []Language <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Join Table: user_languages</span></span><br><span class="line"><span class="comment">//   foreign key: user_id, reference: users.id</span></span><br><span class="line"><span class="comment">//   foreign key: language_id, reference: languages.id</span></span><br></pre></td></tr></table></figure><p>若要重写它们，可以使用标签 <code>foreignKey</code>、<code>references</code>、<code>joinforeignKey</code>、<code>joinReferences</code>。当然，您不需要使用全部的标签，你可以仅使用其中的一个重写部分的外键、引用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Profiles []Profile <span class="string">`gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;`</span></span><br><span class="line">    Refer    <span class="type">uint</span>      <span class="string">`gorm:&quot;index:,unique&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    UserRefer <span class="type">uint</span> <span class="string">`gorm:&quot;index:,unique&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这会创建连接表：user_profiles</span></span><br><span class="line"><span class="comment">//   外键: user_refer_id, 引用: users.refer</span></span><br><span class="line"><span class="comment">//   外键: profile_refer, 引用: profiles.user_refer</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 某些数据库只允许在唯一索引字段上创建外键，如果您在迁移时会创建外键，则需要指定 <code>unique index</code> 标签。</p></blockquote><h2 id="自引用-Many2Many"><a href="#自引用-Many2Many" class="headerlink" title="自引用 Many2Many"></a>自引用 Many2Many</h2><p>自引用 many2many 关系</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">    Friends []*User <span class="string">`gorm:&quot;many2many:user_friends&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会创建连接表：user_friends</span></span><br><span class="line"><span class="comment">//   foreign key: user_id, reference: users.id</span></span><br><span class="line"><span class="comment">//   foreign key: friend_id, reference: users.id</span></span><br></pre></td></tr></table></figure><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>GORM 可以通过 <code>Preload</code> 预加载 has many 关联的记录，查看 <a href="https://gorm.io/zh_CN/docs/preload.html">预加载</a> 获取详情</p><h2 id="Many2Many-的-CURD"><a href="#Many2Many-的-CURD" class="headerlink" title="Many2Many 的 CURD"></a>Many2Many 的 CURD</h2><p>查看 <a href="https://gorm.io/zh_CN/docs/associations.html#Association-Mode">关联模式</a> 获取 many2many 相关的用法</p><h2 id="自定义连接表"><a href="#自定义连接表" class="headerlink" title="自定义连接表"></a>自定义连接表</h2><p><code>连接表</code> 可以是一个全功能的模型，支持 <code>Soft Delete</code>、<code>钩子</code>、定义更多的字段，就跟其它模型一样。您可以通过 <code>SetupJoinTable</code> 指定它，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">int</span></span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  Addresses []Address <span class="string">`gorm:&quot;many2many:person_addresses;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">uint</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonAddress <span class="keyword">struct</span> &#123;</span><br><span class="line">  PersonID  <span class="type">int</span></span><br><span class="line">  AddressID <span class="type">int</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(PersonAddress)</span></span> BeforeCreate(db *gorm.DB) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 Person 的 Addresses 字段的连接表为 PersonAddress</span></span><br><span class="line"><span class="comment">// PersonAddress 必须定义好所需的外键，否则会报错</span></span><br><span class="line">err := db.SetupJoinTable(&amp;Person&#123;&#125;, <span class="string">&quot;Addresses&quot;</span>, &amp;PersonAddress&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>你可以通过为标签 <code>constraint</code> 配置 <code>OnUpdate</code>、<code>OnDelete</code> 实现外键约束，在使用 GORM 进行迁移时它会被创建，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []Language <span class="string">`gorm:&quot;many2many:user_speaks;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  Code <span class="type">string</span> <span class="string">`gorm:&quot;primarykey&quot;`</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CREATE TABLE `user_speaks` (`user_id` integer,`language_code` text,PRIMARY KEY (`user_id`,`language_code`),CONSTRAINT `fk_user_speaks_user` FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE SET NULL ON UPDATE CASCADE,CONSTRAINT `fk_user_speaks_language` FOREIGN KEY (`language_code`) REFERENCES `languages`(`code`) ON DELETE SET NULL ON UPDATE CASCADE);</span></span><br></pre></td></tr></table></figure><p>你也可以在删除记录时通过 <code>Select</code> 来删除 many2many 关系的记录，查看 <a href="https://gorm.io/zh_CN/docs/associations.html#delete_with_select">Delete with Select</a> 获取详情</p><h2 id="复合外键"><a href="#复合外键" class="headerlink" title="复合外键"></a>复合外键</h2><p>如果您的模型使用了 <a href="https://gorm.io/zh_CN/docs/composite_primary_key.html">复合主键</a>，GORM 会默认启用复合外键。</p><p>您也可以覆盖默认的外键、指定多个外键，只需用逗号分隔那些键名，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tag <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID     <span class="type">uint</span>   <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  Locale <span class="type">string</span> <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  Value  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID         <span class="type">uint</span>   <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  Locale     <span class="type">string</span> <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  Subject    <span class="type">string</span></span><br><span class="line">  Body       <span class="type">string</span></span><br><span class="line">  Tags       []Tag <span class="string">`gorm:&quot;many2many:blog_tags;&quot;`</span></span><br><span class="line">  LocaleTags []Tag <span class="string">`gorm:&quot;many2many:locale_blog_tags;ForeignKey:id,locale;References:id&quot;`</span></span><br><span class="line">  SharedTags []Tag <span class="string">`gorm:&quot;many2many:shared_blog_tags;ForeignKey:id;References:id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接表：blog_tags</span></span><br><span class="line"><span class="comment">//   foreign key: blog_id, reference: blogs.id</span></span><br><span class="line"><span class="comment">//   foreign key: blog_locale, reference: blogs.locale</span></span><br><span class="line"><span class="comment">//   foreign key: tag_id, reference: tags.id</span></span><br><span class="line"><span class="comment">//   foreign key: tag_locale, reference: tags.locale</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接表：locale_blog_tags</span></span><br><span class="line"><span class="comment">//   foreign key: blog_id, reference: blogs.id</span></span><br><span class="line"><span class="comment">//   foreign key: blog_locale, reference: blogs.locale</span></span><br><span class="line"><span class="comment">//   foreign key: tag_id, reference: tags.id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接表：shared_blog_tags</span></span><br><span class="line"><span class="comment">//   foreign key: blog_id, reference: blogs.id</span></span><br><span class="line"><span class="comment">//   foreign key: tag_id, reference: tags.id</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gorm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
